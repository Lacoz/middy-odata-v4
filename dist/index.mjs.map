{"version":3,"file":"index.mjs","sources":["../src/core/parse.ts","../src/middleware/index.ts","../src/core/errors.ts","../src/core/shape.ts","../src/core/filter-order.ts","../src/core/serialize.ts"],"sourcesContent":["import type { ODataQueryOptions } from \"./types\";\n\nexport function parseODataQuery(query: Record<string, string | undefined>): ODataQueryOptions {\n  const opts: ODataQueryOptions = {};\n  const sel = query[\"$select\"];\n  if (sel) opts.select = sel.split(\",\").map((s) => s.trim()).filter(Boolean);\n  const orderby = query[\"$orderby\"];\n  if (orderby) {\n    opts.orderby = orderby.split(\",\").map((term) => {\n      const [prop, dir] = term.trim().split(/\\s+/);\n      return { property: prop, direction: (dir?.toLowerCase() === \"desc\" ? \"desc\" : \"asc\") };\n    });\n  }\n  const top = query[\"$top\"];\n  if (top !== undefined) opts.top = Math.max(0, Number(top));\n  const skip = query[\"$skip\"];\n  if (skip !== undefined) opts.skip = Math.max(0, Number(skip));\n  const count = query[\"$count\"];\n  if (count !== undefined) opts.count = String(count).toLowerCase() === \"true\";\n  const filter = query[\"$filter\"];\n  if (filter) opts.filter = filter;\n  const expand = query[\"$expand\"];\n  if (expand) {\n    opts.expand = expand.split(\",\").map((e) => ({ path: e.trim() }));\n  }\n  return opts;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataRequestContext, ODataQueryOptions, EdmModel } from \"../core/types\";\nimport { parseODataQuery } from \"../core/parse\";\n\nexport interface ODataMiddlewareOptions {\n  model: EdmModel;\n  serviceRoot: string | ((event: any) => string);\n  enable?: {\n    compute?: boolean;\n    apply?: boolean;\n    search?: boolean;\n  };\n  defaults?: {\n    maxTop?: number;\n    defaultTop?: number;\n  };\n}\n\nexport function odata(options: ODataMiddlewareOptions): MiddlewareObj {\n  return {\n    before: async (request: any) => {\n      const event = request.event ?? {};\n      const query: Record<string, string> = event.rawQueryString\n        ? Object.fromEntries(new URLSearchParams(event.rawQueryString))\n        : (event.queryStringParameters || {});\n      const opts: ODataQueryOptions = parseODataQuery(query);\n      const serviceRoot = typeof options.serviceRoot === \"function\" ? options.serviceRoot(event) : options.serviceRoot;\n      const ctx: ODataRequestContext = {\n        model: options.model,\n        serviceRoot,\n        entitySet: undefined,\n        options: opts,\n      };\n      request.internal = request.internal || {};\n      request.internal.odata = ctx;\n    },\n  };\n}\n","import type { ODataErrorPayload, EdmModel } from \"./types\";\n\nexport class ODataBadRequest extends Error {\n  statusCode = 400;\n  code = \"BadRequest\";\n}\n\nexport class ODataInternalServerError extends Error {\n  statusCode = 500;\n  code = \"InternalServerError\";\n}\n\nexport function toODataError(err: unknown, message?: string): ODataErrorPayload {\n  if (err && typeof err === \"object\" && \"statusCode\" in err && \"message\" in err) {\n    const e = err as any;\n    return { error: { code: e.code ?? String(e.statusCode), message: e.message } };\n  }\n  return { error: { code: \"InternalServerError\", message: message ?? \"An error occurred\" } };\n}\n\n// Validation functions for OData query parameters\nexport function validateSelectParameters(select: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!select || select.length === 0) return;\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  for (const property of select) {\n    if (!validProperties.includes(property)) {\n      throw new ODataBadRequest(`Property '${property}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateFilterExpression(filter: string | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!filter) return;\n  \n  // Basic filter validation - check for common syntax errors\n  if (filter.includes('()')) {\n    throw new ODataBadRequest(\"Invalid filter expression: empty parentheses\");\n  }\n  \n  if (filter.includes('  ')) {\n    throw new ODataBadRequest(\"Invalid filter expression: multiple spaces\");\n  }\n  \n  // Check for balanced parentheses\n  let parenCount = 0;\n  for (const char of filter) {\n    if (char === '(') parenCount++;\n    if (char === ')') parenCount--;\n    if (parenCount < 0) {\n      throw new ODataBadRequest(\"Invalid filter expression: unmatched closing parenthesis\");\n    }\n  }\n  if (parenCount !== 0) {\n    throw new ODataBadRequest(\"Invalid filter expression: unmatched opening parenthesis\");\n  }\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  // Extract property names from filter (simple regex-based approach)\n  // Skip string literals (text in single quotes)\n  const filterWithoutStrings = filter.replace(/'[^']*'/g, '');\n  const propertyMatches = filterWithoutStrings.match(/\\b([a-zA-Z_][a-zA-Z0-9_]*)\\b/g) || [];\n  for (const match of propertyMatches) {\n    if (!['eq', 'ne', 'gt', 'ge', 'lt', 'le', 'and', 'or', 'not', 'true', 'false', 'null'].includes(match) && \n        !validProperties.includes(match)) {\n      throw new ODataBadRequest(`Property '${match}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateOrderByProperties(orderby: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!orderby || orderby.length === 0) return;\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  for (const orderByItem of orderby) {\n    const [property] = orderByItem.split(' ');\n    if (!validProperties.includes(property)) {\n      throw new ODataBadRequest(`Property '${property}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateExpandNavigationProperties(expand: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!expand || expand.length === 0) return;\n  \n  // Get entity type navigation properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validNavigationProperties = entityTypeDef.navigation?.map(np => np.name) || [];\n  \n  for (const navigationProperty of expand) {\n    if (!validNavigationProperties.includes(navigationProperty)) {\n      throw new ODataBadRequest(`Navigation property '${navigationProperty}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateEdmModelConstraints(entity: any, entityType: string, edmModel: EdmModel): void {\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  // Check required properties (assume all properties are required if nullable is not explicitly set to true)\n  const requiredProperties = entityTypeDef.properties?.filter(p => p.nullable !== true) || [];\n  for (const property of requiredProperties) {\n    if (!(property.name in entity) || entity[property.name] === null || entity[property.name] === undefined) {\n      throw new ODataBadRequest(`Required property '${property.name}' is missing or null`);\n    }\n  }\n  \n  // Check property types (basic validation)\n  for (const property of entityTypeDef.properties || []) {\n    if (property.name in entity) {\n      const value = entity[property.name];\n      if (value !== null && value !== undefined) {\n        // Basic type checking\n        if (property.type === 'Edm.String' && typeof value !== 'string') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a string`);\n        }\n        if ((property.type === 'Edm.Int32' || property.type === 'Edm.Decimal') && typeof value !== 'number') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a number`);\n        }\n        if (property.type === 'Edm.Boolean' && typeof value !== 'boolean') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a boolean`);\n        }\n      }\n    }\n  }\n}\n\n// HTTP status code mapping\nexport function getHttpStatusCode(error: Error): number {\n  if (error instanceof ODataBadRequest) {\n    return 400;\n  }\n  if (error instanceof ODataInternalServerError) {\n    return 500;\n  }\n  // Default to 500 for unknown errors\n  return 500;\n}\n\nexport function isValidationError(error: Error): boolean {\n  return error instanceof ODataBadRequest;\n}\n\nexport function isServerError(error: Error): boolean {\n  return error instanceof ODataInternalServerError;\n}\n","import type { ODataEntity, ODataQueryOptions } from \"./types\";\n\nexport function applySelect<T extends ODataEntity>(row: T, select?: string[]): Partial<T> {\n  if (!select || select.length === 0) return { ...row };\n  const out: Record<string, unknown> = {};\n  for (const p of select) if (p in row) out[p] = (row as any)[p];\n  return out as Partial<T>;\n}\n\nexport function projectArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): Partial<T>[] {\n  return rows.map((r) => applySelect(r, options.select));\n}\n\n// Expand navigation properties\nexport function expandData<T extends Record<string, any>>(\n  data: T | T[],\n  options: ODataQueryOptions\n): T | T[] {\n  if (!options.expand || options.expand.length === 0) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map(item => expandData(item, options) as T);\n  }\n\n  const expanded = { ...data } as any;\n  \n  for (const expandItem of options.expand) {\n    const navigationProperty = expandItem.path;\n    \n    // Simple expansion - in a real implementation, this would resolve navigation properties\n    // For now, we'll just ensure the property exists\n    if (navigationProperty && !(navigationProperty in expanded)) {\n      // Create a placeholder for the expanded property\n      expanded[navigationProperty] = null;\n    }\n    \n    // Handle nested query options in expansion\n    if (expandItem.options) {\n      const nestedData = expanded[navigationProperty];\n      if (nestedData) {\n        expanded[navigationProperty] = expandData(nestedData, expandItem.options);\n      }\n    }\n  }\n  \n  return expanded as T;\n}\n","import type { ODataEntity, ODataQueryOptions } from \"./types\";\n\n// Simple filter expression parser and evaluator\ninterface FilterExpression {\n  type: 'comparison' | 'logical' | 'function' | 'property' | 'literal';\n  operator?: string;\n  left?: FilterExpression;\n  right?: FilterExpression;\n  property?: string;\n  value?: any;\n  function?: string;\n  args?: FilterExpression[];\n}\n\nfunction parseFilterExpression(filter: string): FilterExpression {\n  // Simple parser for basic filter expressions\n  // This is a simplified implementation - a full OData parser would be much more complex\n  \n  // Handle parentheses and logical operators\n  if (filter.includes(' and ')) {\n    const parts = splitByOperator(filter, ' and ');\n    return {\n      type: 'logical',\n      operator: 'and',\n      left: parseFilterExpression(parts[0].trim()),\n      right: parseFilterExpression(parts[1].trim())\n    };\n  }\n  \n  if (filter.includes(' or ')) {\n    const parts = splitByOperator(filter, ' or ');\n    return {\n      type: 'logical',\n      operator: 'or',\n      left: parseFilterExpression(parts[0].trim()),\n      right: parseFilterExpression(parts[1].trim())\n    };\n  }\n  \n  // Handle comparison operators\n  const comparisonOps = [' eq ', ' ne ', ' gt ', ' ge ', ' lt ', ' le '];\n  for (const op of comparisonOps) {\n    if (filter.includes(op)) {\n      const parts = filter.split(op);\n      if (parts.length === 2) {\n        return {\n          type: 'comparison',\n          operator: op.trim(),\n          left: parseFilterExpression(parts[0].trim()),\n          right: parseFilterExpression(parts[1].trim())\n        };\n      }\n    }\n  }\n  \n  // Handle functions\n  if (filter.includes('(') && filter.includes(')')) {\n    const funcMatch = filter.match(/^(\\w+)\\((.+)\\)$/);\n    if (funcMatch) {\n      const [, funcName, argsStr] = funcMatch;\n      const args = argsStr.split(',').map(arg => parseFilterExpression(arg.trim()));\n      return {\n        type: 'function',\n        function: funcName,\n        args\n      };\n    }\n  }\n  \n  // Handle literals\n  if (filter.startsWith(\"'\") && filter.endsWith(\"'\")) {\n    return {\n      type: 'literal',\n      value: filter.slice(1, -1)\n    };\n  }\n  \n  if (filter === 'null') {\n    return {\n      type: 'literal',\n      value: null\n    };\n  }\n  \n  if (!isNaN(Number(filter))) {\n    return {\n      type: 'literal',\n      value: Number(filter)\n    };\n  }\n  \n  // Handle properties\n  return {\n    type: 'property',\n    property: filter\n  };\n}\n\nfunction splitByOperator(str: string, operator: string): string[] {\n  let depth = 0;\n  let inQuotes = false;\n  \n  for (let i = 0; i < str.length - operator.length + 1; i++) {\n    const char = str[i];\n    if (char === \"'\") inQuotes = !inQuotes;\n    if (inQuotes) continue;\n    \n    if (char === '(') depth++;\n    if (char === ')') depth--;\n    \n    if (depth === 0 && str.slice(i, i + operator.length) === operator) {\n      return [str.slice(0, i), str.slice(i + operator.length)];\n    }\n  }\n  \n  return [str];\n}\n\nfunction evaluateExpression(expr: FilterExpression, entity: any): any {\n  switch (expr.type) {\n    case 'property':\n      return getPropertyValue(entity, expr.property!);\n    \n    case 'literal':\n      return expr.value;\n    \n    case 'comparison': {\n      const left = evaluateExpression(expr.left!, entity);\n      const right = evaluateExpression(expr.right!, entity);\n      return evaluateComparison(left, expr.operator!, right);\n    }\n    \n    case 'logical': {\n      const leftResult = evaluateExpression(expr.left!, entity);\n      const rightResult = evaluateExpression(expr.right!, entity);\n      return evaluateLogical(leftResult, expr.operator!, rightResult);\n    }\n    \n    case 'function':\n      return evaluateFunction(expr.function!, expr.args!, entity);\n    \n    default:\n      return false;\n  }\n}\n\nfunction getPropertyValue(entity: any, property: string): any {\n  // Handle nested properties (e.g., \"address/city\")\n  const parts = property.split('/');\n  let value = entity;\n  for (const part of parts) {\n    if (value && typeof value === 'object') {\n      value = value[part];\n    } else {\n      return undefined;\n    }\n  }\n  return value;\n}\n\nfunction evaluateComparison(left: any, operator: string, right: any): boolean {\n  switch (operator) {\n    case 'eq': return left === right;\n    case 'ne': return left !== right;\n    case 'gt': return left > right;\n    case 'ge': return left >= right;\n    case 'lt': return left < right;\n    case 'le': return left <= right;\n    default: return false;\n  }\n}\n\nfunction evaluateLogical(left: boolean, operator: string, right: boolean): boolean {\n  switch (operator) {\n    case 'and': return left && right;\n    case 'or': return left || right;\n    default: return false;\n  }\n}\n\nfunction evaluateFunction(funcName: string, args: FilterExpression[], entity: any): any {\n  const argValues = args.map(arg => evaluateExpression(arg, entity));\n  \n  switch (funcName) {\n    case 'contains':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const substring = String(argValues[1] || '');\n        return str.includes(substring);\n      }\n      return false;\n    \n    case 'startswith':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const prefix = String(argValues[1] || '');\n        return str.startsWith(prefix);\n      }\n      return false;\n    \n    case 'endswith':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const suffix = String(argValues[1] || '');\n        return str.endsWith(suffix);\n      }\n      return false;\n    \n    case 'length':\n      if (argValues.length >= 1) {\n        const str = String(argValues[0] || '');\n        return str.length;\n      }\n      return 0;\n    \n    case 'tolower':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').toLowerCase();\n      }\n      return '';\n    \n    case 'toupper':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').toUpperCase();\n      }\n      return '';\n    \n    case 'trim':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').trim();\n      }\n      return '';\n    \n    case 'substring':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const start = Number(argValues[1]) || 0;\n        if (argValues.length >= 3) {\n          const length = Number(argValues[2]) || 0;\n          return str.substring(start, start + length);\n        }\n        return str.substring(start);\n      }\n      return '';\n    \n    case 'indexof':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const substring = String(argValues[1] || '');\n        return str.indexOf(substring);\n      }\n      return -1;\n    \n    case 'concat':\n      return argValues.map(v => String(v || '')).join('');\n    \n    case 'year':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getFullYear();\n      }\n      return 0;\n    \n    case 'month':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getMonth() + 1;\n      }\n      return 0;\n    \n    case 'day':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getDate();\n      }\n      return 0;\n    \n    case 'hour':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getHours();\n      }\n      return 0;\n    \n    case 'minute':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getMinutes();\n      }\n      return 0;\n    \n    case 'second':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getSeconds();\n      }\n      return 0;\n    \n    case 'round':\n      if (argValues.length >= 1) {\n        return Math.round(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'floor':\n      if (argValues.length >= 1) {\n        return Math.floor(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'ceiling':\n      if (argValues.length >= 1) {\n        return Math.ceil(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'now':\n      return new Date().toISOString();\n    \n    case 'maxdatetime':\n      return new Date('9999-12-31T23:59:59.999Z').toISOString();\n    \n    case 'mindatetime':\n      return new Date('0001-01-01T00:00:00.000Z').toISOString();\n    \n    default:\n      return false;\n  }\n}\n\nexport function filterArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.filter) return rows;\n  \n  try {\n    const expression = parseFilterExpression(options.filter);\n    return rows.filter(row => evaluateExpression(expression, row));\n  } catch (error) {\n    // If filter parsing fails, return all rows\n    // eslint-disable-next-line no-console, no-undef\n    console.warn('Filter parsing failed:', error);\n    return rows;\n  }\n}\n\nexport function orderArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.orderby || options.orderby.length === 0) return rows;\n  const copy = [...rows];\n  copy.sort((a, b) => {\n    for (const term of options.orderby!) {\n      const av = (a as any)[term.property];\n      const bv = (b as any)[term.property];\n      if (av == null && bv == null) continue;\n      if (av == null) return term.direction === \"asc\" ? -1 : 1;\n      if (bv == null) return term.direction === \"asc\" ? 1 : -1;\n      if (av < bv) return term.direction === \"asc\" ? -1 : 1;\n      if (av > bv) return term.direction === \"asc\" ? 1 : -1;\n    }\n    return 0;\n  });\n  return copy;\n}\n\nexport function paginateArray<T>(rows: T[], options: ODataQueryOptions): T[] {\n  const skip = options.skip ?? 0;\n  const top = options.top ?? rows.length;\n  return rows.slice(skip, skip + top);\n}\n","import type { ODataCollectionResponse } from \"./types\";\n\nexport function serializeCollection<T>(contextUrl: string, value: T[], count?: number, nextLink?: string): ODataCollectionResponse<T> {\n  const out: ODataCollectionResponse<T> = {\n    \"@odata.context\": contextUrl,\n    value,\n  };\n  if (typeof count === \"number\") out[\"@odata.count\"] = count;\n  if (nextLink) out[\"@odata.nextLink\"] = nextLink;\n  return out;\n}\n"],"names":["parseODataQuery","query","opts","sel","s","orderby","term","prop","dir","top","skip","count","filter","expand","e","odata","options","request","event","serviceRoot","ctx","ODataBadRequest","__publicField","ODataInternalServerError","toODataError","err","message","validateSelectParameters","select","entityType","edmModel","entityTypeDef","et","validProperties","p","property","validateFilterExpression","parenCount","char","propertyMatches","match","validateOrderByProperties","orderByItem","validateExpandNavigationProperties","validNavigationProperties","np","navigationProperty","validateEdmModelConstraints","entity","requiredProperties","value","getHttpStatusCode","error","isValidationError","isServerError","applySelect","row","out","projectArray","rows","expandData","data","item","expanded","expandItem","nestedData","parseFilterExpression","parts","splitByOperator","comparisonOps","op","funcMatch","funcName","argsStr","args","arg","str","operator","depth","inQuotes","i","evaluateExpression","expr","getPropertyValue","left","right","evaluateComparison","leftResult","rightResult","evaluateLogical","evaluateFunction","part","argValues","substring","prefix","suffix","start","length","v","date","filterArray","expression","orderArray","copy","a","b","av","bv","paginateArray","serializeCollection","contextUrl","nextLink"],"mappings":"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"}