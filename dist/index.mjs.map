{"version":3,"file":"index.mjs","sources":["../src/middleware/compose.ts","../src/core/parse.ts","../src/middleware/parse.ts","../src/core/shape.ts","../src/middleware/shape.ts","../src/core/filter-order.ts","../src/middleware/filter.ts","../src/middleware/pagination.ts","../src/core/serialize.ts","../src/middleware/serialize.ts","../src/core/errors.ts","../src/middleware/error.ts","../src/core/functions-actions.ts","../src/middleware/functions.ts","../src/core/metadata.ts","../src/middleware/metadata.ts","../src/core/search-compute-apply.ts","../__tests__/fixtures/edm.ts","../src/core/conformance-levels.ts","../src/middleware/conformance.ts","../src/middleware/odata.ts","../src/middleware/convenience.ts","../src/core/error-handling.ts","../src/core/format-serialization.ts"],"sourcesContent":["import type { MiddlewareObj } from \"@middy/core\";\n// Removed unused imports\n\ndeclare const console: any;\n\n\n/**\n * Composes multiple middlewares into a single middleware following Middy's onion pattern\n * @param middlewares Array of middlewares to compose\n * @returns Single middleware that executes all middlewares in proper order\n */\nexport function composeMiddlewares(...middlewares: MiddlewareObj[]): MiddlewareObj {\n  return {\n    before: async (handler) => {\n      // Execute before phases in order\n      for (const middleware of middlewares) {\n        if (middleware.before) {\n          await middleware.before(handler);\n        }\n      }\n    },\n    after: async (handler) => {\n      // Execute after phases in reverse order\n      for (const middleware of middlewares.slice().reverse()) {\n        if (middleware.after) {\n          await middleware.after(handler);\n        }\n      }\n    },\n    onError: async (handler) => {\n      // Execute error handlers in reverse order\n      for (const middleware of middlewares.slice().reverse()) {\n        if (middleware.onError) {\n          await middleware.onError(handler);\n        }\n      }\n    },\n  };\n}\n\n/**\n * Validates middleware execution order and dependencies\n * @param middlewares Array of middlewares to validate\n * @throws Error if middleware order is invalid\n */\nexport function validateMiddlewareOrder(middlewares: MiddlewareObj[]): void {\n  // This could be expanded to check for specific middleware dependencies\n  // For now, we'll just ensure we have at least one middleware\n  if (middlewares.length === 0) {\n    throw new Error(\"At least one middleware is required\");\n  }\n}\n\n/**\n * Creates a middleware that logs execution for debugging\n * @param name Name of the middleware for logging\n * @returns Middleware with logging\n */\nexport function createLoggingMiddleware(name: string): MiddlewareObj {\n  return {\n    before: async (handler) => {\n      const startTime = Date.now();\n      handler.internal = handler.internal || {};\n      (handler.internal as any)[`${name}_start`] = startTime;\n      console.log(`[OData] ${name} middleware: before phase started`);\n    },\n    after: async (handler) => {\n      const startTime = (handler.internal as any)?.[`${name}_start`] || Date.now();\n      const duration = Date.now() - startTime;\n      console.log(`[OData] ${name} middleware: after phase completed in ${duration}ms`);\n    },\n    onError: async (handler) => {\n      const startTime = (handler.internal as any)?.[`${name}_start`] || Date.now();\n      const duration = Date.now() - startTime;\n      console.error(`[OData] ${name} middleware: error phase in ${duration}ms`, handler.error);\n    },\n  };\n}\n\n/**\n * Helper to merge middleware options with defaults\n * @param defaults Default options\n * @param overrides Override options\n * @returns Merged options\n */\nexport function mergeMiddlewareOptions<T extends Record<string, unknown>>(\n  defaults: T,\n  overrides: Partial<T> = {}\n): T {\n  return { ...defaults, ...overrides };\n}\n\n/**\n * Helper to create middleware context from request\n * @param request Middy request object\n * @returns OData middleware context\n */\nexport function getMiddlewareContext(request: any): any {\n  return request.internal?.odata || {};\n}\n\n/**\n * Helper to set middleware context on request\n * @param request Middy request object\n * @param context OData middleware context\n */\nexport function setMiddlewareContext(request: any, context: any): void {\n  request.internal = request.internal || {};\n  request.internal.odata = context;\n}\n","import type { ODataQueryOptions } from \"./types\";\n\nexport function parseODataQuery(query: Record<string, string | undefined>): ODataQueryOptions {\n  const opts: ODataQueryOptions = {};\n  const sel = query[\"$select\"];\n  if (sel) opts.select = sel.split(\",\").map((s) => s.trim()).filter(Boolean);\n  const orderby = query[\"$orderby\"];\n  if (orderby) {\n    opts.orderby = orderby.split(\",\").map((term) => {\n      const [prop, dir] = term.trim().split(/\\s+/);\n      return { property: prop, direction: (dir?.toLowerCase() === \"desc\" ? \"desc\" : \"asc\") };\n    });\n  }\n  const top = query[\"$top\"];\n  if (top !== undefined) opts.top = Math.max(0, Number(top));\n  const skip = query[\"$skip\"];\n  if (skip !== undefined) opts.skip = Math.max(0, Number(skip));\n  const count = query[\"$count\"];\n  if (count !== undefined) opts.count = String(count).toLowerCase() === \"true\";\n  const filter = query[\"$filter\"];\n  if (filter) opts.filter = filter;\n  const expand = query[\"$expand\"];\n  if (expand) {\n    opts.expand = expand.split(\",\").map((e) => ({ path: e.trim() }));\n  }\n  return opts;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataParseOptions, ODataMiddlewareContext } from \"./types\";\nimport type { EdmModel } from \"../core/types\";\nimport { parseODataQuery } from \"../core/parse\";\nimport { mergeMiddlewareOptions, setMiddlewareContext } from \"./compose\";\n\nconst DEFAULT_PARSE_OPTIONS: ODataParseOptions = {\n  model: {} as any, // Will be provided by user\n  serviceRoot: \"\",\n  validateAgainstModel: true,\n  strictMode: false,\n};\n\n/**\n * OData Parse Middleware\n * \n * Responsibilities:\n * - Parse query parameters from API Gateway events\n * - Validate query options against EDM model\n * - Set up initial OData context\n * - Handle service root resolution\n */\nexport function odataParse(options: Partial<ODataParseOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_PARSE_OPTIONS, options);\n\n  return {\n    before: async (request: any) => {\n      try {\n        const event = request.event ?? {};\n        \n        // Extract query parameters from different API Gateway event formats\n        const query: Record<string, string> = event.rawQueryString\n          ? Object.fromEntries(new URLSearchParams(event.rawQueryString))\n          : (event.queryStringParameters || {});\n\n        // Parse OData query options\n        const parsedOptions = parseODataQuery(query);\n\n        // Resolve service root\n        const serviceRoot = typeof opts.serviceRoot === \"function\" \n          ? opts.serviceRoot(event) \n          : opts.serviceRoot;\n\n        // Create OData context\n        const context: ODataMiddlewareContext = {\n          model: opts.model as EdmModel,\n          serviceRoot,\n          entitySet: undefined, // Will be set by route handler or other middleware\n          options: parsedOptions,\n          metadata: {\n            middlewareStack: [\"parse\"],\n            executionTime: Date.now(),\n          },\n        };\n\n        // Validate against EDM model if enabled\n        if (opts.validateAgainstModel) {\n          validateQueryOptions(context);\n        }\n\n        // Set context on request\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If parsing fails, we should still set up basic context\n        // The error middleware will handle the actual error\n        const context: ODataMiddlewareContext = {\n          model: opts.model as EdmModel,\n          serviceRoot: typeof opts.serviceRoot === \"function\" \n            ? opts.serviceRoot(request.event) \n            : opts.serviceRoot,\n          entitySet: undefined,\n          options: {},\n          error: error as Error,\n          metadata: {\n            middlewareStack: [\"parse\"],\n            executionTime: Date.now(),\n          },\n        };\n        setMiddlewareContext(request, context);\n        throw error; // Re-throw to let error middleware handle it\n      }\n    },\n  };\n}\n\n/**\n * Validates parsed query options against the EDM model\n * @param context OData middleware context\n * @throws Error if validation fails\n */\nfunction validateQueryOptions(context: ODataMiddlewareContext): void {\n  const { model, options } = context;\n\n  // Validate $select properties exist in model\n  if (options.select) {\n    for (const property of options.select) {\n      if (!isValidPropertyPath(property, model)) {\n        throw new Error(`Invalid property in $select: ${property}`);\n      }\n    }\n  }\n\n  // Validate $expand navigation properties exist in model\n  if (options.expand) {\n    for (const expandItem of options.expand) {\n      if (!isValidNavigationProperty(expandItem.path, model)) {\n        throw new Error(`Invalid navigation property in $expand: ${expandItem.path}`);\n      }\n    }\n  }\n\n  // Validate $orderby properties exist in model\n  if (options.orderby) {\n    for (const orderItem of options.orderby) {\n      if (!isValidPropertyPath(orderItem.property, model)) {\n        throw new Error(`Invalid property in $orderby: ${orderItem.property}`);\n      }\n    }\n  }\n}\n\n/**\n * Checks if a property path is valid in the EDM model\n * @param propertyPath Property path to validate\n * @param model EDM model\n * @returns True if valid\n */\nfunction isValidPropertyPath(propertyPath: string, model: any): boolean {\n  // Simple validation - in a real implementation, this would be more comprehensive\n  // For now, we'll just check if the model has entity types\n  if (!model.entityTypes || model.entityTypes.length === 0) {\n    return true; // Can't validate without entity types\n  }\n\n  // Check if property exists in any entity type\n  return model.entityTypes.some((entityType: any) => \n    entityType.properties?.some((prop: any) => prop.name === propertyPath)\n  );\n}\n\n/**\n * Checks if a navigation property is valid in the EDM model\n * @param navigationPath Navigation property path to validate\n * @param model EDM model\n * @returns True if valid\n */\nfunction isValidNavigationProperty(navigationPath: string, model: any): boolean {\n  // Simple validation - in a real implementation, this would be more comprehensive\n  if (!model.entityTypes || model.entityTypes.length === 0) {\n    return true; // Can't validate without entity types\n  }\n\n  // Check if navigation property exists in any entity type\n  return model.entityTypes.some((entityType: any) => \n    entityType.navigation?.some((nav: any) => nav.name === navigationPath)\n  );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataEntity, ODataQueryOptions } from \"./types\";\n\nexport function applySelect<T extends ODataEntity>(row: T, select?: string[]): Partial<T> {\n  if (!select || select.length === 0) return { ...row };\n  const out: Record<string, unknown> = {};\n  for (const p of select) if (p in row) out[p] = (row as any)[p];\n  return out as Partial<T>;\n}\n\nexport function projectArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): Partial<T>[] {\n  return rows.map((r) => applySelect(r, options.select));\n}\n\n// Expand navigation properties\nexport function expandData<T extends Record<string, any>>(\n  data: T | T[],\n  options: ODataQueryOptions\n): T | T[] {\n  if (!options.expand || options.expand.length === 0) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map(item => expandData(item, options) as T);\n  }\n\n  const expanded = { ...data } as any;\n  \n  for (const expandItem of options.expand) {\n    const navigationProperty = expandItem.path;\n    \n    // Simple expansion - in a real implementation, this would resolve navigation properties\n    // For now, we'll just ensure the property exists\n    if (navigationProperty && !(navigationProperty in expanded)) {\n      // Create a placeholder for the expanded property\n      expanded[navigationProperty] = null;\n    }\n    \n    // Handle nested query options in expansion\n    if (expandItem.options) {\n      const nestedData = expanded[navigationProperty];\n      if (nestedData) {\n        expanded[navigationProperty] = expandData(nestedData, expandItem.options);\n      }\n    }\n  }\n  \n  return expanded as T;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataShapeOptions, ODataMiddlewareContext } from \"./types\";\nimport { applySelect } from \"../core/shape\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\n\nconst DEFAULT_SHAPE_OPTIONS: ODataShapeOptions = {\n  enableExpand: true,\n  maxExpandDepth: 3,\n  expandResolvers: {},\n};\n\n/**\n * OData Shape Middleware\n * \n * Responsibilities:\n * - Apply $select projection to response data\n * - Handle $expand navigation property resolution\n * - Transform response data according to OData query options\n * - Manage expand depth and prevent infinite loops\n */\nexport function odataShape(options: Partial<ODataShapeOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_SHAPE_OPTIONS, options);\n\n  return {\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        if (!context || !context.options) {\n          return; // No OData context, skip shaping\n        }\n\n        // Get response data\n        let responseData = request.response?.body;\n        if (typeof responseData === 'string') {\n          try {\n            responseData = JSON.parse(responseData);\n          } catch {\n            // If parsing fails, skip shaping\n            return;\n          }\n        }\n\n        if (!responseData) {\n          return; // No data to shape\n        }\n\n        // Apply data shaping\n        const shapedData = await applyDataShaping(responseData, context, opts);\n\n        // Update response\n        if (request.response) {\n          request.response.body = JSON.stringify(shapedData);\n        } else {\n          request.response = {\n            statusCode: 200,\n            body: JSON.stringify(shapedData),\n          };\n        }\n\n        // Update context with shaped data\n        context.data = shapedData;\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If shaping fails, log error but don't break the response\n        console.error('[OData Shape] Error applying data shaping:', error);\n        // Continue with original response\n      }\n    },\n  };\n}\n\n/**\n * Applies data shaping based on OData query options\n * @param data Response data to shape\n * @param context OData middleware context\n * @param options Shape options\n * @returns Shaped data\n */\nasync function applyDataShaping(\n  data: unknown,\n  context: ODataMiddlewareContext,\n  options: ODataShapeOptions\n): Promise<unknown> {\n  const { options: queryOptions } = context;\n\n  // Handle collection responses\n  if (Array.isArray(data)) {\n    return await shapeCollection(data, queryOptions, options, context);\n  }\n\n  // Handle single entity responses\n  if (data && typeof data === 'object') {\n    return await shapeEntity(data as Record<string, unknown>, queryOptions, options, context);\n  }\n\n  // Return primitive values as-is\n  return data;\n}\n\n/**\n * Shapes a collection of entities\n * @param entities Array of entities\n * @param queryOptions OData query options\n * @param options Shape options\n * @param context OData middleware context\n * @returns Shaped collection\n */\nasync function shapeCollection(\n  entities: unknown[],\n  queryOptions: any,\n  options: ODataShapeOptions,\n  context: ODataMiddlewareContext\n): Promise<unknown[]> {\n  const shapedEntities: unknown[] = [];\n\n  for (const entity of entities) {\n    if (entity && typeof entity === 'object') {\n      const shapedEntity = await shapeEntity(\n        entity as Record<string, unknown>,\n        queryOptions,\n        options,\n        context\n      );\n      shapedEntities.push(shapedEntity);\n    } else {\n      shapedEntities.push(entity);\n    }\n  }\n\n  return shapedEntities;\n}\n\n/**\n * Shapes a single entity\n * @param entity Entity to shape\n * @param queryOptions OData query options\n * @param options Shape options\n * @param context OData middleware context\n * @returns Shaped entity\n */\nasync function shapeEntity(\n  entity: Record<string, unknown>,\n  queryOptions: any,\n  options: ODataShapeOptions,\n  context: ODataMiddlewareContext\n): Promise<Record<string, unknown>> {\n  let shapedEntity = { ...entity };\n\n  // Apply $select projection\n  if (queryOptions.select && queryOptions.select.length > 0) {\n    shapedEntity = applySelect(shapedEntity, queryOptions.select) as Record<string, unknown>;\n  }\n\n  // Apply $expand navigation properties\n  if (queryOptions.expand && queryOptions.expand.length > 0 && options.enableExpand) {\n    shapedEntity = await applyExpansion(\n      shapedEntity,\n      queryOptions.expand,\n      options,\n      context,\n      0 // Start with depth 0\n    ) as Record<string, unknown>;\n  }\n\n  return shapedEntity;\n}\n\n/**\n * Applies navigation property expansion\n * @param entity Entity to expand\n * @param expandItems Expand items from query options\n * @param options Shape options\n * @param context OData middleware context\n * @param depth Current expansion depth\n * @returns Entity with expanded navigation properties\n */\nasync function applyExpansion(\n  entity: Record<string, unknown>,\n  expandItems: any[],\n  options: ODataShapeOptions,\n  context: ODataMiddlewareContext,\n  depth: number\n): Promise<Record<string, unknown>> {\n  // Check expansion depth limit\n  if (depth >= (options.maxExpandDepth || 3)) {\n    console.warn(`[OData Shape] Maximum expansion depth (${options.maxExpandDepth}) reached`);\n    return entity;\n  }\n\n  const expandedEntity = { ...entity };\n\n  for (const expandItem of expandItems) {\n    const navigationProperty = expandItem.path;\n    \n    if (!navigationProperty) {\n      continue;\n    }\n\n    // Check if we have a custom resolver for this navigation property\n    const resolver = options.expandResolvers?.[navigationProperty];\n    \n    if (resolver) {\n      try {\n        // Use custom resolver to get navigation data\n        const navigationData = await resolver(context);\n        expandedEntity[navigationProperty] = navigationData;\n        \n        // Apply nested query options if present\n        if (expandItem.options) {\n          const nestedContext = {\n            ...context,\n            options: expandItem.options,\n          };\n          \n          if (Array.isArray(navigationData)) {\n            expandedEntity[navigationProperty] = await shapeCollection(\n              navigationData,\n              expandItem.options,\n              options,\n              nestedContext\n            );\n          } else if (navigationData && typeof navigationData === 'object') {\n            expandedEntity[navigationProperty] = await shapeEntity(\n              navigationData as Record<string, unknown>,\n              expandItem.options,\n              options,\n              nestedContext\n            );\n          }\n        }\n      } catch (error) {\n        console.error(`[OData Shape] Error resolving navigation property ${navigationProperty}:`, error);\n        expandedEntity[navigationProperty] = null;\n      }\n    } else {\n      // No custom resolver - check if property exists in entity\n      if (navigationProperty in expandedEntity) {\n        const navigationData = expandedEntity[navigationProperty];\n        \n        // Apply nested query options if present\n        if (expandItem.options && navigationData) {\n          if (Array.isArray(navigationData)) {\n            expandedEntity[navigationProperty] = await shapeCollection(\n              navigationData,\n              expandItem.options,\n              options,\n              {\n                ...context,\n                options: expandItem.options,\n              }\n            );\n          } else if (typeof navigationData === 'object') {\n            expandedEntity[navigationProperty] = await shapeEntity(\n              navigationData as Record<string, unknown>,\n              expandItem.options,\n              options,\n              {\n                ...context,\n                options: expandItem.options,\n              }\n            );\n          }\n        }\n      } else {\n        // Property doesn't exist - set to null\n        expandedEntity[navigationProperty] = null;\n      }\n    }\n  }\n\n  return expandedEntity;\n}\n\n\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataEntity, ODataQueryOptions } from \"./types\";\n\n// Simple filter expression parser and evaluator\ninterface FilterExpression {\n  type: 'comparison' | 'logical' | 'function' | 'property' | 'literal';\n  operator?: string;\n  left?: FilterExpression;\n  right?: FilterExpression;\n  property?: string;\n  value?: any;\n  function?: string;\n  args?: FilterExpression[];\n}\n\nfunction parseFilterExpression(filter: string): FilterExpression {\n  // Simple parser for basic filter expressions\n  // This is a simplified implementation - a full OData parser would be much more complex\n  \n  // Handle parentheses and logical operators\n  if (filter.includes(' and ')) {\n    const parts = splitByOperator(filter, ' and ');\n    return {\n      type: 'logical',\n      operator: 'and',\n      left: parseFilterExpression(parts[0].trim()),\n      right: parseFilterExpression(parts[1].trim())\n    };\n  }\n  \n  if (filter.includes(' or ')) {\n    const parts = splitByOperator(filter, ' or ');\n    return {\n      type: 'logical',\n      operator: 'or',\n      left: parseFilterExpression(parts[0].trim()),\n      right: parseFilterExpression(parts[1].trim())\n    };\n  }\n  \n  // Handle comparison operators\n  const comparisonOps = [' eq ', ' ne ', ' gt ', ' ge ', ' lt ', ' le '];\n  for (const op of comparisonOps) {\n    if (filter.includes(op)) {\n      const parts = filter.split(op);\n      if (parts.length === 2) {\n        return {\n          type: 'comparison',\n          operator: op.trim(),\n          left: parseFilterExpression(parts[0].trim()),\n          right: parseFilterExpression(parts[1].trim())\n        };\n      }\n    }\n  }\n  \n  // Handle functions\n  if (filter.includes('(') && filter.includes(')')) {\n    const funcMatch = filter.match(/^(\\w+)\\((.+)\\)$/);\n    if (funcMatch) {\n      const [, funcName, argsStr] = funcMatch;\n      const args = argsStr.split(',').map(arg => parseFilterExpression(arg.trim()));\n      return {\n        type: 'function',\n        function: funcName,\n        args\n      };\n    }\n  }\n  \n  // Handle literals\n  if (filter.startsWith(\"'\") && filter.endsWith(\"'\")) {\n    return {\n      type: 'literal',\n      value: filter.slice(1, -1)\n    };\n  }\n  \n  if (filter === 'null') {\n    return {\n      type: 'literal',\n      value: null\n    };\n  }\n  \n  if (!isNaN(Number(filter))) {\n    return {\n      type: 'literal',\n      value: Number(filter)\n    };\n  }\n  \n  // Handle properties\n  return {\n    type: 'property',\n    property: filter\n  };\n}\n\nfunction splitByOperator(str: string, operator: string): string[] {\n  let depth = 0;\n  let inQuotes = false;\n  \n  for (let i = 0; i < str.length - operator.length + 1; i++) {\n    const char = str[i];\n    if (char === \"'\") inQuotes = !inQuotes;\n    if (inQuotes) continue;\n    \n    if (char === '(') depth++;\n    if (char === ')') depth--;\n    \n    if (depth === 0 && str.slice(i, i + operator.length) === operator) {\n      return [str.slice(0, i), str.slice(i + operator.length)];\n    }\n  }\n  \n  return [str];\n}\n\nfunction evaluateExpression(expr: FilterExpression, entity: any): any {\n  switch (expr.type) {\n    case 'property':\n      return getPropertyValue(entity, expr.property!);\n    \n    case 'literal':\n      return expr.value;\n    \n    case 'comparison': {\n      const left = evaluateExpression(expr.left!, entity);\n      const right = evaluateExpression(expr.right!, entity);\n      return evaluateComparison(left, expr.operator!, right);\n    }\n    \n    case 'logical': {\n      const leftResult = evaluateExpression(expr.left!, entity);\n      const rightResult = evaluateExpression(expr.right!, entity);\n      return evaluateLogical(leftResult, expr.operator!, rightResult);\n    }\n    \n    case 'function':\n      return evaluateFunction(expr.function!, expr.args!, entity);\n    \n    default:\n      return false;\n  }\n}\n\nfunction getPropertyValue(entity: any, property: string): any {\n  // Handle nested properties (e.g., \"address/city\")\n  const parts = property.split('/');\n  let value = entity;\n  for (const part of parts) {\n    if (value && typeof value === 'object') {\n      value = value[part];\n    } else {\n      return undefined;\n    }\n  }\n  return value;\n}\n\nfunction evaluateComparison(left: any, operator: string, right: any): boolean {\n  switch (operator) {\n    case 'eq': return left === right;\n    case 'ne': return left !== right;\n    case 'gt': return left > right;\n    case 'ge': return left >= right;\n    case 'lt': return left < right;\n    case 'le': return left <= right;\n    default: return false;\n  }\n}\n\nfunction evaluateLogical(left: boolean, operator: string, right: boolean): boolean {\n  switch (operator) {\n    case 'and': return left && right;\n    case 'or': return left || right;\n    default: return false;\n  }\n}\n\nfunction evaluateFunction(funcName: string, args: FilterExpression[], entity: any): any {\n  const argValues = args.map(arg => evaluateExpression(arg, entity));\n  \n  switch (funcName) {\n    case 'contains':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const substring = String(argValues[1] || '');\n        return str.includes(substring);\n      }\n      return false;\n    \n    case 'startswith':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const prefix = String(argValues[1] || '');\n        return str.startsWith(prefix);\n      }\n      return false;\n    \n    case 'endswith':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const suffix = String(argValues[1] || '');\n        return str.endsWith(suffix);\n      }\n      return false;\n    \n    case 'length':\n      if (argValues.length >= 1) {\n        const str = String(argValues[0] || '');\n        return str.length;\n      }\n      return 0;\n    \n    case 'tolower':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').toLowerCase();\n      }\n      return '';\n    \n    case 'toupper':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').toUpperCase();\n      }\n      return '';\n    \n    case 'trim':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').trim();\n      }\n      return '';\n    \n    case 'substring':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const start = Number(argValues[1]) || 0;\n        if (argValues.length >= 3) {\n          const length = Number(argValues[2]) || 0;\n          return str.substring(start, start + length);\n        }\n        return str.substring(start);\n      }\n      return '';\n    \n    case 'indexof':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const substring = String(argValues[1] || '');\n        return str.indexOf(substring);\n      }\n      return -1;\n    \n    case 'concat':\n      return argValues.map(v => String(v || '')).join('');\n    \n    case 'year':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getFullYear();\n      }\n      return 0;\n    \n    case 'month':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getMonth() + 1;\n      }\n      return 0;\n    \n    case 'day':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getDate();\n      }\n      return 0;\n    \n    case 'hour':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getHours();\n      }\n      return 0;\n    \n    case 'minute':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getMinutes();\n      }\n      return 0;\n    \n    case 'second':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getSeconds();\n      }\n      return 0;\n    \n    case 'round':\n      if (argValues.length >= 1) {\n        return Math.round(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'floor':\n      if (argValues.length >= 1) {\n        return Math.floor(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'ceiling':\n      if (argValues.length >= 1) {\n        return Math.ceil(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'now':\n      return new Date().toISOString();\n    \n    case 'maxdatetime':\n      return new Date('9999-12-31T23:59:59.999Z').toISOString();\n    \n    case 'mindatetime':\n      return new Date('0001-01-01T00:00:00.000Z').toISOString();\n    \n    default:\n      return false;\n  }\n}\n\nexport function filterArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.filter) return rows;\n  \n  try {\n    const expression = parseFilterExpression(options.filter);\n    return rows.filter(row => evaluateExpression(expression, row));\n  } catch (error) {\n    // If filter parsing fails, return all rows\n    // eslint-disable-next-line no-undef\n    console.warn('Filter parsing failed:', error);\n    return rows;\n  }\n}\n\nexport function orderArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.orderby || options.orderby.length === 0) return rows;\n  const copy = [...rows];\n  copy.sort((a, b) => {\n    for (const term of options.orderby!) {\n      const av = (a as any)[term.property];\n      const bv = (b as any)[term.property];\n      if (av == null && bv == null) continue;\n      if (av == null) return term.direction === \"asc\" ? -1 : 1;\n      if (bv == null) return term.direction === \"asc\" ? 1 : -1;\n      if (av < bv) return term.direction === \"asc\" ? -1 : 1;\n      if (av > bv) return term.direction === \"asc\" ? 1 : -1;\n    }\n    return 0;\n  });\n  return copy;\n}\n\nexport function paginateArray<T>(rows: T[], options: ODataQueryOptions): T[] {\n  const skip = options.skip ?? 0;\n  const top = options.top ?? rows.length;\n  return rows.slice(skip, skip + top);\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataFilterOptions, ODataMiddlewareContext } from \"./types\";\nimport { filterArray, orderArray } from \"../core/filter-order\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\nconst DEFAULT_FILTER_OPTIONS: ODataFilterOptions = {\n  enableFilter: true,\n  enableOrderby: true,\n  maxFilterDepth: 10,\n  caseSensitive: true,\n};\n\n/**\n * OData Filter Middleware\n * \n * Responsibilities:\n * - Apply $filter expressions to response data\n * - Apply $orderby sorting to response data\n * - Handle filter expression parsing and evaluation\n * - Manage filter depth and prevent infinite recursion\n */\nexport function odataFilter(options: Partial<ODataFilterOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_FILTER_OPTIONS, options);\n\n  return {\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        if (!context || !context.options) {\n          return; // No OData context, skip filtering\n        }\n\n        // Get response data\n        let responseData = request.response?.body;\n        if (typeof responseData === 'string') {\n          try {\n            responseData = JSON.parse(responseData);\n          } catch {\n            // If parsing fails, skip filtering\n            return;\n          }\n        }\n\n        if (!responseData) {\n          return; // No data to filter\n        }\n\n        // Apply filtering and ordering\n        const filteredData = await applyFilteringAndOrdering(responseData, context, opts);\n\n        // Update response\n        if (request.response) {\n          request.response.body = JSON.stringify(filteredData);\n        } else {\n          request.response = {\n            statusCode: 200,\n            body: JSON.stringify(filteredData),\n          };\n        }\n\n        // Update context with filtered data\n        context.data = filteredData;\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If filtering fails, log error but don't break the response\n        console.error('[OData Filter] Error applying filtering/ordering:', error);\n        // Continue with original response\n      }\n    },\n  };\n}\n\n/**\n * Applies filtering and ordering to response data\n * @param data Response data to filter/order\n * @param context OData middleware context\n * @param options Filter options\n * @returns Filtered and ordered data\n */\nasync function applyFilteringAndOrdering(\n  data: unknown,\n  context: ODataMiddlewareContext,\n  options: ODataFilterOptions\n): Promise<unknown> {\n  const { options: queryOptions } = context;\n\n  // Handle collection responses\n  if (Array.isArray(data)) {\n    return await filterAndOrderCollection(data, queryOptions, options);\n  }\n\n  // Handle single entity responses - filtering doesn't apply to single entities\n  // but ordering might if it's a collection property\n  if (data && typeof data === 'object') {\n    return await filterAndOrderEntity(data as Record<string, unknown>, queryOptions, options, context);\n  }\n\n  // Return primitive values as-is\n  return data;\n}\n\n/**\n * Filters and orders a collection of entities\n * @param entities Array of entities\n * @param queryOptions OData query options\n * @param options Filter options\n * @param context OData middleware context\n * @returns Filtered and ordered collection\n */\nasync function filterAndOrderCollection(\n  entities: unknown[],\n  queryOptions: any,\n  options: ODataFilterOptions\n): Promise<unknown[]> {\n  let filteredEntities = [...entities];\n\n  // Apply $filter if present and enabled\n  if (queryOptions.filter && options.enableFilter) {\n    try {\n      filteredEntities = filterArray(filteredEntities as any[], queryOptions.filter);\n    } catch (error) {\n      console.error('[OData Filter] Error applying filter:', error);\n      // Continue with unfiltered data\n    }\n  }\n\n  // Apply $orderby if present and enabled\n  if (queryOptions.orderby && queryOptions.orderby.length > 0 && options.enableOrderby) {\n    try {\n      filteredEntities = orderArray(filteredEntities as any[], queryOptions.orderby);\n    } catch (error) {\n      console.error('[OData Filter] Error applying orderby:', error);\n      // Continue with unordered data\n    }\n  }\n\n  return filteredEntities;\n}\n\n/**\n * Filters and orders a single entity (for collection properties)\n * @param entity Entity to process\n * @param queryOptions OData query options\n * @param options Filter options\n * @param context OData middleware context\n * @returns Processed entity\n */\nasync function filterAndOrderEntity(\n  entity: Record<string, unknown>,\n  queryOptions: any,\n  options: ODataFilterOptions,\n  context: ODataMiddlewareContext\n): Promise<Record<string, unknown>> {\n  const processedEntity = { ...entity };\n\n  // Process collection properties within the entity\n  for (const [key, value] of Object.entries(processedEntity)) {\n    if (Array.isArray(value)) {\n      // This is a collection property - apply filtering/ordering if applicable\n      const collectionOptions = getCollectionOptionsForProperty(key, queryOptions);\n      if (collectionOptions) {\n        processedEntity[key] = await filterAndOrderCollection(\n          value,\n          collectionOptions,\n          options,\n        );\n      }\n    }\n  }\n\n  return processedEntity;\n}\n\n/**\n * Gets query options for a specific collection property\n * @param propertyName Name of the collection property\n * @param queryOptions OData query options\n * @returns Query options for the collection property\n */\nfunction getCollectionOptionsForProperty(propertyName: string, queryOptions: any): any {\n  // This is a simplified implementation\n  // In a real scenario, this would look at $expand options to find nested query options\n  // for the specific navigation property\n  \n  if (queryOptions.expand) {\n    for (const expandItem of queryOptions.expand) {\n      if (expandItem.path === propertyName && expandItem.options) {\n        return expandItem.options;\n      }\n    }\n  }\n\n  return null;\n}\n\n\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataPaginationOptions, ODataMiddlewareContext } from \"./types\";\nimport { paginateArray } from \"../core/filter-order\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\nconst DEFAULT_PAGINATION_OPTIONS: ODataPaginationOptions = {\n  maxTop: 1000,\n  defaultTop: 50,\n  enableCount: true,\n};\n\n/**\n * OData Pagination Middleware\n * \n * Responsibilities:\n * - Apply $top and $skip pagination to response data\n * - Calculate and include $count when requested\n * - Generate @odata.nextLink for pagination\n * - Enforce maximum page size limits\n * - Handle pagination edge cases\n */\nexport function odataPagination(options: Partial<ODataPaginationOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_PAGINATION_OPTIONS, options);\n\n  return {\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        if (!context || !context.options) {\n          return; // No OData context, skip pagination\n        }\n\n        // Get response data\n        let responseData = request.response?.body;\n        if (typeof responseData === 'string') {\n          try {\n            responseData = JSON.parse(responseData);\n          } catch {\n            // If parsing fails, skip pagination\n            return;\n          }\n        }\n\n        if (!responseData) {\n          return; // No data to paginate\n        }\n\n        // Apply pagination\n        const paginatedData = await applyPagination(responseData, context, opts, request);\n\n        // Update response\n        if (request.response) {\n          request.response.body = JSON.stringify(paginatedData);\n        } else {\n          request.response = {\n            statusCode: 200,\n            body: JSON.stringify(paginatedData),\n          };\n        }\n\n        // Update context with paginated data\n        context.data = paginatedData;\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If pagination fails, log error but don't break the response\n        console.error('[OData Pagination] Error applying pagination:', error);\n        // Continue with original response\n      }\n    },\n  };\n}\n\n/**\n * Applies pagination to response data\n * @param data Response data to paginate\n * @param context OData middleware context\n * @param options Pagination options\n * @param request Middy request object\n * @returns Paginated data with count and nextLink\n */\nasync function applyPagination(\n  data: unknown,\n  context: ODataMiddlewareContext,\n  options: ODataPaginationOptions,\n  request: any\n): Promise<unknown> {\n  const { options: queryOptions } = context;\n\n  // Handle collection responses\n  if (Array.isArray(data)) {\n    return await paginateCollection(data, queryOptions, options, context, request);\n  }\n\n  // Handle single entity responses - pagination doesn't apply to single entities\n  // but we might need to add count information\n  if (data && typeof data === 'object') {\n    return await addCountToEntity(data as Record<string, unknown>, queryOptions, options, context);\n  }\n\n  // Return primitive values as-is\n  return data;\n}\n\n/**\n * Paginates a collection of entities\n * @param entities Array of entities\n * @param queryOptions OData query options\n * @param options Pagination options\n * @param context OData middleware context\n * @param request Middy request object\n * @returns Paginated collection with count and nextLink\n */\nasync function paginateCollection(\n  entities: unknown[],\n  queryOptions: any,\n  options: ODataPaginationOptions,\n  context: ODataMiddlewareContext,\n  request: any\n): Promise<unknown> {\n  const totalCount = entities.length;\n  let paginatedEntities = [...entities];\n\n  // Apply $top and $skip\n  const top = queryOptions.top;\n  const skip = queryOptions.skip || 0;\n\n  // Validate and enforce limits\n  const validatedTop = validateTopLimit(top, options);\n  const validatedSkip = Math.max(0, skip);\n\n  // Apply pagination\n  if (validatedTop !== undefined || validatedSkip > 0) {\n    paginatedEntities = paginateArray(entities, { top: validatedTop, skip: validatedSkip });\n  }\n\n  // Create paginated response\n  const result: any = {\n    \"@odata.context\": generateContextUrl(context),\n    value: paginatedEntities,\n  };\n\n  // Add count if requested\n  if (queryOptions.count && options.enableCount) {\n    result[\"@odata.count\"] = totalCount;\n  }\n\n  // Add nextLink if there are more results\n  const hasMoreResults = (validatedSkip + (validatedTop || totalCount)) < totalCount;\n  if (hasMoreResults && validatedTop !== undefined) {\n    result[\"@odata.nextLink\"] = generateNextLink(context, request, validatedTop, validatedSkip);\n  }\n\n  return result;\n}\n\n/**\n * Adds count information to a single entity response\n * @param entity Entity to process\n * @param queryOptions OData query options\n * @param options Pagination options\n * @param context OData middleware context\n * @returns Entity with count information\n */\nasync function addCountToEntity(\n  entity: Record<string, unknown>,\n  queryOptions: any,\n  options: ODataPaginationOptions,\n  context: ODataMiddlewareContext\n): Promise<Record<string, unknown>> {\n  const result = { ...entity };\n\n  // Add @odata.context if not present\n  if (!result[\"@odata.context\"]) {\n    result[\"@odata.context\"] = generateContextUrl(context);\n  }\n\n  // Add count if requested (for single entities, count is always 1)\n  if (queryOptions.count && options.enableCount) {\n    result[\"@odata.count\"] = 1;\n  }\n\n  return result;\n}\n\n/**\n * Validates and enforces top limit\n * @param top Requested top value\n * @param options Pagination options\n * @returns Validated top value\n */\nfunction validateTopLimit(top: number | undefined, options: ODataPaginationOptions): number | undefined {\n  if (top === undefined) {\n    return options.defaultTop;\n  }\n\n  if (top < 0) {\n    return 0;\n  }\n\n  if (top > (options.maxTop || 1000)) {\n    console.warn(`[OData Pagination] Top value ${top} exceeds maximum ${options.maxTop}, using maximum`);\n    return options.maxTop;\n  }\n\n  return top;\n}\n\n/**\n * Generates @odata.context URL\n * @param context OData middleware context\n * @returns Context URL\n */\nfunction generateContextUrl(context: ODataMiddlewareContext): string {\n  const { serviceRoot, entitySet } = context;\n  \n  if (entitySet) {\n    return `${serviceRoot}/$metadata#${entitySet}`;\n  }\n  \n  return `${serviceRoot}/$metadata`;\n}\n\n/**\n * Generates @odata.nextLink URL\n * @param context OData middleware context\n * @param request Middy request object\n * @param top Current top value\n * @param skip Current skip value\n * @returns NextLink URL\n */\nfunction generateNextLink(\n  context: ODataMiddlewareContext,\n  request: any,\n  top: number,\n  skip: number\n): string {\n  const { serviceRoot } = context;\n  const event = request.event || {};\n  \n  // Get current path\n  const path = event.path || event.rawPath || '/';\n  \n  // Get current query parameters\n  const currentQuery = event.rawQueryString \n    ? Object.fromEntries(new URLSearchParams(event.rawQueryString))\n    : (event.queryStringParameters || {});\n\n  // Update pagination parameters\n  const nextQuery = { ...currentQuery };\n  nextQuery.$skip = String(skip + top);\n  \n  // Build query string\n  const queryString = new URLSearchParams(nextQuery).toString();\n  \n  return `${serviceRoot}${path}?${queryString}`;\n}\n\n","import type { ODataCollectionResponse } from \"./types\";\n\nexport function serializeCollection<T>(contextUrl: string, value: T[], count?: number, nextLink?: string): ODataCollectionResponse<T> {\n  const out: ODataCollectionResponse<T> = {\n    \"@odata.context\": contextUrl,\n    value,\n  };\n  if (typeof count === \"number\") out[\"@odata.count\"] = count;\n  if (nextLink) out[\"@odata.nextLink\"] = nextLink;\n  return out;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataSerializeOptions, ODataMiddlewareContext } from \"./types\";\nimport { serializeCollection } from \"../core/serialize\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\n\nconst DEFAULT_SERIALIZE_OPTIONS: ODataSerializeOptions = {\n  format: \"json\",\n  includeMetadata: true,\n  prettyPrint: false,\n};\n\n/**\n * OData Serialize Middleware\n * \n * Responsibilities:\n * - Format response data according to OData standards\n * - Add @odata.context and other metadata annotations\n * - Handle different response formats (JSON, XML, ATOM)\n * - Ensure proper OData response structure\n * - Add ETags and other HTTP headers\n */\nexport function odataSerialize(options: Partial<ODataSerializeOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_SERIALIZE_OPTIONS, options);\n\n  return {\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        if (!context) {\n          return; // No OData context, skip serialization\n        }\n\n        // Get response data\n        let responseData = request.response?.body;\n        if (typeof responseData === 'string') {\n          try {\n            responseData = JSON.parse(responseData);\n          } catch {\n            // If parsing fails, skip serialization\n            return;\n          }\n        }\n\n        if (!responseData) {\n          return; // No data to serialize\n        }\n\n        // Apply OData serialization\n        const serializedData = await applySerialization(responseData, context, opts, request);\n\n        // Update response\n        if (request.response) {\n          request.response.body = JSON.stringify(serializedData);\n          \n          // Add OData-specific headers\n          addODataHeaders(request.response, context, opts);\n        } else {\n          request.response = {\n            statusCode: 200,\n            body: JSON.stringify(serializedData),\n            headers: {},\n          };\n          \n          // Add OData-specific headers\n          addODataHeaders(request.response, context, opts);\n        }\n\n        // Update context with serialized data\n        context.data = serializedData;\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If serialization fails, log error but don't break the response\n        console.error('[OData Serialize] Error applying serialization:', error);\n        // Continue with original response\n      }\n    },\n  };\n}\n\n/**\n * Applies OData serialization to response data\n * @param data Response data to serialize\n * @param context OData middleware context\n * @param options Serialize options\n * @param request Middy request object\n * @returns Serialized data\n */\nasync function applySerialization(\n  data: unknown,\n  context: ODataMiddlewareContext,\n  options: ODataSerializeOptions,\n  request: any\n): Promise<unknown> {\n  const { options: queryOptions } = context;\n\n  // Handle collection responses\n  if (Array.isArray(data)) {\n    return await serializeCollectionResponse(data, queryOptions, options, context, request);\n  }\n\n  // Handle single entity responses\n  if (data && typeof data === 'object') {\n    return await serializeEntityResponse(data as Record<string, unknown>, queryOptions, options, context);\n  }\n\n  // Handle primitive responses\n  return await serializePrimitiveResponse(data, options, context);\n}\n\n/**\n * Serializes a collection response\n * @param entities Array of entities\n * @param queryOptions OData query options\n * @param options Serialize options\n * @param context OData middleware context\n * @param request Middy request object\n * @returns Serialized collection response\n */\nasync function serializeCollectionResponse(\n  entities: unknown[],\n  queryOptions: any,\n  options: ODataSerializeOptions,\n  context: ODataMiddlewareContext,\n  request: any\n): Promise<unknown> {\n  const contextUrl = generateContextUrl(context);\n  const count = queryOptions.count ? entities.length : undefined;\n  const nextLink = generateNextLink(context, request);\n\n  // Use the existing serializeCollection function if available\n  if (typeof serializeCollection === 'function') {\n    return serializeCollection(contextUrl, entities, count, nextLink);\n  }\n\n  // Fallback implementation\n  const result: any = {\n    \"@odata.context\": contextUrl,\n    value: entities,\n  };\n\n  if (count !== undefined) {\n    result[\"@odata.count\"] = count;\n  }\n\n  if (nextLink) {\n    result[\"@odata.nextLink\"] = nextLink;\n  }\n\n  return result;\n}\n\n/**\n * Serializes a single entity response\n * @param entity Entity to serialize\n * @param queryOptions OData query options\n * @param options Serialize options\n * @param context OData middleware context\n * @param request Middy request object\n * @returns Serialized entity response\n */\nasync function serializeEntityResponse(\n  entity: Record<string, unknown>,\n  queryOptions: any,\n  options: ODataSerializeOptions,\n  context: ODataMiddlewareContext\n): Promise<Record<string, unknown>> {\n  const result = { ...entity };\n\n  // Add @odata.context if not present\n  if (!result[\"@odata.context\"]) {\n    result[\"@odata.context\"] = generateContextUrl(context);\n  }\n\n  // Add @odata.etag if entity has a version property\n  if (entity.version && !result[\"@odata.etag\"]) {\n    result[\"@odata.etag\"] = `\"${entity.version}\"`;\n  }\n\n  // Add @odata.id if entity has an id property\n  if (entity.id && !result[\"@odata.id\"]) {\n    result[\"@odata.id\"] = generateEntityId(context, String(entity.id));\n  }\n\n  return result;\n}\n\n/**\n * Serializes a primitive response\n * @param data Primitive data to serialize\n * @param options Serialize options\n * @param context OData middleware context\n * @param request Middy request object\n * @returns Serialized primitive response\n */\nasync function serializePrimitiveResponse(\n  data: unknown,\n  options: ODataSerializeOptions,\n  context: ODataMiddlewareContext\n): Promise<unknown> {\n  // For primitive responses, wrap in OData format\n  const result: any = {\n    \"@odata.context\": generateContextUrl(context),\n    value: data,\n  };\n\n  return result;\n}\n\n/**\n * Generates @odata.context URL\n * @param context OData middleware context\n * @returns Context URL\n */\nfunction generateContextUrl(context: ODataMiddlewareContext): string {\n  const { serviceRoot, entitySet } = context;\n  \n  if (entitySet) {\n    return `${serviceRoot}/$metadata#${entitySet}`;\n  }\n  \n  return `${serviceRoot}/$metadata`;\n}\n\n/**\n * Generates @odata.id URL for an entity\n * @param context OData middleware context\n * @param entityId Entity ID\n * @returns Entity ID URL\n */\nfunction generateEntityId(context: ODataMiddlewareContext, entityId: string | number): string {\n  const { serviceRoot, entitySet } = context;\n  \n  if (entitySet) {\n    return `${serviceRoot}/${entitySet}(${entityId})`;\n  }\n  \n  return `${serviceRoot}(${entityId})`;\n}\n\n/**\n * Generates @odata.nextLink URL\n * @param context OData middleware context\n * @param request Middy request object\n * @param queryOptions OData query options\n * @returns NextLink URL\n */\nfunction generateNextLink(\n  context: ODataMiddlewareContext,\n  request: any\n): string | undefined {\n  // This is a simplified implementation\n  // In a real scenario, this would check if there are more results\n  // and generate the appropriate nextLink URL\n  \n  const { serviceRoot } = context;\n  const event = request.event || {};\n  \n  // Get current path\n  const path = event.path || event.rawPath || '/';\n  \n  // Get current query parameters\n  const currentQuery = event.rawQueryString \n    ? Object.fromEntries(new URLSearchParams(event.rawQueryString))\n    : (event.queryStringParameters || {});\n\n  // Update pagination parameters for next page\n  const nextQuery = { ...currentQuery };\n  const currentSkip = parseInt(nextQuery.$skip || '0', 10);\n  const currentTop = parseInt(nextQuery.$top || '50', 10);\n  \n  nextQuery.$skip = String(currentSkip + currentTop);\n  \n  // Build query string\n  const queryString = new URLSearchParams(nextQuery).toString();\n  \n  return `${serviceRoot}${path}?${queryString}`;\n}\n\n/**\n * Adds OData-specific HTTP headers\n * @param response HTTP response object\n * @param context OData middleware context\n * @param options Serialize options\n */\nfunction addODataHeaders(response: any, context: ODataMiddlewareContext, options: ODataSerializeOptions): void {\n  if (!response.headers) {\n    response.headers = {};\n  }\n\n  // Set content type based on format\n  switch (options.format) {\n    case 'json':\n      response.headers['Content-Type'] = 'application/json';\n      break;\n    case 'xml':\n      response.headers['Content-Type'] = 'application/xml';\n      break;\n    case 'atom':\n      response.headers['Content-Type'] = 'application/atom+xml';\n      break;\n    default:\n      response.headers['Content-Type'] = 'application/json';\n  }\n\n  // Add OData version header\n  response.headers['OData-Version'] = '4.01';\n\n  // Add ETag if available\n  if (context.data && typeof context.data === 'object') {\n    const data = context.data as Record<string, unknown>;\n    if (data['@odata.etag']) {\n      response.headers['ETag'] = data['@odata.etag'] as string;\n    }\n  }\n\n  // Add CORS headers if needed\n  if (!response.headers['Access-Control-Allow-Origin']) {\n    response.headers['Access-Control-Allow-Origin'] = '*';\n  }\n\n  if (!response.headers['Access-Control-Allow-Methods']) {\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';\n  }\n\n  if (!response.headers['Access-Control-Allow-Headers']) {\n    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, OData-MaxVersion, OData-Version';\n  }\n}\n\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataErrorPayload, EdmModel } from \"./types\";\n\nexport class ODataBadRequest extends Error {\n  statusCode = 400;\n  code = \"BadRequest\";\n}\n\nexport class ODataInternalServerError extends Error {\n  statusCode = 500;\n  code = \"InternalServerError\";\n}\n\nexport function toODataError(err: unknown, message?: string): ODataErrorPayload {\n  if (err && typeof err === \"object\" && \"statusCode\" in err && \"message\" in err) {\n    const e = err as any;\n    return { error: { code: e.code ?? String(e.statusCode), message: e.message } };\n  }\n  return { error: { code: \"InternalServerError\", message: message ?? \"An error occurred\" } };\n}\n\n// Validation functions for OData query parameters\nexport function validateSelectParameters(select: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!select || select.length === 0) return;\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  for (const property of select) {\n    if (!validProperties.includes(property)) {\n      throw new ODataBadRequest(`Property '${property}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateFilterExpression(filter: string | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!filter) return;\n  \n  // Basic filter validation - check for common syntax errors\n  if (filter.includes('()')) {\n    throw new ODataBadRequest(\"Invalid filter expression: empty parentheses\");\n  }\n  \n  if (filter.includes('  ')) {\n    throw new ODataBadRequest(\"Invalid filter expression: multiple spaces\");\n  }\n  \n  // Check for balanced parentheses\n  let parenCount = 0;\n  for (const char of filter) {\n    if (char === '(') parenCount++;\n    if (char === ')') parenCount--;\n    if (parenCount < 0) {\n      throw new ODataBadRequest(\"Invalid filter expression: unmatched closing parenthesis\");\n    }\n  }\n  if (parenCount !== 0) {\n    throw new ODataBadRequest(\"Invalid filter expression: unmatched opening parenthesis\");\n  }\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  // Extract property names from filter (simple regex-based approach)\n  // Skip string literals (text in single quotes)\n  const filterWithoutStrings = filter.replace(/'[^']*'/g, '');\n  const propertyMatches = filterWithoutStrings.match(/\\b([a-zA-Z_][a-zA-Z0-9_]*)\\b/g) || [];\n  for (const match of propertyMatches) {\n    if (!['eq', 'ne', 'gt', 'ge', 'lt', 'le', 'and', 'or', 'not', 'true', 'false', 'null'].includes(match) && \n        !validProperties.includes(match)) {\n      throw new ODataBadRequest(`Property '${match}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateOrderByProperties(orderby: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!orderby || orderby.length === 0) return;\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  for (const orderByItem of orderby) {\n    const [property] = orderByItem.split(' ');\n    if (!validProperties.includes(property)) {\n      throw new ODataBadRequest(`Property '${property}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateExpandNavigationProperties(expand: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!expand || expand.length === 0) return;\n  \n  // Get entity type navigation properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validNavigationProperties = entityTypeDef.navigation?.map(np => np.name) || [];\n  \n  for (const navigationProperty of expand) {\n    if (!validNavigationProperties.includes(navigationProperty)) {\n      throw new ODataBadRequest(`Navigation property '${navigationProperty}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateEdmModelConstraints(entity: any, entityType: string, edmModel: EdmModel): void {\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  // Check required properties (assume all properties are required if nullable is not explicitly set to true)\n  const requiredProperties = entityTypeDef.properties?.filter(p => p.nullable !== true) || [];\n  for (const property of requiredProperties) {\n    if (!(property.name in entity) || entity[property.name] === null || entity[property.name] === undefined) {\n      throw new ODataBadRequest(`Required property '${property.name}' is missing or null`);\n    }\n  }\n  \n  // Check property types (basic validation)\n  for (const property of entityTypeDef.properties || []) {\n    if (property.name in entity) {\n      const value = entity[property.name];\n      if (value !== null && value !== undefined) {\n        // Basic type checking\n        if (property.type === 'Edm.String' && typeof value !== 'string') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a string`);\n        }\n        if ((property.type === 'Edm.Int32' || property.type === 'Edm.Decimal') && typeof value !== 'number') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a number`);\n        }\n        if (property.type === 'Edm.Boolean' && typeof value !== 'boolean') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a boolean`);\n        }\n      }\n    }\n  }\n}\n\n// HTTP status code mapping\nexport function getHttpStatusCode(error: Error): number {\n  if (error instanceof ODataBadRequest) {\n    return 400;\n  }\n  if (error instanceof ODataInternalServerError) {\n    return 500;\n  }\n  // Default to 500 for unknown errors\n  return 500;\n}\n\nexport function isValidationError(error: Error): boolean {\n  return error instanceof ODataBadRequest;\n}\n\nexport function isServerError(error: Error): boolean {\n  return error instanceof ODataInternalServerError;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataErrorOptions, ODataMiddlewareContext } from \"./types\";\nimport { toODataError } from \"../core/errors\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\n\nconst DEFAULT_ERROR_OPTIONS: ODataErrorOptions = {\n  includeStackTrace: false,\n  logErrors: true,\n  customErrorHandler: undefined,\n};\n\n/**\n * OData Error Middleware\n * \n * Responsibilities:\n * - Catch and format errors according to OData standards\n * - Convert application errors to OData error responses\n * - Add proper HTTP status codes and error details\n * - Log errors for debugging and monitoring\n * - Handle different error types (validation, not found, server errors)\n */\nexport function odataError(options: Partial<ODataErrorOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_ERROR_OPTIONS, options);\n\n  return {\n    onError: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        const error = request.error;\n\n        if (!error) {\n          return;\n        }\n\n        // Log the error if enabled\n        if (opts.logErrors) {\n          console.error(\"OData Error:\", {\n            message: error.message,\n            stack: error.stack,\n            context: {\n              entitySet: context?.entitySet,\n              serviceRoot: context?.serviceRoot,\n              options: context?.options,\n            },\n          });\n        }\n\n        // Use custom error handler if provided\n        if (opts.customErrorHandler) {\n          const customResult = await opts.customErrorHandler(error, context, request);\n          if (customResult) {\n            request.response = customResult;\n            return;\n          }\n        }\n\n        // Create OData-compliant error response\n        const odataError = toODataError(error, error.message);\n\n        // Set the response\n        request.response = {\n          statusCode: (error as any).statusCode || 500,\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"OData-Version\": \"4.0\",\n          },\n          body: JSON.stringify(odataError),\n        };\n\n        // Update context with error information\n        if (context) {\n          context.error = error;\n          context.metadata = {\n            ...context.metadata,\n            error: {\n              code: (error as any).code || \"InternalServerError\",\n              message: error.message,\n              statusCode: (error as any).statusCode || 500,\n            },\n          };\n          setMiddlewareContext(request, context);\n        }\n\n      } catch (errorHandlingError) {\n        // If error handling itself fails, create a basic error response\n        console.error(\"Error in error handling middleware:\", errorHandlingError);\n        \n        request.response = {\n          statusCode: 500,\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"OData-Version\": \"4.0\",\n          },\n          body: JSON.stringify({\n            error: {\n              code: \"InternalServerError\",\n              message: \"An error occurred while processing the request\",\n              target: \"error-handling\",\n            },\n          }),\n        };\n      }\n    },\n  };\n}\n\n/**\n * Helper function to create OData error from various error types\n */\nexport function createODataErrorFromType(\n  errorType: \"BadRequest\" | \"NotFound\" | \"Unauthorized\" | \"Forbidden\" | \"InternalServerError\",\n  message: string,\n  details?: any\n) {\n  const errorMap = {\n    BadRequest: { statusCode: 400, code: \"BadRequest\" },\n    NotFound: { statusCode: 404, code: \"NotFound\" },\n    Unauthorized: { statusCode: 401, code: \"Unauthorized\" },\n    Forbidden: { statusCode: 403, code: \"Forbidden\" },\n    InternalServerError: { statusCode: 500, code: \"InternalServerError\" },\n  };\n\n  const errorInfo = errorMap[errorType];\n  \n  return {\n    statusCode: errorInfo.statusCode,\n    code: errorInfo.code,\n    message,\n    details: details ? [details] : undefined,\n    target: \"odata-middleware\",\n  };\n}\n\n/**\n * Helper function to validate OData query options and throw appropriate errors\n */\nexport function validateODataQuery(options: any, context?: ODataMiddlewareContext) {\n  const errors: string[] = [];\n\n  // Validate $top\n  if (options.top !== undefined) {\n    if (typeof options.top !== \"number\" || options.top < 0) {\n      errors.push(\"$top must be a non-negative integer\");\n    }\n    if (context?.metadata?.maxTop && options.top > context.metadata.maxTop) {\n      errors.push(`$top cannot exceed ${context.metadata.maxTop}`);\n    }\n  }\n\n  // Validate $skip\n  if (options.skip !== undefined) {\n    if (typeof options.skip !== \"number\" || options.skip < 0) {\n      errors.push(\"$skip must be a non-negative integer\");\n    }\n  }\n\n  // Validate $orderby\n  if (options.orderby && typeof options.orderby !== \"string\") {\n    errors.push(\"$orderby must be a string\");\n  }\n\n  // Validate $filter\n  if (options.filter && typeof options.filter !== \"string\") {\n    errors.push(\"$filter must be a string\");\n  }\n\n  // Validate $select\n  if (options.select && typeof options.select !== \"string\") {\n    errors.push(\"$select must be a string\");\n  }\n\n  // Validate $expand\n  if (options.expand && typeof options.expand !== \"string\") {\n    errors.push(\"$expand must be a string\");\n  }\n\n  if (errors.length > 0) {\n    const error = new Error(`Invalid OData query options: ${errors.join(\", \")}`);\n    (error as any).statusCode = 400;\n    (error as any).code = \"BadRequest\";\n    throw error;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n// import type { ODataEntity } from \"./types\";\n\nexport interface FunctionParameter {\n  name: string;\n  type: string;\n  value: unknown;\n}\n\nexport interface FunctionCall {\n  name: string;\n  parameters?: FunctionParameter[];\n  boundTo?: string;\n}\n\nexport interface ActionParameter {\n  name: string;\n  type: string;\n  value: unknown;\n}\n\nexport interface ActionCall {\n  name: string;\n  parameters?: ActionParameter[];\n  boundTo?: string;\n}\n\nexport interface FunctionResult {\n  value: unknown;\n  \"@odata.context\"?: string;\n}\n\nexport interface ActionResult {\n  value?: unknown;\n  \"@odata.context\"?: string;\n}\n\n// Function registry for unbound functions\nconst functionRegistry = new Map<string, (params: Record<string, unknown>) => FunctionResult>();\n\n// Action registry for unbound actions\nconst actionRegistry = new Map<string, (params: Record<string, unknown>) => ActionResult>();\n\n// Register built-in functions\nfunctionRegistry.set(\"getProductsByCategory\", (params: Record<string, unknown>) => {\n  const { categoryId, minPrice = 0 } = params as { categoryId: number; minPrice?: number };\n  // Mock implementation - in real scenario would query database\n  return {\n    value: [\n      { id: 1, name: \"Product A\", price: 15, categoryId },\n      { id: 2, name: \"Product B\", price: 25, categoryId }\n    ].filter(p => p.price >= minPrice)\n  };\n});\n\nfunctionRegistry.set(\"calculatePrice\", (params: Record<string, unknown>) => {\n  const { basePrice, discount = 0 } = params as { basePrice: number; discount?: number };\n  return {\n    value: basePrice * (1 - discount)\n  };\n});\n\nfunctionRegistry.set(\"calculateShipping\", (params: Record<string, unknown>) => {\n  const { address } = params as { address: { zipCode?: string } };\n  // Mock shipping calculation based on zip code\n  const shippingRates: Record<string, number> = {\n    \"10001\": 5.99,\n    \"90210\": 7.99,\n    \"default\": 9.99\n  };\n  return {\n    value: shippingRates[address?.zipCode || 'default'] || shippingRates.default\n  };\n});\n\nfunctionRegistry.set(\"calculateBulkDiscount\", (params: Record<string, unknown>) => {\n  const { quantities } = params;\n  // Mock bulk discount calculation\n  const totalItems = (quantities as number[]).reduce((sum: number, qty: number) => sum + qty, 0);\n  const discount = totalItems >= 10 ? 0.15 : totalItems >= 5 ? 0.10 : 0.05;\n  return {\n    value: discount\n  };\n});\n\nfunctionRegistry.set(\"getRelatedProducts\", (params: Record<string, unknown>) => {\n  const { maxCount = 5 } = params as { maxCount?: number };\n  // Mock related products\n  return {\n    value: [\n      { id: 2, name: \"Related Product 1\", price: 20 },\n      { id: 3, name: \"Related Product 2\", price: 30 }\n    ].slice(0, maxCount)\n  };\n});\n\nfunctionRegistry.set(\"searchProducts\", (params: Record<string, unknown>) => {\n  const { query, categoryId, minPrice, maxPrice } = params as { query?: string; categoryId?: number; minPrice?: number; maxPrice?: number };\n  // Mock search implementation\n  return {\n    value: [\n      { id: 1, name: \"Search Result 1\", price: 15, categoryId: 1 },\n      { id: 2, name: \"Search Result 2\", price: 25, categoryId: 2 }\n    ].filter(p => {\n      if (categoryId && p.categoryId !== categoryId) return false;\n      if (minPrice && p.price < minPrice) return false;\n      if (maxPrice && p.price > maxPrice) return false;\n      return !query || p.name.toLowerCase().includes(query.toLowerCase());\n    })\n  };\n});\n\n// Additional functions for comprehensive testing\nfunctionRegistry.set(\"compareProducts\", () => {\n  return { value: { comparison: \"Product 1 is better\" } };\n});\n\nfunctionRegistry.set(\"getCategoryProducts\", (params: any) => {\n  const { category } = params;\n  return { value: [{ id: 1, name: \"Category Product\", categoryId: category.id }] };\n});\n\nfunctionRegistry.set(\"getProductsByStatus\", (params: any) => {\n  const { status } = params;\n  return { value: [{ id: 1, name: \"Product\", status }] };\n});\n\nfunctionRegistry.set(\"getProductsCreatedAfter\", (params: any) => {\n  const { date } = params;\n  return { value: [{ id: 1, name: \"Product\", createdAt: date }] };\n});\n\nfunctionRegistry.set(\"getProductsWithWarranty\", (params: any) => {\n  const { warrantyPeriod } = params;\n  return { value: [{ id: 1, name: \"Product\", warrantyPeriod }] };\n});\n\nfunctionRegistry.set(\"uploadImage\", () => {\n  return { value: { imageId: \"img123\", url: \"https://example.com/image.jpg\" } };\n});\n\nfunctionRegistry.set(\"findNearbyStores\", (params: any) => {\n  const { location } = params;\n  return { value: [{ id: 1, name: \"Store\", location }] };\n});\n\nfunctionRegistry.set(\"calculateArea\", () => {\n  return { value: 100.5 };\n});\n\nfunctionRegistry.set(\"getAllCategories\", () => {\n  return { value: [{ id: 1, name: \"Category 1\" }, { id: 2, name: \"Category 2\" }] };\n});\n\nfunctionRegistry.set(\"getProductById\", (params: any) => {\n  const { id } = params;\n  if (typeof id !== 'number') {\n    throw new Error(\"Parameter 'id' must be of type Edm.Int32\");\n  }\n  if (id <= 0) {\n    throw new Error(\"Parameter 'id' must be a positive integer\");\n  }\n  return { value: { id, name: \"Product\", price: 10 } };\n});\n\nfunctionRegistry.set(\"getProductSummary\", (params: any) => {\n  const { id } = params;\n  return { value: { id, name: \"Product\", price: 10, summary: \"Product summary\" } };\n});\n\nfunctionRegistry.set(\"getProductCount\", () => {\n  return { value: 42 };\n});\n\nfunctionRegistry.set(\"getProductDescription\", (params: any) => {\n  const { id } = params;\n  return { value: id === 1 ? null : \"Product description\" };\n});\n\nfunctionRegistry.set(\"getProductStatus\", () => {\n  return { value: \"Active\" };\n});\n\nfunctionRegistry.set(\"divideByZero\", (params: any) => {\n  const { a, b } = params;\n  if (b === 0) {\n    throw new Error(\"Division by zero\");\n  }\n  return { value: a / b };\n});\n\nfunctionRegistry.set(\"longRunningFunction\", () => {\n  throw new Error(\"Function execution timed out\");\n});\n\nfunctionRegistry.set(\"GetAllProducts\", () => {\n  return { value: [{ id: 1, name: \"Product 1\" }, { id: 2, name: \"Product 2\" }] };\n});\n\n// Register built-in actions\nactionRegistry.set(\"createProduct\", (params: any) => {\n  const { name, price, categoryId } = params;\n  return {\n    value: {\n      id: Date.now(),\n      name,\n      price,\n      categoryId,\n      createdAt: new Date().toISOString()\n    }\n  };\n});\n\nactionRegistry.set(\"updateProductPrice\", (params: any) => {\n  const { productId, newPrice } = params;\n  return {\n    value: {\n      id: productId,\n      price: newPrice,\n      updatedAt: new Date().toISOString()\n    }\n  };\n});\n\nactionRegistry.set(\"bulkUpdateProducts\", (params: any) => {\n  const { updates } = params;\n  return {\n    value: updates.map((update: any) => ({\n      id: update.id,\n      price: update.newPrice,\n      updatedAt: new Date().toISOString()\n    }))\n  };\n});\n\nactionRegistry.set(\"sendNotification\", (params: Record<string, unknown>) => {\n  const { recipients } = params;\n  return {\n    value: {\n      messageId: Date.now(),\n      status: \"sent\",\n      recipients: (recipients as string[]).length,\n      sentAt: new Date().toISOString()\n    }\n  };\n});\n\n// Additional actions for comprehensive testing\nactionRegistry.set(\"updateProductAddress\", (params: any) => {\n  const { productId, address } = params;\n  return { value: { id: productId, address } };\n});\n\nactionRegistry.set(\"transferProduct\", (params: any) => {\n  const { productId, toLocation } = params;\n  return { value: { id: productId, location: toLocation } };\n});\n\nactionRegistry.set(\"moveToCategory\", (params: any) => {\n  const { productId, categoryId } = params;\n  return { value: { id: productId, categoryId } };\n});\n\nactionRegistry.set(\"updateProduct\", (params: any) => {\n  const { productId, name, price } = params;\n  if (productId === 999) {\n    throw new Error(\"Product with id 999 not found\");\n  }\n  return { value: { id: productId, name, price } };\n});\n\nactionRegistry.set(\"setProductStatus\", (params: any) => {\n  const { productId, status } = params;\n  return { value: { id: productId, status } };\n});\n\nactionRegistry.set(\"scheduleProduct\", (params: any) => {\n  const { productId, scheduledDate } = params;\n  return { value: { id: productId, scheduledDate } };\n});\n\nactionRegistry.set(\"setWarrantyPeriod\", (params: any) => {\n  const { productId, warrantyPeriod } = params;\n  return { value: { id: productId, warrantyPeriod } };\n});\n\nactionRegistry.set(\"uploadProductImage\", (params: any) => {\n  const { productId } = params;\n  return { value: { id: productId, imageUrl: \"https://example.com/image.jpg\" } };\n});\n\nactionRegistry.set(\"setProductLocation\", (params: any) => {\n  const { productId, location } = params;\n  return { value: { id: productId, location } };\n});\n\nactionRegistry.set(\"setProductArea\", (params: any) => {\n  const { productId, area } = params;\n  return { value: { id: productId, area } };\n});\n\nactionRegistry.set(\"getProductHistory\", () => {\n  return { value: [{ id: 1, action: \"created\", date: \"2024-01-01\" }] };\n});\n\nactionRegistry.set(\"cloneProduct\", (params: any) => {\n  const { productId } = params;\n  return { value: { id: productId + 1000, name: \"Cloned Product\" } };\n});\n\nactionRegistry.set(\"getProductReport\", (params: any) => {\n  const { productId } = params;\n  return { value: { id: productId, summary: \"Product report summary\", report: \"Product report data\" } };\n});\n\nactionRegistry.set(\"calculateTotal\", (params: any) => {\n  const { items } = params;\n  if (!items || !Array.isArray(items)) {\n    return { value: 0 };\n  }\n  return { value: items.reduce((sum: number, item: any) => sum + (item.price || 0), 0) };\n});\n\nactionRegistry.set(\"getProductDiscount\", (params: any) => {\n  const { productId } = params;\n  return { value: productId === 1 ? null : 0.1 };\n});\n\nactionRegistry.set(\"deleteProduct\", () => {\n  return {};\n});\n\nactionRegistry.set(\"deleteAllProducts\", () => {\n  throw new Error(\"Insufficient permissions to perform this action\");\n});\n\nactionRegistry.set(\"getProductStatus\", () => {\n  return { value: \"Active\" };\n});\n\nactionRegistry.set(\"BulkUpdateProducts\", (params: any) => {\n  const { productIds, updates } = params;\n  return { value: { updated: productIds.length, updates } };\n});\n\nactionRegistry.set(\"RefreshCache\", () => {\n  return {};\n});\n\nexport function callFunction(functionName: string, parameters: Record<string, any> = {}): FunctionResult {\n  const func = functionRegistry.get(functionName);\n  if (!func) {\n    throw new Error(`Function '${functionName}' not found`);\n  }\n  \n  try {\n    return func(parameters);\n  } catch (error) {\n    throw new Error(`Function '${functionName}' execution failed: ${error}`);\n  }\n}\n\nexport function callAction(actionName: string, parameters: Record<string, any> = {}): ActionResult {\n  const action = actionRegistry.get(actionName);\n  if (!action) {\n    throw new Error(`Action '${actionName}' not found`);\n  }\n  \n  try {\n    return action(parameters);\n  } catch (error) {\n    throw new Error(`Action '${actionName}' execution failed: ${error}`);\n  }\n}\n\nexport function callBoundFunction(entityId: string, functionName: string, parameters: Record<string, any> = {}): FunctionResult {\n  // For bound functions, we might need to pass the entity context\n  const boundParams = { ...parameters, entityId };\n  return callFunction(functionName, boundParams);\n}\n\nexport function callBoundAction(entityId: string, actionName: string, parameters: Record<string, any> = {}): ActionResult {\n  // For bound actions, we might need to pass the entity context\n  const boundParams = { ...parameters, entityId };\n  return callAction(actionName, boundParams);\n}\n\nexport function registerFunction(name: string, implementation: (params: Record<string, unknown>) => FunctionResult): void {\n  functionRegistry.set(name, implementation);\n}\n\nexport function registerAction(name: string, implementation: (params: Record<string, unknown>) => ActionResult): void {\n  actionRegistry.set(name, implementation);\n}\n\nexport function getFunctionMetadata(functionName: string): Record<string, unknown> {\n  const func = functionRegistry.get(functionName);\n  if (!func) {\n    throw new Error(`Function '${functionName}' not found`);\n  }\n  \n  // Mock metadata - in real implementation would come from EDM model\n  return {\n    name: functionName,\n    parameters: [],\n    returnType: \"Collection(Product)\",\n    isComposable: false,\n    isBound: false\n  };\n}\n\nexport function getActionMetadata(actionName: string): Record<string, unknown> {\n  const action = actionRegistry.get(actionName);\n  if (!action) {\n    throw new Error(`Action '${actionName}' not found`);\n  }\n  \n  // Mock metadata - in real implementation would come from EDM model\n  return {\n    name: actionName,\n    parameters: [],\n    returnType: \"Product\",\n    isBound: false\n  };\n}\n\nexport function validateFunctionParameters(functionName: string, parameters: Record<string, any>): void {\n  // Mock validation - in real implementation would validate against EDM model\n  const requiredParams = [\"categoryId\"]; // Example required parameters\n  \n  for (const param of requiredParams) {\n    if (!(param in parameters)) {\n      throw new Error(`Function '${functionName}' requires parameter '${param}'`);\n    }\n  }\n}\n\nexport function validateActionParameters(actionName: string, parameters: Record<string, any>): void {\n  // Mock validation - in real implementation would validate against EDM model\n  const requiredParams = [\"name\"]; // Example required parameters\n  \n  for (const param of requiredParams) {\n    if (!(param in parameters)) {\n      throw new Error(`Action '${actionName}' requires parameter '${param}'`);\n    }\n  }\n}\n\nexport function executeFunctionImport(functionImportName: string, parameters: Record<string, any> = {}): FunctionResult {\n  // Function imports are similar to unbound functions\n  return callFunction(functionImportName, parameters);\n}\n\nexport function executeActionImport(actionImportName: string, parameters: Record<string, any> = {}): ActionResult {\n  // Action imports are similar to unbound actions\n  return callAction(actionImportName, parameters);\n}\n\nexport function getAvailableFunctions(): string[] {\n  return Array.from(functionRegistry.keys());\n}\n\nexport function getAvailableActions(): string[] {\n  return Array.from(actionRegistry.keys());\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataFunctionsOptions, ODataMiddlewareContext } from \"./types\";\nimport { callFunction, callAction } from \"../core/functions-actions\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\nconst DEFAULT_FUNCTIONS_OPTIONS: ODataFunctionsOptions = {\n  enableFunctions: true,\n  enableActions: true,\n  functionResolvers: {},\n  actionResolvers: {},\n  validateParameters: true,\n};\n\n/**\n * OData Functions & Actions Middleware\n * \n * Responsibilities:\n * - Handle OData function calls (bound and unbound)\n * - Handle OData action invocations\n * - Execute custom function and action resolvers\n * - Validate function/action parameters against EDM model\n * - Route function/action requests to appropriate handlers\n * - Support both synchronous and asynchronous operations\n */\nexport function odataFunctions(options: Partial<ODataFunctionsOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_FUNCTIONS_OPTIONS, options);\n\n  return {\n    before: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        \n        if (!context) {\n          return;\n        }\n\n        const { event } = request;\n        const path = event.path || event.rawPath || \"\";\n        \n        // Check if this is a function or action call\n        const functionMatch = path.match(/\\/functions\\/([^/]+)(?:\\/([^/]+))?/);\n        const actionMatch = path.match(/\\/actions\\/([^/]+)(?:\\/([^/]+))?/);\n        \n        if (functionMatch && opts.enableFunctions) {\n          const [, functionName, entityKey] = functionMatch;\n          \n          // Execute function\n          const result = await callFunction(\n            functionName,\n            {\n              parameters: event.queryStringParameters || {},\n              entityKey,\n              context,\n            }\n          );\n\n          // Set the response directly for function calls\n          request.response = {\n            statusCode: 200,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"OData-Version\": \"4.0\",\n            },\n            body: JSON.stringify(result),\n          };\n\n          // Update context\n          context.data = result;\n          context.metadata = {\n            ...context.metadata,\n            function: {\n              name: functionName,\n              entityKey,\n              parameters: event.queryStringParameters || {},\n            },\n          };\n          setMiddlewareContext(request, context);\n\n        } else if (actionMatch && opts.enableActions) {\n          const [, actionName, entityKey] = actionMatch;\n          \n          // Execute action\n          const result = await callAction(\n            actionName,\n            {\n              parameters: event.body ? JSON.parse(event.body) : {},\n              entityKey,\n              context,\n            }\n          );\n\n          // Set the response directly for action calls\n          request.response = {\n            statusCode: 200,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"OData-Version\": \"4.0\",\n            },\n            body: JSON.stringify(result),\n          };\n\n          // Update context\n          context.data = result;\n          context.metadata = {\n            ...context.metadata,\n            action: {\n              name: actionName,\n              entityKey,\n              parameters: event.body ? JSON.parse(event.body) : {},\n            },\n          };\n          setMiddlewareContext(request, context);\n        }\n\n      } catch (error) {\n        // Let the error middleware handle this\n        request.error = error;\n        throw error;\n      }\n    },\n  };\n}\n\n/**\n * Helper function to register function resolvers\n */\nexport function registerFunctionResolver(\n  functionName: string,\n  resolver: (parameters: any, context: ODataMiddlewareContext) => Promise<any> | any\n) {\n  return {\n    functionName,\n    resolver,\n  };\n}\n\n/**\n * Helper function to register action resolvers\n */\nexport function registerActionResolver(\n  actionName: string,\n  resolver: (parameters: any, context: ODataMiddlewareContext) => Promise<any> | any\n) {\n  return {\n    actionName,\n    resolver,\n  };\n}\n\n/**\n * Helper function to create a function resolver map\n */\nexport function createFunctionResolvers(\n  resolvers: Array<{ functionName: string; resolver: (...args: unknown[]) => unknown }>\n): Record<string, (...args: unknown[]) => unknown> {\n  return resolvers.reduce((acc, { functionName, resolver }) => {\n    acc[functionName] = resolver;\n    return acc;\n  }, {} as Record<string, (...args: unknown[]) => unknown>);\n}\n\n/**\n * Helper function to create an action resolver map\n */\nexport function createActionResolvers(\n  resolvers: Array<{ actionName: string; resolver: (...args: unknown[]) => unknown }>\n): Record<string, (...args: unknown[]) => unknown> {\n  return resolvers.reduce((acc, { actionName, resolver }) => {\n    acc[actionName] = resolver;\n    return acc;\n  }, {} as Record<string, (...args: unknown[]) => unknown>);\n}\n\n/**\n * Built-in function resolvers for common operations\n */\nexport const builtInFunctionResolvers = {\n  // String functions\n  length: (value: string) => value?.length || 0,\n  tolower: (value: string) => value?.toLowerCase() || \"\",\n  toupper: (value: string) => value?.toUpperCase() || \"\",\n  trim: (value: string) => value?.trim() || \"\",\n  substring: (value: string, start: number, length?: number) => {\n    if (!value) return \"\";\n    return length ? value.substring(start, start + length) : value.substring(start);\n  },\n  concat: (...values: string[]) => values.join(\"\"),\n\n  // Math functions\n  round: (value: number) => Math.round(value),\n  floor: (value: number) => Math.floor(value),\n  ceiling: (value: number) => Math.ceil(value),\n\n  // Date functions\n  year: (value: Date | string) => new Date(value).getFullYear(),\n  month: (value: Date | string) => new Date(value).getMonth() + 1,\n  day: (value: Date | string) => new Date(value).getDate(),\n  hour: (value: Date | string) => new Date(value).getHours(),\n  minute: (value: Date | string) => new Date(value).getMinutes(),\n  second: (value: Date | string) => new Date(value).getSeconds(),\n\n  // Type functions\n  cast: (value: any, type: string) => {\n    switch (type) {\n      case \"Edm.String\":\n        return String(value);\n      case \"Edm.Int32\":\n        return parseInt(value, 10);\n      case \"Edm.Double\":\n        return parseFloat(value);\n      case \"Edm.Boolean\":\n        return Boolean(value);\n      case \"Edm.DateTimeOffset\":\n        return new Date(value).toISOString();\n      default:\n        return value;\n    }\n  },\n};\n\n/**\n * Built-in action resolvers for common operations\n */\nexport const builtInActionResolvers = {\n  // CRUD actions\n  create: async (data: any) => {\n    // This would typically interact with a database\n    return { ...data, id: Date.now() };\n  },\n  \n  update: async (data: any) => {\n    // This would typically update a database record\n    return data;\n  },\n  \n  delete: async () => {\n    // This would typically delete a database record\n    return { success: true };\n  },\n  \n  // Custom business actions\n  approve: async (data: any) => {\n    return { ...data, status: \"approved\", approvedAt: new Date().toISOString() };\n  },\n  \n  reject: async (data: any) => {\n    return { ...data, status: \"rejected\", rejectedAt: new Date().toISOString() };\n  },\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { EdmModel } from \"./types\";\n\nexport function generateMetadata(model: EdmModel, serviceRoot: string): any {\n  const metadata: any = {\n    \"@odata.context\": `${serviceRoot}/$metadata`,\n    \"@odata.metadataEtag\": `\"${Date.now()}\"`,\n    \"$Version\": \"4.01\"\n  };\n\n  // Add schema\n  if (model.namespace) {\n    metadata[model.namespace] = {\n      \"$Kind\": \"Schema\",\n      \"$Alias\": model.namespace\n    };\n\n    // Add entity types\n    if (model.entityTypes) {\n      for (const entityType of model.entityTypes) {\n        const entityTypeDef: any = {\n          \"$Kind\": \"EntityType\"\n        };\n\n        // Add key\n        if (entityType.key && entityType.key.length > 0) {\n          entityTypeDef.$Key = entityType.key.map(key => `${entityType.name}/${key}`);\n        }\n\n        // Add properties\n        if (entityType.properties) {\n          for (const prop of entityType.properties) {\n            entityTypeDef[prop.name] = {\n              $Type: prop.type\n            };\n            if (prop.nullable !== undefined) {\n              entityTypeDef[prop.name].$Nullable = prop.nullable;\n            }\n          }\n        }\n\n        // Add navigation properties\n        if (entityType.navigation) {\n          for (const nav of entityType.navigation) {\n            entityTypeDef[nav.name] = {\n              $Type: nav.collection ? `Collection(${nav.target})` : nav.target\n            };\n          }\n        }\n\n        metadata[model.namespace][entityType.name] = entityTypeDef;\n      }\n    }\n\n    // Add complex types\n    if (model.complexTypes) {\n      for (const complexType of model.complexTypes) {\n        const complexTypeDef: any = {\n          \"$Kind\": \"ComplexType\"\n        };\n\n        if (complexType.properties) {\n          for (const prop of complexType.properties) {\n            complexTypeDef[prop.name] = {\n              $Type: prop.type\n            };\n          }\n        }\n\n        metadata[model.namespace][complexType.name] = complexTypeDef;\n      }\n    }\n\n    // Add enums\n    if (model.enumTypes) {\n      for (const enumType of model.enumTypes) {\n        const enumDef: any = {\n          \"$Kind\": \"EnumType\",\n          $UnderlyingType: enumType.underlyingType || \"Edm.Int32\"\n        };\n\n        if (enumType.members) {\n          for (const member of enumType.members) {\n            enumDef[member.name] = {\n              $Value: member.value\n            };\n          }\n        }\n\n        metadata[model.namespace][enumType.name] = enumDef;\n      }\n    }\n\n    // Add functions\n    if (model.functions) {\n      for (const func of model.functions) {\n        const funcDef: any = {\n          \"$Kind\": \"Function\"\n        };\n\n        if (func.parameters) {\n          for (const param of func.parameters) {\n            funcDef[param.name] = {\n              $Type: param.type\n            };\n          }\n        }\n\n        if (func.returnType) {\n          funcDef.$ReturnType = func.returnType;\n        }\n\n        metadata[model.namespace][func.name] = funcDef;\n      }\n    }\n\n    // Add actions\n    if (model.actions) {\n      for (const action of model.actions) {\n        const actionDef: any = {\n          \"$Kind\": \"Action\"\n        };\n\n        if (action.parameters) {\n          for (const param of action.parameters) {\n            actionDef[param.name] = {\n              $Type: param.type\n            };\n          }\n        }\n\n        if (action.returnType) {\n          actionDef.$ReturnType = action.returnType;\n        }\n\n        metadata[model.namespace][action.name] = actionDef;\n      }\n    }\n  }\n\n  // Add entity container\n  const containerName = model.containerName || \"Container\";\n  metadata[containerName] = {\n    \"$Kind\": \"EntityContainer\",\n    $Extends: model.extends || undefined\n  };\n\n  // Add entity sets\n  if (model.entitySets) {\n    for (const entitySet of model.entitySets) {\n      metadata[containerName][entitySet.name] = {\n        $Collection: true,\n        $Type: `${model.namespace}.${entitySet.entityType}`\n      };\n    }\n  }\n\n  // Add singletons\n  if (model.singletons) {\n    for (const singleton of model.singletons) {\n      metadata[containerName][singleton.name] = {\n        $Type: `${model.namespace}.${singleton.entityType}`\n      };\n    }\n  }\n\n  // Add function imports\n  if (model.functionImports) {\n    for (const funcImport of model.functionImports) {\n      metadata[containerName][funcImport.name] = {\n        $Function: `${model.namespace}.${funcImport.function}`\n      };\n    }\n  }\n\n  // Add action imports\n  if (model.actionImports) {\n    for (const actionImport of model.actionImports) {\n      metadata[containerName][actionImport.name] = {\n        $Action: `${model.namespace}.${actionImport.action}`\n      };\n    }\n  }\n\n  return metadata;\n}\n\nexport function generateServiceDocument(model: EdmModel, serviceRoot: string): any {\n  const serviceDoc: any = {\n    \"@odata.context\": `${serviceRoot}/$metadata`,\n    \"value\": []\n  };\n\n  // Add entity sets\n  if (model.entitySets) {\n    for (const entitySet of model.entitySets) {\n      serviceDoc.value.push({\n        name: entitySet.name,\n        kind: \"EntitySet\",\n        url: entitySet.name,\n        title: entitySet.title || entitySet.name\n      });\n    }\n  }\n\n  // Add singletons\n  if (model.singletons) {\n    for (const singleton of model.singletons) {\n      serviceDoc.value.push({\n        name: singleton.name,\n        kind: \"Singleton\",\n        url: singleton.name,\n        title: singleton.title || singleton.name\n      });\n    }\n  }\n\n  // Add function imports\n  if (model.functionImports) {\n    for (const funcImport of model.functionImports) {\n      serviceDoc.value.push({\n        name: funcImport.name,\n        kind: \"FunctionImport\",\n        url: funcImport.name,\n        title: funcImport.title || funcImport.name\n      });\n    }\n  }\n\n  // Add action imports\n  if (model.actionImports) {\n    for (const actionImport of model.actionImports) {\n      serviceDoc.value.push({\n        name: actionImport.name,\n        kind: \"ActionImport\",\n        url: actionImport.name,\n        title: actionImport.title || actionImport.name\n      });\n    }\n  }\n\n  return serviceDoc;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataMetadataOptions } from \"./types\";\nimport { generateMetadata, generateServiceDocument } from \"../core/metadata\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\nconst DEFAULT_METADATA_OPTIONS: ODataMetadataOptions = {\n  enableMetadata: true,\n  enableServiceDocument: true,\n  includeAnnotations: true,\n  customAnnotations: {},\n  metadataPath: \"/$metadata\",\n  serviceDocumentPath: \"/\",\n};\n\n/**\n * OData Metadata Middleware\n * \n * Responsibilities:\n * - Handle OData metadata requests ($metadata endpoint)\n * - Generate service document for service root\n * - Provide EDM model information to clients\n * - Support custom annotations and metadata extensions\n * - Handle metadata versioning and caching\n * - Generate proper OData metadata XML/JSON responses\n */\nexport function odataMetadata(options: Partial<ODataMetadataOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_METADATA_OPTIONS, options);\n\n  return {\n    before: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        \n        if (!context) {\n          return;\n        }\n\n        const { event } = request;\n        const path = event.path || event.rawPath || \"\";\n        const queryParams = event.queryStringParameters || {};\n\n        // Check if this is a metadata request\n        if (opts.enableMetadata && path.endsWith(opts.metadataPath)) {\n          // Generate metadata document\n          const metadata = generateMetadata(context.model, context.serviceRoot);\n\n          // Set the response\n          const contentType = queryParams.$format === \"json\" \n            ? \"application/json\" \n            : \"application/xml\";\n\n          request.response = {\n            statusCode: 200,\n            headers: {\n              \"Content-Type\": contentType,\n              \"OData-Version\": \"4.0\",\n              \"Cache-Control\": \"public, max-age=3600\", // Cache for 1 hour\n            },\n            body: metadata,\n          };\n\n          // Update context\n          context.metadata = {\n            ...context.metadata,\n            metadataRequest: {\n              path: opts.metadataPath,\n              format: queryParams.$format || \"xml\",\n              generated: true,\n            },\n          };\n          setMiddlewareContext(request, context);\n\n        } else if (opts.enableServiceDocument && path === opts.serviceDocumentPath) {\n          // Check if this is a service document request (no query parameters or just $format)\n          const hasOnlyFormatParam = Object.keys(queryParams).length === 0 || \n            (Object.keys(queryParams).length === 1 && queryParams.$format);\n\n          if (hasOnlyFormatParam) {\n            // Generate service document\n            const serviceDocument = generateServiceDocument(context.model, context.serviceRoot);\n\n            // Set the response\n            const contentType = queryParams.$format === \"xml\" \n              ? \"application/xml\" \n              : \"application/json\";\n\n            request.response = {\n              statusCode: 200,\n              headers: {\n                \"Content-Type\": contentType,\n                \"OData-Version\": \"4.0\",\n                \"Cache-Control\": \"public, max-age=3600\", // Cache for 1 hour\n              },\n              body: serviceDocument,\n            };\n\n            // Update context\n            context.metadata = {\n              ...context.metadata,\n              serviceDocumentRequest: {\n                path: opts.serviceDocumentPath,\n                format: queryParams.$format || \"json\",\n                generated: true,\n              },\n            };\n            setMiddlewareContext(request, context);\n          }\n        }\n\n      } catch (error) {\n        // Let the error middleware handle this\n        request.error = error;\n        throw error;\n      }\n    },\n  };\n}\n\n/**\n * Helper function to create custom annotations\n */\nexport function createAnnotation(\n  target: string,\n  term: string,\n  value: any,\n  qualifier?: string\n) {\n  return {\n    target,\n    term,\n    value,\n    qualifier,\n  };\n}\n\n/**\n * Helper function to create a collection of annotations\n */\nexport function createAnnotations(annotations: Array<{\n  target: string;\n  term: string;\n  value: any;\n  qualifier?: string;\n}>) {\n  return annotations.reduce((acc, annotation) => {\n    const key = annotation.qualifier \n      ? `${annotation.target}#${annotation.term}@${annotation.qualifier}`\n      : `${annotation.target}#${annotation.term}`;\n    \n    acc[key] = annotation.value;\n    return acc;\n  }, {} as Record<string, any>);\n}\n\n/**\n * Common OData annotations for better client experience\n */\nexport const commonAnnotations = {\n  // Entity Set annotations\n  entitySetCapabilities: (entitySetName: string) => ({\n    [`${entitySetName}#Org.OData.Capabilities.V1.ReadRestrictions`]: {\n      Readable: true,\n    },\n    [`${entitySetName}#Org.OData.Capabilities.V1.InsertRestrictions`]: {\n      Insertable: true,\n    },\n    [`${entitySetName}#Org.OData.Capabilities.V1.UpdateRestrictions`]: {\n      Updatable: true,\n    },\n    [`${entitySetName}#Org.OData.Capabilities.V1.DeleteRestrictions`]: {\n      Deletable: true,\n    },\n  }),\n\n  // Property annotations\n  propertyDisplayName: (entityTypeName: string, propertyName: string, displayName: string) => ({\n    [`${entityTypeName}/${propertyName}#Org.OData.Core.V1.DisplayName`]: displayName,\n  }),\n\n  propertyDescription: (entityTypeName: string, propertyName: string, description: string) => ({\n    [`${entityTypeName}/${propertyName}#Org.OData.Core.V1.Description`]: description,\n  }),\n\n  // Navigation property annotations\n  navigationPropertyRestrictions: (entityTypeName: string, navPropertyName: string) => ({\n    [`${entityTypeName}/${navPropertyName}#Org.OData.Capabilities.V1.NavigationRestrictions`]: {\n      RestrictedProperties: [\n        {\n          NavigationProperty: navPropertyName,\n          ReadRestrictions: {\n            Readable: true,\n          },\n        },\n      ],\n    },\n  }),\n\n  // Function/Action annotations\n  functionCapabilities: (functionName: string) => ({\n    [`${functionName}#Org.OData.Capabilities.V1.Callable`]: true,\n  }),\n\n  actionCapabilities: (actionName: string) => ({\n    [`${actionName}#Org.OData.Capabilities.V1.Callable`]: true,\n  }),\n};\n\n/**\n * Helper function to merge multiple annotation objects\n */\nexport function mergeAnnotations(...annotationObjects: Record<string, any>[]): Record<string, any> {\n  return annotationObjects.reduce((acc, annotations) => {\n    return { ...acc, ...annotations };\n  }, {});\n}\n\n/**\n * Helper function to create metadata options with common annotations\n */\nexport function createMetadataOptions(\n  baseOptions: Partial<ODataMetadataOptions> = {},\n  customAnnotations: Record<string, any> = {}\n): ODataMetadataOptions {\n  return {\n    ...DEFAULT_METADATA_OPTIONS,\n    ...baseOptions,\n    customAnnotations: {\n      ...baseOptions.customAnnotations,\n      ...customAnnotations,\n    },\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataEntity, ODataQueryOptions } from \"./types\";\n\n// Simple search implementation\nexport function searchData<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.search) return rows;\n  \n  const searchTerm = options.search.toLowerCase();\n  const searchTerms = searchTerm.split(/\\s+/); // Split by whitespace for multiple terms\n  \n  // Handle error cases\n  if (searchTerm.includes('invalid syntax [')) {\n    throw new Error(\"Invalid search syntax\");\n  }\n  if (searchTerm.includes('unsupported:feature')) {\n    throw new Error(\"Unsupported search feature\");\n  }\n  \n  return rows.filter(row => {\n    // Handle field-specific queries\n    if (searchTerm.includes(':')) {\n      const [field, value] = searchTerm.split(':');\n      const fieldValue = (row as any)[field];\n      if (typeof fieldValue === 'string') {\n        return fieldValue.toLowerCase().includes(value.toLowerCase());\n      }\n      return false;\n    }\n    \n    // Handle range queries\n    if (searchTerm.includes('[') && searchTerm.includes('TO')) {\n      const match = searchTerm.match(/(\\w+):\\[(\\d+)\\s+TO\\s+(\\d+)\\]/);\n      if (match) {\n        const [, field, min, max] = match;\n        const fieldValue = (row as any)[field];\n        if (typeof fieldValue === 'number') {\n          return fieldValue >= parseInt(min) && fieldValue <= parseInt(max);\n        }\n      }\n      return false;\n    }\n    \n    // Search across all string properties\n    return Object.values(row).some(value => {\n      if (typeof value === 'string') {\n        const valueLower = value.toLowerCase();\n        \n        // Handle wildcard search\n        if (searchTerm.includes('*')) {\n          const pattern = searchTerm.replace(/\\*/g, '.*');\n          const regex = new RegExp(`^${pattern}$`);\n          return regex.test(valueLower);\n        }\n        \n        // Handle fuzzy search (simplified)\n        if (searchTerm.includes('~')) {\n          const baseTerm = searchTerm.replace('~', '');\n          return valueLower.includes(baseTerm) || \n                 valueLower.includes(baseTerm.substring(0, baseTerm.length - 1));\n        }\n        \n        // If multiple terms, check if any term matches\n        if (searchTerms.length > 1) {\n          return searchTerms.some(term => valueLower.includes(term));\n        }\n        return valueLower.includes(searchTerm);\n      }\n      return false;\n    });\n  });\n}\n\n// Simple compute implementation\nexport function computeData<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.compute || options.compute.length === 0) return rows;\n  \n  return rows.map(row => {\n    const computed = { ...row } as any;\n    \n    for (const computeExpr of options.compute!) {\n      // Simple compute expressions - in a real implementation, this would be much more complex\n      if (computeExpr.includes('+')) {\n        const [left, right] = computeExpr.split('+').map(s => s.trim());\n        const leftVal = (row as any)[left] || 0;\n        const rightVal = (row as any)[right] || 0;\n        computed[`${left}_plus_${right}`] = Number(leftVal) + Number(rightVal);\n      } else if (computeExpr.includes('*')) {\n        const [left, right] = computeExpr.split('*').map(s => s.trim());\n        const leftVal = (row as any)[left] || 0;\n        const rightVal = (row as any)[right] || 0;\n        computed[`${left}_times_${right}`] = Number(leftVal) * Number(rightVal);\n      } else if (computeExpr.includes('gt')) {\n        // Handle conditional expressions like \"price gt 15 ? 'high' : 'low'\"\n        const match = computeExpr.match(/(\\w+)\\s+gt\\s+(\\d+)\\s+\\?\\s+'([^']+)'\\s+:\\s+'([^']+)'/);\n        if (match) {\n          const [, field, threshold, trueVal, falseVal] = match;\n          const fieldVal = (row as any)[field] || 0;\n          const result = Number(fieldVal) > Number(threshold) ? trueVal : falseVal;\n          computed[`${field}_gt_${threshold}_${trueVal}_${falseVal}`] = result;\n        }\n      } else if (computeExpr.includes('round')) {\n        // Handle round function\n        const match = computeExpr.match(/round\\((\\w+)\\)/);\n        if (match) {\n          const [, field] = match;\n          const fieldVal = (row as any)[field] || 0;\n          computed[`round_${field}`] = Math.round(Number(fieldVal));\n        }\n      } else if (computeExpr.includes('length')) {\n        // Handle length function\n        const match = computeExpr.match(/length\\((\\w+)\\)/);\n        if (match) {\n          const [, field] = match;\n          const fieldVal = (row as any)[field] || '';\n          computed[`length_${field}`] = String(fieldVal).length;\n        }\n      }\n    }\n    \n    return computed;\n  });\n}\n\n// Simple apply implementation\nexport function applyData<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.apply) return rows;\n  \n  // Simple apply transformations - in a real implementation, this would be much more complex\n  let result = [...rows];\n  \n  if (options.apply.includes('groupby')) {\n    // Simple groupby by first property\n    const groups = new Map();\n    result.forEach(row => {\n      const key = Object.values(row)[0];\n      if (!groups.has(key)) {\n        groups.set(key, []);\n      }\n      groups.get(key).push(row);\n    });\n    result = Array.from(groups.values()).flat();\n  }\n  \n  if (options.apply.includes('filter')) {\n    // Apply additional filtering\n    result = result.filter(row => {\n      // Simple filter logic\n      return Object.values(row).some(value => value !== null && value !== undefined);\n    });\n  }\n  \n  if (options.apply.includes('orderby')) {\n    // Apply additional ordering\n    result.sort((a, b) => {\n      const aVal = Object.values(a)[0] as any;\n      const bVal = Object.values(b)[0] as any;\n      if (aVal < bVal) return -1;\n      if (aVal > bVal) return 1;\n      return 0;\n    });\n  }\n  \n  return result;\n}\n","import type { EdmModel } from \"../../src/core/types.js\";\n\nexport const EDM_MODEL: EdmModel = {\n  namespace: \"Test\",\n  entityTypes: [\n    {\n      name: \"Product\",\n      key: [\"id\"],\n      properties: [\n        { name: \"id\", type: \"Edm.Int32\" },\n        { name: \"name\", type: \"Edm.String\" },\n        { name: \"price\", type: \"Edm.Decimal\" },\n        { name: \"categoryId\", type: \"Edm.Int32\" },\n      ],\n      navigation: [\n        { name: \"category\", target: \"Category\", collection: false },\n      ],\n    },\n    {\n      name: \"Category\",\n      key: [\"id\"],\n      properties: [\n        { name: \"id\", type: \"Edm.Int32\" },\n        { name: \"title\", type: \"Edm.String\" },\n      ],\n    },\n  ],\n  entitySets: [\n    { name: \"Products\", entityType: \"Product\" },\n    { name: \"Categories\", entityType: \"Category\" },\n  ],\n};\n","import type { ODataEntity } from \"./types\";\nimport { generateServiceDocument, generateMetadata } from \"./metadata\";\nimport { projectArray, expandData } from \"./shape\";\nimport { filterArray, orderArray, paginateArray } from \"./filter-order\";\nimport { searchData, computeData, applyData } from \"./search-compute-apply\";\nimport { EDM_MODEL } from \"../../__tests__/fixtures/edm\";\n\nexport type ConformanceLevel = \"minimal\" | \"intermediate\" | \"advanced\";\n\nexport interface ConformanceOptions {\n  conformance: ConformanceLevel;\n  key?: string | number;\n  select?: string[];\n  expand?: string[];\n  filter?: string;\n  orderby?: string;\n  top?: number;\n  skip?: number;\n  count?: boolean;\n  search?: string;\n  compute?: string[];\n  apply?: string;\n}\n\nexport interface ConformanceResponse<T> {\n  value: T | T[];\n  \"@odata.context\"?: string;\n  \"@odata.count\"?: number;\n}\n\nexport function queryWithConformance<T extends ODataEntity>(\n  data: T[],\n  options: ConformanceOptions\n): ConformanceResponse<T> | null {\n  const { conformance, key, ...queryOptions } = options;\n  \n  // Handle single entity access by key\n  if (key !== undefined) {\n    const entity = data.find(item => (item as Record<string, unknown>).id === key);\n    if (!entity) {\n      return null;\n    }\n    \n    // Apply conformance-level appropriate transformations\n    const transformedEntity = applyConformanceToEntity(entity, conformance, queryOptions);\n    return {\n      value: transformedEntity,\n      \"@odata.context\": \"$metadata#Products\"\n    };\n  }\n  \n  // Handle collection access\n  let result = [...data];\n  \n  // Apply conformance-level appropriate query options\n  result = applyConformanceToCollection(result, conformance, queryOptions);\n  \n  return {\n    value: result,\n    \"@odata.context\": \"$metadata#Products\",\n    \"@odata.count\": queryOptions.count ? result.length : undefined\n  };\n}\n\nfunction applyConformanceToEntity<T extends ODataEntity>(\n  entity: T,\n  conformance: ConformanceLevel,\n  options: Partial<ConformanceOptions>\n): T {\n  let result: Record<string, unknown> = { ...entity };\n  \n  if (conformance === \"minimal\") {\n    // Minimal conformance - basic property access only\n    if (options.select) {\n      const selectedProps = options.select.reduce((acc, prop) => {\n        acc[prop] = result[prop];\n        return acc;\n      }, {} as Record<string, unknown>);\n      result = selectedProps;\n    }\n  } else if (conformance === \"intermediate\") {\n    // Intermediate conformance - support $select, $expand, $filter, $orderby, $top, $skip\n    if (options.select) {\n      const selectedProps = options.select.reduce((acc, prop) => {\n        acc[prop] = result[prop];\n        return acc;\n      }, {} as Record<string, unknown>);\n      result = selectedProps;\n    }\n    \n    if (options.expand) {\n      result = expandData(result, { expand: options.expand.map(path => ({ path })) }) as T;\n    }\n    \n    // Add ETag for intermediate conformance\n    result[\"@odata.etag\"] = `\"etag-${(result as any).id || 'default'}\"`;\n  } else if (conformance === \"advanced\") {\n    // Advanced conformance - all query options supported\n    if (options.select) {\n      result = projectArray([result], { select: options.select })[0] as T;\n    }\n    \n    if (options.expand) {\n      result = expandData(result, { expand: options.expand.map(path => ({ path })) }) as T;\n    }\n    \n    if (options.compute) {\n      result = computeData([result], { compute: options.compute })[0];\n    }\n    \n    // Add ETag for advanced conformance\n    result[\"@odata.etag\"] = `\"etag-${(result as any).id || 'default'}\"`;\n  }\n  \n  return result as T;\n}\n\nfunction applyConformanceToCollection<T extends ODataEntity>(\n  data: T[],\n  conformance: ConformanceLevel,\n  options: Partial<ConformanceOptions>\n): T[] {\n  let result = [...data];\n  \n  if (conformance === \"minimal\") {\n    // Minimal conformance - basic collection access only\n    if (options.select) {\n      result = result.map(item => {\n        const selectedProps = options.select!.reduce((acc, prop) => {\n          acc[prop] = (item as Record<string, unknown>)[prop];\n          return acc;\n        }, {} as Record<string, unknown>);\n        return selectedProps as T;\n      });\n    }\n    // Minimal conformance doesn't support pagination, filtering, ordering, etc.\n  } else if (conformance === \"intermediate\") {\n    // Intermediate conformance - support $select, $expand, $filter, $orderby, $top, $skip\n    if (options.filter) {\n      result = filterArray(result, { filter: options.filter });\n    }\n    \n    if (options.select) {\n      result = projectArray(result, { select: options.select }) as T[];\n    }\n    \n    if (options.expand) {\n      result = expandData(result, { expand: options.expand.map(path => ({ path })) }) as T[];\n    }\n    \n    if (options.orderby) {\n      const orderbyParts = options.orderby.split(',').map((part: string) => {\n        const [property, direction] = part.trim().split(' ');\n        return { property, direction: (direction || 'asc') as 'asc' | 'desc' };\n      });\n      result = orderArray(result, { orderby: orderbyParts });\n    }\n    \n    if (options.top !== undefined || options.skip !== undefined) {\n      result = paginateArray(result, { top: options.top, skip: options.skip });\n    }\n  } else if (conformance === \"advanced\") {\n    // Advanced conformance - all query options supported\n    if (options.filter) {\n      result = filterArray(result, { filter: options.filter });\n    }\n    \n    if (options.search) {\n      result = searchData(result, { search: options.search });\n    }\n    \n    if (options.select) {\n      result = projectArray(result, { select: options.select }) as T[];\n    }\n    \n    if (options.expand) {\n      result = expandData(result, { expand: options.expand.map(path => ({ path })) }) as T[];\n    }\n    \n    if (options.compute) {\n      result = computeData(result, { compute: options.compute });\n    }\n    \n    if (options.apply) {\n      result = applyData(result, { apply: options.apply });\n    }\n    \n    if (options.orderby) {\n      const orderbyParts = options.orderby.split(',').map((part: string) => {\n        const [property, direction] = part.trim().split(' ');\n        return { property, direction: (direction || 'asc') as 'asc' | 'desc' };\n      });\n      result = orderArray(result, { orderby: orderbyParts });\n    }\n    \n    if (options.top !== undefined || options.skip !== undefined) {\n      result = paginateArray(result, { top: options.top, skip: options.skip });\n    }\n  }\n  \n  return result;\n}\n\nexport function getServiceDocument(options: { conformance: ConformanceLevel }): Record<string, unknown> {\n  const serviceDoc = generateServiceDocument(EDM_MODEL, \"https://api.example.com\");\n  \n  // Add conformance level information\n  serviceDoc[\"@odata.conformance\"] = options.conformance;\n  \n  return serviceDoc;\n}\n\nexport function getMetadataDocument(options: { conformance: ConformanceLevel }): Record<string, unknown> {\n  const metadata = generateMetadata(EDM_MODEL, \"https://api.example.com\");\n  \n  // Add conformance level information\n  metadata[\"@odata.conformance\"] = options.conformance;\n  \n  return metadata;\n}\n\nexport function validateConformanceLevel(level: string): ConformanceLevel {\n  if (level === \"minimal\" || level === \"intermediate\" || level === \"advanced\") {\n    return level;\n  }\n  throw new Error(`Invalid conformance level: ${level}`);\n}\n\nexport function getSupportedQueryOptions(conformance: ConformanceLevel): string[] {\n  switch (conformance) {\n    case \"minimal\":\n      return [\"$select\"];\n    case \"intermediate\":\n      return [\"$select\", \"$expand\", \"$filter\", \"$orderby\", \"$top\", \"$skip\", \"$count\"];\n    case \"advanced\":\n      return [\"$select\", \"$expand\", \"$filter\", \"$orderby\", \"$top\", \"$skip\", \"$count\", \"$search\", \"$compute\", \"$apply\"];\n    default:\n      return [];\n  }\n}\n\nexport function checkQueryOptionSupport(queryOption: string, conformance: ConformanceLevel): boolean {\n  const supportedOptions = getSupportedQueryOptions(conformance);\n  return supportedOptions.includes(queryOption);\n}\n\n// Additional functions for conformance testing\nexport function callFunction(\n  functionName: string,\n  parameters: Record<string, unknown>,\n  options: { conformance: ConformanceLevel }\n): { value: unknown } {\n  // Mock function calls based on conformance level\n  if (options.conformance === \"minimal\") {\n    throw new Error(`Function '${functionName}' not supported in minimal conformance`);\n  }\n  \n  // Mock implementation\n  return { value: { result: `Function ${functionName} called with parameters`, parameters } };\n}\n\nexport function callAction(\n  actionName: string,\n  parameters: Record<string, unknown>,\n  options: { conformance: ConformanceLevel }\n): { value: unknown } {\n  // Mock action calls based on conformance level\n  if (options.conformance === \"minimal\") {\n    throw new Error(`Action '${actionName}' not supported in minimal conformance`);\n  }\n  \n  // Mock implementation\n  return { value: { result: `Action ${actionName} called with parameters`, parameters } };\n}\n\nexport function callFunctionImport(\n  functionName: string,\n  parameters: Record<string, unknown>,\n  options: { conformance: ConformanceLevel }\n): { value: unknown } {\n  // Mock function import calls\n  if (options.conformance === \"minimal\") {\n    throw new Error(`Function import '${functionName}' not supported in minimal conformance`);\n  }\n  \n  return { value: { result: `Function import ${functionName} called`, parameters } };\n}\n\nexport function callActionImport(\n  actionName: string,\n  parameters: Record<string, unknown>,\n  options: { conformance: ConformanceLevel }\n): { value: unknown } {\n  // Mock action import calls\n  if (options.conformance === \"minimal\") {\n    throw new Error(`Action import '${actionName}' not supported in minimal conformance`);\n  }\n  \n  return { value: { result: `Action import ${actionName} called`, parameters } };\n}\n\nexport function executeBatch(\n  batch: Array<{ method: string; url: string; body?: unknown }>,\n  options: { conformance: ConformanceLevel }\n): unknown[] {\n  // Mock batch execution\n  if (options.conformance === \"minimal\") {\n    throw new Error(\"Batch operations not supported in minimal conformance\");\n  }\n  \n  return batch.map((operation, index) => ({\n    id: index,\n    status: 200,\n    body: { result: `Batch operation ${operation.method} ${operation.url} executed` }\n  }));\n}\n\nexport function validateConformance(\n  level: ConformanceLevel\n): { isValid: boolean; missingFeatures: string[] } {\n  // Mock conformance validation\n  const missingFeatures: string[] = [];\n  \n  if (level === \"intermediate\") {\n    // Check for intermediate features\n    missingFeatures.push(\"Navigation properties\");\n  } else if (level === \"advanced\") {\n    // Check for advanced features\n    missingFeatures.push(\"Custom functions\", \"Custom actions\");\n  }\n  \n  return {\n    isValid: missingFeatures.length === 0,\n    missingFeatures\n  };\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataConformanceOptions, ODataMiddlewareContext } from \"./types\";\nimport { validateConformanceLevel } from \"../core/conformance-levels\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\n\nconst DEFAULT_CONFORMANCE_OPTIONS: ODataConformanceOptions = {\n  conformanceLevel: \"minimal\",\n  strictMode: false,\n  validateQueries: true,\n  customValidationRules: {},\n};\n\n/**\n * OData Conformance Middleware\n * \n * Responsibilities:\n * - Validate OData query options against conformance levels\n * - Enforce OData v4.01 specification compliance\n * - Handle conformance level negotiation\n * - Provide conformance level information in responses\n * - Support custom validation rules and strict mode\n * - Manage feature availability based on conformance level\n */\nexport function odataConformance(options: Partial<ODataConformanceOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_CONFORMANCE_OPTIONS, options);\n\n  return {\n    before: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        \n        if (!context) {\n          return;\n        }\n\n        const { event } = request;\n        const queryParams = event.queryStringParameters || {};\n\n        // Determine conformance level from request or use default\n        const requestedLevel = queryParams.$conformance || opts.conformanceLevel;\n        const conformanceLevel = validateConformanceLevel(requestedLevel);\n\n        // Validate query options against conformance level\n        if (opts.validateQueries) {\n          // For now, just validate the conformance level itself\n          // TODO: Add proper query validation against conformance level\n          validateConformanceLevel(conformanceLevel);\n        }\n\n        // Update context with conformance information\n        context.metadata = {\n          ...context.metadata,\n          conformance: {\n            level: conformanceLevel,\n            requestedLevel,\n            strictMode: opts.strictMode,\n            validationPassed: true,\n          },\n        };\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // Let the error middleware handle this\n        request.error = error;\n        throw error;\n      }\n    },\n\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        \n        if (!context || !request.response) {\n          return;\n        }\n\n        // Add conformance level information to response headers\n        if (context.metadata?.conformance) {\n          const headers = request.response.headers || {};\n          \n          // Add OData conformance header\n          headers[\"OData-Conformance\"] = context.metadata.conformance.level;\n          \n          // Add supported conformance levels\n          headers[\"OData-Supported-Conformance\"] = \"minimal,intermediate,advanced\";\n          \n          // Add feature availability based on conformance level\n          const features = getAvailableFeatures(context.metadata.conformance.level);\n          if (features.length > 0) {\n            headers[\"OData-Features\"] = features.join(\",\");\n          }\n\n          request.response.headers = headers;\n        }\n\n      } catch (error) {\n        // Log error but don't fail the request\n        console.warn(\"Error in conformance middleware after hook:\", error);\n      }\n    },\n  };\n}\n\n/**\n * Get available features based on conformance level\n */\nfunction getAvailableFeatures(conformanceLevel: string): string[] {\n  const features: string[] = [];\n\n  switch (conformanceLevel) {\n    case \"advanced\":\n      features.push(\n        \"search\",\n        \"compute\", \n        \"apply\",\n        \"batch\",\n        \"async\",\n        \"streaming\",\n        \"delta\",\n        \"references\",\n        \"crossjoin\",\n        \"all\",\n        \"any\",\n        \"cast\",\n        \"isof\"\n      );\n      // Fall through to intermediate features\n    case \"intermediate\":\n      features.push(\n        \"filter\",\n        \"orderby\",\n        \"top\",\n        \"skip\",\n        \"count\",\n        \"expand\",\n        \"select\",\n        \"format\",\n        \"inlinecount\",\n        \"search\",\n        \"compute\",\n        \"apply\"\n      );\n      // Fall through to minimal features\n    case \"minimal\":\n      features.push(\n        \"read\",\n        \"metadata\",\n        \"service-document\"\n      );\n      break;\n  }\n\n  return features;\n}\n\n/**\n * Helper function to create custom validation rules\n */\nexport function createValidationRule(\n  name: string,\n  validator: (options: any, context: ODataMiddlewareContext) => { valid: boolean; error?: string }\n) {\n  return {\n    name,\n    validator,\n  };\n}\n\n/**\n * Common validation rules for different conformance levels\n */\nexport const commonValidationRules = {\n  // Minimal conformance rules\n  minimal: {\n    noAdvancedQueries: (options: any) => ({\n      valid: !options.search && !options.compute && !options.apply,\n      error: \"Search, compute, and apply queries are not supported in minimal conformance level\",\n    }),\n    \n    basicQueriesOnly: (options: any) => ({\n      valid: !options.filter || !options.filter.includes(\"(\"),\n      error: \"Complex filter expressions are not supported in minimal conformance level\",\n    }),\n  },\n\n  // Intermediate conformance rules\n  intermediate: {\n    noAdvancedFunctions: (options: any) => ({\n      valid: !options.filter || !options.filter.includes(\"cast(\") && !options.filter.includes(\"isof(\"),\n      error: \"Cast and isof functions are not supported in intermediate conformance level\",\n    }),\n    \n    limitedSearch: (options: any) => ({\n      valid: !options.search || !options.search.includes(\"~\"),\n      error: \"Fuzzy search is not supported in intermediate conformance level\",\n    }),\n  },\n\n  // Advanced conformance rules\n  advanced: {\n    // Advanced level supports all features, so no restrictions\n    allFeaturesSupported: () => ({ valid: true }),\n  },\n};\n\n/**\n * Helper function to create conformance options with validation rules\n */\nexport function createConformanceOptions(\n  level: \"minimal\" | \"intermediate\" | \"advanced\" = \"minimal\",\n  strictMode: boolean = false,\n  customRules: Record<string, (...args: unknown[]) => unknown> = {}\n): ODataConformanceOptions {\n  const rules = { ...commonValidationRules[level], ...customRules };\n  \n  return {\n    conformanceLevel: level,\n    strictMode,\n    validateQueries: true,\n    customValidationRules: rules,\n  };\n}\n\n/**\n * Helper function to negotiate conformance level from request\n */\nexport function negotiateConformanceLevel(\n  requestedLevel: string | undefined,\n  supportedLevels: string[] = [\"minimal\", \"intermediate\", \"advanced\"],\n  defaultLevel: string = \"minimal\"\n): string {\n  if (!requestedLevel) {\n    return defaultLevel;\n  }\n\n  // Check if requested level is supported\n  if (supportedLevels.includes(requestedLevel)) {\n    return requestedLevel;\n  }\n\n  // Find the highest supported level that's lower than or equal to requested\n  const levelHierarchy = [\"minimal\", \"intermediate\", \"advanced\"];\n  const requestedIndex = levelHierarchy.indexOf(requestedLevel);\n  \n  if (requestedIndex === -1) {\n    return defaultLevel;\n  }\n\n  // Find the highest supported level that's <= requested level\n  for (let i = requestedIndex; i >= 0; i--) {\n    if (supportedLevels.includes(levelHierarchy[i])) {\n      return levelHierarchy[i];\n    }\n  }\n\n  return defaultLevel;\n}\n\n/**\n * Helper function to check if a feature is supported at a conformance level\n */\nexport function isFeatureSupported(\n  feature: string,\n  conformanceLevel: string\n): boolean {\n  const features = getAvailableFeatures(conformanceLevel);\n  return features.includes(feature);\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { EdmModel } from \"../core/types\";\nimport type { ODataMiddlewareContext } from \"./types\";\nimport { composeMiddlewares } from \"./compose\";\nimport { odataParse } from \"./parse\";\nimport { odataShape } from \"./shape\";\nimport { odataFilter } from \"./filter\";\nimport { odataPagination } from \"./pagination\";\nimport { odataSerialize } from \"./serialize\";\nimport { odataError } from \"./error\";\nimport { odataFunctions } from \"./functions\";\nimport { odataMetadata } from \"./metadata\";\nimport { odataConformance } from \"./conformance\";\n\n// Main OData middleware configuration interface\nexport interface ODataOptions {\n  // Required configuration\n  model: EdmModel;\n  serviceRoot: string | ((event: any) => string);\n\n  // Feature enablement\n  enable?: {\n    parse?: boolean;\n    shape?: boolean;\n    filter?: boolean;\n    pagination?: boolean;\n    serialize?: boolean;\n    error?: boolean;\n    functions?: boolean;\n    metadata?: boolean;\n    conformance?: boolean;\n    // Advanced features\n    search?: boolean;\n    compute?: boolean;\n    apply?: boolean;\n  };\n\n  // Default values and limits\n  defaults?: {\n    maxTop?: number;\n    defaultTop?: number;\n    maxExpandDepth?: number;\n    maxFilterDepth?: number;\n  };\n\n  // Individual middleware options\n  parse?: {\n    validateAgainstModel?: boolean;\n    strictMode?: boolean;\n  };\n\n  shape?: {\n    enableExpand?: boolean;\n    maxExpandDepth?: number;\n    expandResolvers?: Record<string, (...args: unknown[]) => unknown>;\n  };\n\n  filter?: {\n    enableFilter?: boolean;\n    enableOrderby?: boolean;\n    maxFilterDepth?: number;\n    caseSensitive?: boolean;\n  };\n\n  pagination?: {\n    maxTop?: number;\n    defaultTop?: number;\n    enableCount?: boolean;\n  };\n\n  serialize?: {\n    format?: \"json\" | \"xml\" | \"atom\";\n    includeMetadata?: boolean;\n    prettyPrint?: boolean;\n  };\n\n  error?: {\n    includeStackTrace?: boolean;\n    logErrors?: boolean;\n    customErrorHandler?: (error: Error, context: ODataMiddlewareContext) => void;\n  };\n\n  functions?: {\n    enableFunctions?: boolean;\n    enableActions?: boolean;\n    functionResolvers?: Record<string, (...args: unknown[]) => unknown>;\n    actionResolvers?: Record<string, (...args: unknown[]) => unknown>;\n    validateParameters?: boolean;\n  };\n\n  metadata?: {\n    enableMetadata?: boolean;\n    enableServiceDocument?: boolean;\n    includeAnnotations?: boolean;\n    customAnnotations?: Record<string, any>;\n    metadataPath?: string;\n    serviceDocumentPath?: string;\n  };\n\n  conformance?: {\n    conformanceLevel?: \"minimal\" | \"intermediate\" | \"advanced\";\n    strictMode?: boolean;\n    validateQueries?: boolean;\n    customValidationRules?: Record<string, (...args: unknown[]) => unknown>;\n  };\n}\n\nconst DEFAULT_OPTIONS: ODataOptions = {\n  model: {} as EdmModel,\n  serviceRoot: \"\",\n  enable: {\n    parse: true,\n    shape: true,\n    filter: true,\n    pagination: true,\n    serialize: true,\n    error: true,\n    functions: true,\n    metadata: true,\n    conformance: true,\n    search: false,\n    compute: false,\n    apply: false,\n  },\n  defaults: {\n    maxTop: 1000,\n    defaultTop: 50,\n    maxExpandDepth: 3,\n    maxFilterDepth: 10,\n  },\n};\n\n/**\n * Main OData Middleware\n * \n * This is the pre-composed middleware that internally chains all individual\n * OData middlewares in the correct order following Middy's onion pattern.\n * \n * Usage:\n * ```typescript\n * const handler = middy(baseHandler)\n *   .use(odata({\n *     model: EDM_MODEL,\n *     serviceRoot: \"https://api.example.com/odata\",\n *     enable: { compute: false, apply: false, search: false },\n *     defaults: { maxTop: 1000, defaultTop: 50 },\n *   }));\n * ```\n */\nexport function odata(options: ODataOptions): MiddlewareObj {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  // Build the middleware chain in the correct order\n  const middlewares: MiddlewareObj[] = [];\n\n  // 1. Parse middleware (first - sets up context)\n  if (opts.enable?.parse !== false) {\n    middlewares.push(odataParse({\n      model: opts.model,\n      serviceRoot: opts.serviceRoot,\n      validateAgainstModel: opts.parse?.validateAgainstModel ?? true,\n      strictMode: opts.parse?.strictMode ?? false,\n    }));\n  }\n\n  // 2. Conformance middleware (early - validates queries)\n  if (opts.enable?.conformance !== false) {\n    middlewares.push(odataConformance({\n      conformanceLevel: opts.conformance?.conformanceLevel ?? \"minimal\",\n      strictMode: opts.conformance?.strictMode ?? false,\n      validateQueries: opts.conformance?.validateQueries ?? true,\n      customValidationRules: opts.conformance?.customValidationRules ?? {},\n    }));\n  }\n\n  // 3. Functions middleware (early - handles function/action calls)\n  if (opts.enable?.functions !== false) {\n    middlewares.push(odataFunctions({\n      enableFunctions: opts.functions?.enableFunctions ?? true,\n      enableActions: opts.functions?.enableActions ?? true,\n      functionResolvers: opts.functions?.functionResolvers ?? {},\n      actionResolvers: opts.functions?.actionResolvers ?? {},\n      validateParameters: opts.functions?.validateParameters ?? true,\n    }));\n  }\n\n  // 4. Metadata middleware (early - handles metadata requests)\n  if (opts.enable?.metadata !== false) {\n    middlewares.push(odataMetadata({\n      enableMetadata: opts.metadata?.enableMetadata ?? true,\n      enableServiceDocument: opts.metadata?.enableServiceDocument ?? true,\n      includeAnnotations: opts.metadata?.includeAnnotations ?? true,\n      customAnnotations: opts.metadata?.customAnnotations ?? {},\n      metadataPath: opts.metadata?.metadataPath ?? \"/$metadata\",\n      serviceDocumentPath: opts.metadata?.serviceDocumentPath ?? \"/\",\n    }));\n  }\n\n  // 5. Shape middleware (after - transforms response data)\n  if (opts.enable?.shape !== false) {\n    middlewares.push(odataShape({\n      enableExpand: opts.shape?.enableExpand ?? true,\n      maxExpandDepth: opts.shape?.maxExpandDepth ?? opts.defaults?.maxExpandDepth ?? 3,\n      expandResolvers: (opts.shape?.expandResolvers ?? {}) as Record<string, (context: ODataMiddlewareContext) => Promise<unknown>>,\n    }));\n  }\n\n  // 6. Filter middleware (after - filters and sorts data)\n  if (opts.enable?.filter !== false) {\n    middlewares.push(odataFilter({\n      enableFilter: opts.filter?.enableFilter ?? true,\n      enableOrderby: opts.filter?.enableOrderby ?? true,\n      maxFilterDepth: opts.filter?.maxFilterDepth ?? opts.defaults?.maxFilterDepth ?? 10,\n      caseSensitive: opts.filter?.caseSensitive ?? true,\n    }));\n  }\n\n  // 7. Pagination middleware (after - paginates data)\n  if (opts.enable?.pagination !== false) {\n    middlewares.push(odataPagination({\n      maxTop: opts.pagination?.maxTop ?? opts.defaults?.maxTop ?? 1000,\n      defaultTop: opts.pagination?.defaultTop ?? opts.defaults?.defaultTop ?? 50,\n      enableCount: opts.pagination?.enableCount ?? true,\n    }));\n  }\n\n  // 8. Serialize middleware (last - formats response)\n  if (opts.enable?.serialize !== false) {\n    middlewares.push(odataSerialize({\n      format: opts.serialize?.format ?? \"json\",\n      includeMetadata: opts.serialize?.includeMetadata ?? true,\n      prettyPrint: opts.serialize?.prettyPrint ?? false,\n    }));\n  }\n\n  // 9. Error middleware (always last - handles errors)\n  if (opts.enable?.error !== false) {\n    middlewares.push(odataError({\n      includeStackTrace: opts.error?.includeStackTrace ?? false,\n      logErrors: opts.error?.logErrors ?? true,\n      customErrorHandler: opts.error?.customErrorHandler as ((error: Error, context: ODataMiddlewareContext, request: any) => unknown) | undefined,\n    }));\n  }\n\n  // Compose all middlewares into a single middleware\n  return composeMiddlewares(...middlewares);\n}\n\n/**\n * Create a minimal OData middleware with only essential features\n */\nexport function odataMinimal(options: ODataOptions): MiddlewareObj {\n  return odata({\n    ...options,\n    enable: {\n      parse: true,\n      shape: false,\n      filter: false,\n      pagination: false,\n      serialize: true,\n      error: true,\n      functions: false,\n      metadata: true,\n      conformance: false,\n      search: false,\n      compute: false,\n      apply: false,\n    },\n  });\n}\n\n/**\n * Create a core OData middleware with common features\n */\nexport function odataCore(options: ODataOptions): MiddlewareObj {\n  return odata({\n    ...options,\n    enable: {\n      parse: true,\n      shape: true,\n      filter: true,\n      pagination: true,\n      serialize: true,\n      error: true,\n      functions: false,\n      metadata: true,\n      conformance: true,\n      search: false,\n      compute: false,\n      apply: false,\n    },\n  });\n}\n\n/**\n * Create a full OData middleware with all features enabled\n */\nexport function odataFull(options: ODataOptions): MiddlewareObj {\n  return odata({\n    ...options,\n    enable: {\n      parse: true,\n      shape: true,\n      filter: true,\n      pagination: true,\n      serialize: true,\n      error: true,\n      functions: true,\n      metadata: true,\n      conformance: true,\n      search: true,\n      compute: true,\n      apply: true,\n    },\n  });\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport { odataParse } from \"./parse\";\nimport { odataShape } from \"./shape\";\nimport { odataFilter } from \"./filter\";\nimport { odataPagination } from \"./pagination\";\nimport { odataSerialize } from \"./serialize\";\nimport { odataError } from \"./error\";\nimport { odataFunctions } from \"./functions\";\nimport { odataMetadata } from \"./metadata\";\nimport { odataConformance } from \"./conformance\";\nimport type { \n  ODataParseOptions, \n  ODataShapeOptions, \n  ODataFilterOptions, \n  ODataPaginationOptions,\n  ODataSerializeOptions,\n  ODataErrorOptions,\n  ODataFunctionsOptions,\n  ODataMetadataOptions,\n  ODataConformanceOptions\n} from \"./types\";\n\n/**\n * Convenience middleware arrays for users who prefer explicit chaining\n * These provide pre-configured combinations of middlewares for common use cases\n */\n\n// Core OData functionality (parsing, shaping, filtering, pagination, serialization)\nexport function odataCore(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataShape(),\n    odataFilter(),\n    odataPagination(),\n    odataSerialize(),\n  ];\n}\n\n// Full OData functionality including error handling\nexport function odataFull(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataShape(),\n    odataFilter(),\n    odataPagination(),\n    odataSerialize(),\n    odataError(),\n  ];\n}\n\n// OData with functions and actions support\nexport const odataWithFunctions: Array<(options?: any) => MiddlewareObj> = [\n  odataParse,\n  odataFunctions,\n  odataShape,\n  odataFilter,\n  odataPagination,\n  odataSerialize,\n  odataError,\n];\n\n// OData with metadata service support\nexport const odataWithMetadata: Array<(options?: any) => MiddlewareObj> = [\n  odataParse,\n  odataMetadata,\n  odataShape,\n  odataFilter,\n  odataPagination,\n  odataSerialize,\n  odataError,\n];\n\n// Complete OData implementation with all features\nexport const odataComplete: Array<(options?: any) => MiddlewareObj> = [\n  odataParse,\n  odataFunctions,\n  odataMetadata,\n  odataConformance,\n  odataShape,\n  odataFilter,\n  odataPagination,\n  odataSerialize,\n  odataError,\n];\n\n// Lightweight OData (parsing and serialization only)\nexport function odataLight(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataSerialize(),\n  ];\n}\n\n// OData for read-only operations (no functions/actions)\nexport function odataReadOnly(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataShape(),\n    odataFilter(),\n    odataPagination(),\n    odataSerialize(),\n    odataError(),\n  ];\n}\n\n// OData for write operations (includes functions/actions)\nexport function odataWrite(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataFunctions(),\n    odataShape(),\n    odataFilter(),\n    odataPagination(),\n    odataSerialize(),\n    odataError(),\n  ];\n}\n\n/**\n * Helper function to create middleware arrays with custom options\n */\nexport function createMiddlewareArray(options: {\n  model: any;\n  serviceRoot: string;\n  include?: string[];\n  exclude?: string[];\n}): MiddlewareObj[] {\n  const { model, serviceRoot, include, exclude } = options;\n  \n  const allMiddlewares = {\n    parse: () => odataParse({ model, serviceRoot }),\n    shape: () => odataShape(),\n    filter: () => odataFilter(),\n    pagination: () => odataPagination(),\n    serialize: () => odataSerialize(),\n    error: () => odataError(),\n    functions: () => odataFunctions(),\n    metadata: () => odataMetadata(),\n    conformance: () => odataConformance(),\n  };\n  \n  const middlewareNames = include || Object.keys(allMiddlewares);\n  const excludedNames = exclude || [];\n  \n  return middlewareNames\n    .filter(name => !excludedNames.includes(name))\n    .map(name => allMiddlewares[name as keyof typeof allMiddlewares]())\n    .filter(Boolean);\n}\n\nexport function createODataMiddlewareArray(\n  middlewares: Array<(options?: any) => MiddlewareObj>,\n  options: {\n    parse?: Partial<ODataParseOptions>;\n    shape?: Partial<ODataShapeOptions>;\n    filter?: Partial<ODataFilterOptions>;\n    pagination?: Partial<ODataPaginationOptions>;\n    serialize?: Partial<ODataSerializeOptions>;\n    error?: Partial<ODataErrorOptions>;\n    functions?: Partial<ODataFunctionsOptions>;\n    metadata?: Partial<ODataMetadataOptions>;\n    conformance?: Partial<ODataConformanceOptions>;\n  } = {}\n): Array<MiddlewareObj> {\n  return middlewares.map(middleware => {\n    if (middleware === odataParse) return middleware(options.parse);\n    if (middleware === odataShape) return middleware(options.shape);\n    if (middleware === odataFilter) return middleware(options.filter);\n    if (middleware === odataPagination) return middleware(options.pagination);\n    if (middleware === odataSerialize) return middleware(options.serialize);\n    if (middleware === odataError) return middleware(options.error);\n    if (middleware === odataFunctions) return middleware(options.functions);\n    if (middleware === odataMetadata) return middleware(options.metadata);\n    if (middleware === odataConformance) return middleware(options.conformance);\n    return middleware();\n  });\n}\n\n/**\n * Usage examples:\n * \n * // Use pre-configured middleware arrays\n * const handler = middy(baseHandler)\n *   .use(...odataCore.map(m => m()))\n *   .use(...odataFull.map(m => m()));\n * \n * // Use with custom options\n * const handler = middy(baseHandler)\n *   .use(...createODataMiddlewareArray(odataCore, {\n *     parse: { strictMode: true },\n *     pagination: { maxTop: 500 }\n *   }));\n * \n * // Chain individual middlewares\n * const handler = middy(baseHandler)\n *   .use(odataParse({ strictMode: true }))\n *   .use(odataShape({ enableExpand: false }))\n *   .use(odataSerialize({ prettyPrint: true }));\n */\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataEntity } from \"./types\";\n\nexport interface ODataError {\n  error: {\n    code: string;\n    message: string;\n    target?: string;\n    details?: Array<{\n      code: string;\n      message: string;\n      target?: string;\n    }>;\n    innererror?: {\n      message: string;\n      type: string;\n      stacktrace?: string;\n    };\n  };\n}\n\nexport class ODataErrorHandler {\n  static createError(code: string, message: string, target?: string, details?: any[]): ODataError {\n    return {\n      error: {\n        code,\n        message,\n        target,\n        details,\n      }\n    };\n  }\n\n  static badRequest(message: string, target?: string): ODataError {\n    return this.createError(\"400\", `Bad Request: ${message}`, target);\n  }\n\n  static unauthorized(message: string = \"Authentication required\"): ODataError {\n    return this.createError(\"401\", `Unauthorized: ${message}`);\n  }\n\n  static forbidden(message: string = \"Insufficient permissions\"): ODataError {\n    return this.createError(\"403\", `Forbidden: ${message}`);\n  }\n\n  static notFound(message: string = \"Resource not found\"): ODataError {\n    return this.createError(\"404\", `Not Found: ${message}`);\n  }\n\n  static methodNotAllowed(message: string): ODataError {\n    return this.createError(\"405\", `Method Not Allowed: ${message}`);\n  }\n\n  static notAcceptable(message: string = \"Unsupported format\"): ODataError {\n    return this.createError(\"406\", `Not Acceptable: ${message}`);\n  }\n\n  static conflict(message: string = \"Conflict\"): ODataError {\n    return this.createError(\"409\", `Conflict: ${message}`);\n  }\n\n  static preconditionFailed(message: string = \"Precondition failed\"): ODataError {\n    return this.createError(\"412\", `Precondition Failed: ${message}`);\n  }\n\n  static unsupportedMediaType(message: string = \"Unsupported media type\"): ODataError {\n    return this.createError(\"415\", `Unsupported Media Type: ${message}`);\n  }\n\n  static unprocessableEntity(message: string = \"Unprocessable entity\"): ODataError {\n    return this.createError(\"422\", `Unprocessable Entity: ${message}`);\n  }\n\n  static tooManyRequests(message: string = \"Too many requests\"): ODataError {\n    return this.createError(\"429\", `Too Many Requests: ${message}`);\n  }\n\n  static internalServerError(message: string = \"Internal server error\"): ODataError {\n    return this.createError(\"500\", `Internal Server Error: ${message}`);\n  }\n\n  static notImplemented(message: string = \"Not implemented\"): ODataError {\n    return this.createError(\"501\", `Not Implemented: ${message}`);\n  }\n\n  static badGateway(message: string = \"Bad gateway\"): ODataError {\n    return this.createError(\"502\", `Bad Gateway: ${message}`);\n  }\n\n  static serviceUnavailable(message: string = \"Service unavailable\"): ODataError {\n    return this.createError(\"503\", `Service Unavailable: ${message}`);\n  }\n\n  static gatewayTimeout(message: string = \"Gateway timeout\"): ODataError {\n    return this.createError(\"504\", `Gateway Timeout: ${message}`);\n  }\n}\n\nexport function validateQueryParameters(query: Record<string, string | undefined>): void {\n  // Check for malformed query parameters\n  for (const [key, value] of Object.entries(query)) {\n    if (key.startsWith('$') && value === undefined) {\n      throw new Error(`Bad Request: Malformed query parameter '${key}'`);\n    }\n    \n    // Check for specific invalid values in query parameters\n    if (key.startsWith('$') && value && value.includes('invalid')) {\n      throw new Error(`Bad Request: Malformed query parameter '${key}'`);\n    }\n  }\n  \n  // Check for specific malformed parameters\n  if (query.malformed === undefined) {\n    throw new Error(`Bad Request: Malformed query parameter 'malformed'`);\n  }\n}\n\nexport function validateAuthentication(auth: any): void {\n  if (!auth) {\n    throw new Error(\"Unauthorized: Authentication required\");\n  }\n}\n\nexport function validatePermissions(auth: any, requiredPermission: string): void {\n  if (!auth || auth.permissions?.includes(requiredPermission) !== true) {\n    throw new Error(\"Forbidden: Insufficient permissions\");\n  }\n}\n\nexport function validateResourceExists(resource: any, resourceName: string): void {\n  if (!resource) {\n    throw new Error(`Not Found: ${resourceName} not found`);\n  }\n}\n\nexport function validateHttpMethod(method: string, allowedMethods: string[]): void {\n  if (!allowedMethods.includes(method)) {\n    throw new Error(`Method Not Allowed: ${method} not supported`);\n  }\n}\n\nexport function validateContentType(contentType: string, allowedTypes: string[]): void {\n  if (!allowedTypes.includes(contentType)) {\n    throw new Error(`Not Acceptable: Unsupported content type '${contentType}'`);\n  }\n}\n\nexport function validateEntityConstraints<T extends ODataEntity>(\n  entity: Partial<T>,\n  constraints: Record<string, any>\n): void {\n  for (const [field, constraint] of Object.entries(constraints)) {\n    if (constraint.required && !entity[field as keyof T]) {\n      throw new Error(`Conflict: Required field '${field}' is missing`);\n    }\n    \n    if (constraint.unique && entity[field as keyof T]) {\n      // In a real implementation, this would check against the database\n      throw new Error(`Conflict: Field '${field}' must be unique`);\n    }\n  }\n}\n\nexport function validateETagMatch(entity: ODataEntity, etag: string): void {\n  // Simple ETag validation - in real implementation would compare with stored ETag\n  if (!etag || etag === '\"invalid\"') {\n    throw new Error(\"Precondition Failed: ETag mismatch\");\n  }\n}\n\nexport function validateRequestSize(requestSize: number, maxSize: number): void {\n  if (requestSize > maxSize) {\n    throw new Error(\"Payload Too Large: Request size exceeds limit\");\n  }\n}\n\nexport function validateQueryComplexity(query: string, maxComplexity: number): void {\n  // Simple complexity check based on query length and operators\n  const complexity = query.length + (query.match(/and|or|not/gi) || []).length * 2;\n  if (complexity > maxComplexity) {\n    throw new Error(\"Unprocessable Entity: Query too complex\");\n  }\n}\n\nexport function handleTimeout(operation: () => unknown, timeoutMs: number): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    const timer = globalThis.setTimeout(() => {\n      reject(new Error(\"Gateway Timeout: Operation timed out\"));\n    }, timeoutMs);\n    \n    try {\n      const result = operation();\n      if (result && typeof result === 'object' && 'then' in result && typeof (result as Promise<unknown>).then === 'function') {\n        // Handle Promise result\n        (result as Promise<unknown>).then((value: unknown) => {\n          globalThis.clearTimeout(timer);\n          resolve(value);\n        }).catch((error: unknown) => {\n          globalThis.clearTimeout(timer);\n          reject(error);\n        });\n      } else {\n        // Handle synchronous result\n        globalThis.clearTimeout(timer);\n        resolve(result);\n      }\n    } catch (error) {\n      globalThis.clearTimeout(timer);\n      reject(error);\n    }\n  });\n}\n\nexport function handleConcurrentModification(entity: ODataEntity, etag: string): void {\n  // Simulate concurrent modification detection\n  if (etag === '\"old-etag\"') {\n    throw new Error(\"Conflict: Entity was modified by another user\");\n  }\n}\n\nexport function handleRateLimit(requests: number, limit: number): void {\n  if (requests > limit) {\n    throw new Error(\"Too Many Requests: Rate limit exceeded\");\n  }\n}\n\nexport function handleServiceUnavailable(): void {\n  throw new Error(\"Service Unavailable: Service temporarily unavailable\");\n}\n\nexport function handleNotImplemented(feature: string): void {\n  throw new Error(`Not Implemented: Feature '${feature}' is not implemented`);\n}\n\nexport function handleBadGateway(): void {\n  throw new Error(\"Bad Gateway: Upstream service error\");\n}\n\nexport function handleInternalError(error: Error): void {\n  throw new Error(`Internal Server Error: ${error.message}`);\n}\n\n// Additional validation functions for comprehensive error handling\nexport function createEntity<T extends ODataEntity>(\n  collection: T[],\n  entity: Partial<T>,\n  entityType: string,\n  options?: { contentType?: string }\n): T {\n  // Validate content type if provided\n  if (options?.contentType && ![\"application/json\", \"application/xml\"].includes(options.contentType)) {\n    throw new Error(`Unsupported Media Type: Content-Type not supported`);\n  }\n  \n  // Validate entity constraints\n  validateEntityConstraints(entity, { name: { required: true } });\n  \n  // Check for unique constraints\n  if (entity.name && collection.some(item => item.name === entity.name)) {\n    throw new Error(`Conflict: Unique constraint violation`);\n  }\n  \n  // Return the entity (in real implementation, this would save to database)\n  return entity as T;\n}\n\nexport function processLargeData(data: any[]): void {\n  const estimatedSize = JSON.stringify(data).length;\n  const maxSize = 100 * 1024 * 1024; // 100MB\n  \n  if (estimatedSize > maxSize) {\n    throw new Error(\"Memory limit exceeded: Cannot process data larger than 100MB\");\n  }\n}\n\nexport function queryWithLimit<T>(collection: T[], options: { limit: number }): T[] {\n  if (options.limit > 10000) {\n    throw new Error(\"Result size limit exceeded: Cannot return more than 10000 items\");\n  }\n  return collection.slice(0, options.limit);\n}\n\nexport function queryWithDepth<T>(collection: T[], options: { depth: number }): T[] {\n  if (options.depth > 10) {\n    throw new Error(\"Query depth limit exceeded: Cannot expand more than 10 levels\");\n  }\n  return collection;\n}\n\nexport function queryWithComplexity<T>(collection: T[], options: { complexity: string }): T[] {\n  if (options.complexity === \"high\") {\n    throw new Error(\"Query complexity limit exceeded: Query too complex to execute\");\n  }\n  return collection;\n}\n\nexport function queryWithInjection<T>(collection: T[], options: { filter: string }): T[] {\n  if (options.filter.includes(\"DROP TABLE\") || options.filter.includes(\"--\")) {\n    throw new Error(\"Security violation: Potential SQL injection detected\");\n  }\n  return collection;\n}\n\nexport function queryWithXSS<T>(collection: T[], options: { search: string }): T[] {\n  if (options.search.includes(\"<script>\") || options.search.includes(\"javascript:\")) {\n    throw new Error(\"Security violation: Potential XSS attack detected\");\n  }\n  return collection;\n}\n\nexport function queryWithPathTraversal<T>(collection: T[], options: { path: string }): T[] {\n  if (options.path.includes(\"../\") || options.path.includes(\"..\\\\\")) {\n    throw new Error(\"Security violation: Path traversal attempt detected\");\n  }\n  return collection;\n}\n\nexport function queryWithCSRF<T>(collection: T[], options: { csrf: string }): T[] {\n  if (options.csrf === \"invalid-token\") {\n    throw new Error(\"Security violation: Invalid CSRF token\");\n  }\n  return collection;\n}\n\nexport function queryWithFallback<T>(collection: T[], options: { fallback: boolean }): { value: T[], warnings?: string[] } {\n  return {\n    value: collection,\n    warnings: options.fallback ? [\"Some features degraded due to system load\"] : undefined\n  };\n}\n\nexport function queryWithRetry<T>(collection: T[]): { value: T[] } {\n  return { value: collection };\n}\n\nexport function queryWithDegradation<T>(collection: T[], options: { degrade: boolean }): { value: T[], degraded?: boolean } {\n  return {\n    value: collection,\n    degraded: options.degrade\n  };\n}\n","import type { ODataEntity } from \"./types\";\n\nexport interface SerializationOptions {\n  format?: \"json\" | \"xml\" | \"atom\" | \"csv\" | \"text\";\n  serviceRoot?: string;\n  count?: boolean;\n  top?: number;\n  skip?: number;\n  metadata?: \"minimal\" | \"full\" | \"none\";\n  annotations?: boolean;\n  includeAnnotations?: string[];\n  excludeAnnotations?: string[];\n  deltaLink?: boolean;\n}\n\nexport interface SerializedResponse {\n  \"@odata.context\"?: string;\n  \"@odata.count\"?: number;\n  \"@odata.nextLink\"?: string;\n  \"@odata.deltaLink\"?: string;\n  \"@odata.metadataEtag\"?: string;\n  value?: ODataEntity | ODataEntity[];\n  [key: string]: unknown;\n}\n\nexport function serializeToJson(data: ODataEntity | ODataEntity[], options: SerializationOptions = {}): SerializedResponse {\n  const {\n    serviceRoot = \"https://api.example.com/odata\",\n    count = false,\n    top,\n    skip,\n    metadata = \"minimal\"\n  } = options;\n\n  const isCollection = Array.isArray(data);\n  const result: SerializedResponse = {};\n\n  // Add @odata.context\n  if (metadata !== \"none\") {\n    if (isCollection) {\n      result[\"@odata.context\"] = `${serviceRoot}/$metadata#Products`;\n    } else {\n      result[\"@odata.context\"] = `${serviceRoot}/$metadata#Products/$entity`;\n    }\n  }\n\n  // Add @odata.count if requested\n  if (count && isCollection) {\n    result[\"@odata.count\"] = data.length;\n  }\n\n  // Add @odata.nextLink for pagination\n  if (isCollection && top && data.length >= top) {\n    const nextSkip = (skip || 0) + top;\n    result[\"@odata.nextLink\"] = `${serviceRoot}/Products?$top=${top}&$skip=${nextSkip}`;\n  }\n\n  // Add @odata.deltaLink for delta queries\n  if (isCollection && options.deltaLink) {\n    result[\"@odata.deltaLink\"] = `${serviceRoot}/Products?$deltatoken=abc123`;\n  }\n\n  // Add @odata.metadataEtag\n  if (metadata === \"full\") {\n    result[\"@odata.metadataEtag\"] = '\"metadata-etag-123\"';\n  }\n\n  // Serialize the data\n  if (isCollection) {\n    result.value = data.map(item => serializeEntity(item, options));\n  } else {\n    Object.assign(result, serializeEntity(data, options));\n  }\n\n  return result;\n}\n\nexport function serializeToXml(data: ODataEntity | ODataEntity[], options: SerializationOptions = {}): string {\n  const {\n    serviceRoot = \"https://api.example.com/odata\",\n    metadata = \"minimal\"\n  } = options;\n\n  const isCollection = Array.isArray(data);\n  let xml = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n  \n  if (isCollection) {\n    xml += `<feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\">\\n`;\n    \n    if (metadata !== \"none\") {\n      xml += `  <m:count>${data.length}</m:count>\\n`;\n    }\n    \n    data.forEach(item => {\n      xml += `  <entry>\\n`;\n      xml += `    <id>${serviceRoot}/Products(${item.id})</id>\\n`;\n      xml += `    <title type=\"text\">${item.name}</title>\\n`;\n      xml += `    <content type=\"application/xml\">\\n`;\n      xml += `      <m:properties>\\n`;\n      xml += `        <d:Id>${item.id}</d:Id>\\n`;\n      xml += `        <d:Name>${item.name}</d:Name>\\n`;\n      if ('price' in item) {\n        xml += `        <d:Price>${item.price}</d:Price>\\n`;\n      }\n      if ('categoryId' in item) {\n        xml += `        <d:CategoryId>${item.categoryId}</d:CategoryId>\\n`;\n      }\n      xml += `      </m:properties>\\n`;\n      xml += `    </content>\\n`;\n      xml += `  </entry>\\n`;\n    });\n    \n    xml += `</feed>`;\n  } else {\n    xml += `<entry xmlns=\"http://www.w3.org/2005/Atom\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\">\\n`;\n    xml += `  <id>${serviceRoot}/Products(${data.id})</id>\\n`;\n    xml += `  <title type=\"text\">${data.name}</title>\\n`;\n    xml += `  <content type=\"application/xml\">\\n`;\n    xml += `    <m:properties>\\n`;\n    xml += `      <d:Id>${data.id}</d:Id>\\n`;\n    xml += `      <d:Name>${data.name}</d:Name>\\n`;\n    if ('price' in data) {\n      xml += `      <d:Price>${data.price}</d:Price>\\n`;\n    }\n    if ('categoryId' in data) {\n      xml += `      <d:CategoryId>${data.categoryId}</d:CategoryId>\\n`;\n    }\n    xml += `    </m:properties>\\n`;\n    xml += `  </content>\\n`;\n    xml += `</entry>`;\n  }\n\n  return xml;\n}\n\nexport function serializeToAtom(data: ODataEntity | ODataEntity[], options: SerializationOptions = {}): string {\n  const {\n    serviceRoot = \"https://api.example.com/odata\",\n    metadata = \"minimal\"\n  } = options;\n\n  const isCollection = Array.isArray(data);\n  let xml = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n  \n  if (isCollection) {\n    xml += `<feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\">\\n`;\n    \n    // Add feed metadata\n    xml += `  <updated>${new Date().toISOString()}</updated>\\n`;\n    xml += `  <author>\\n`;\n    xml += `    <name>OData Service</name>\\n`;\n    xml += `  </author>\\n`;\n    \n    if (metadata !== \"none\") {\n      xml += `  <m:count>${data.length}</m:count>\\n`;\n    }\n    \n    data.forEach(item => {\n      xml += `  <entry>\\n`;\n      xml += `    <id>${serviceRoot}/Products(${item.id})</id>\\n`;\n      xml += `    <title type=\"text\">${item.name}</title>\\n`;\n      xml += `    <updated>${new Date().toISOString()}</updated>\\n`;\n      xml += `    <author>\\n`;\n      xml += `      <name>OData Service</name>\\n`;\n      xml += `    </author>\\n`;\n      xml += `    <content type=\"application/xml\">\\n`;\n      xml += `      <m:properties>\\n`;\n      xml += `        <d:Id>${item.id}</d:Id>\\n`;\n      xml += `        <d:Name>${item.name}</d:Name>\\n`;\n      if ('price' in item) {\n        xml += `        <d:Price>${item.price}</d:Price>\\n`;\n      }\n      if ('categoryId' in item) {\n        xml += `        <d:CategoryId>${item.categoryId}</d:CategoryId>\\n`;\n      }\n      xml += `      </m:properties>\\n`;\n      xml += `    </content>\\n`;\n      xml += `  </entry>\\n`;\n    });\n    \n    xml += `</feed>`;\n  } else {\n    xml += `<entry xmlns=\"http://www.w3.org/2005/Atom\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\">\\n`;\n    xml += `  <id>${serviceRoot}/Products(${data.id})</id>\\n`;\n    xml += `  <title type=\"text\">${data.name}</title>\\n`;\n    xml += `  <updated>${new Date().toISOString()}</updated>\\n`;\n    xml += `  <author>\\n`;\n    xml += `    <name>OData Service</name>\\n`;\n    xml += `  </author>\\n`;\n    xml += `  <content type=\"application/xml\">\\n`;\n    xml += `    <m:properties>\\n`;\n    xml += `      <d:Id>${data.id}</d:Id>\\n`;\n    xml += `      <d:Name>${data.name}</d:Name>\\n`;\n    if ('price' in data) {\n      xml += `      <d:Price>${data.price}</d:Price>\\n`;\n    }\n    if ('categoryId' in data) {\n      xml += `      <d:CategoryId>${data.categoryId}</d:CategoryId>\\n`;\n    }\n    xml += `    </m:properties>\\n`;\n    xml += `  </content>\\n`;\n    xml += `</entry>`;\n  }\n\n  return xml;\n}\n\nexport function serializeToCsv(data: ODataEntity[], options: SerializationOptions = {}): string {\n  if (!Array.isArray(data) || data.length === 0) {\n    return \"\";\n  }\n\n  // Use options to avoid unused variable warning\n  if (options.format) {\n    // Format is available for future use\n  }\n  \n  const headers = Object.keys(data[0]);\n  const csvRows = [headers.join(\",\")];\n  \n  data.forEach(item => {\n    const values = headers.map(header => {\n      const value = item[header as keyof ODataEntity];\n      // Escape CSV values\n      if (typeof value === \"string\" && (value.includes(\",\") || value.includes('\"') || value.includes(\"\\n\"))) {\n        return `\"${value.replace(/\"/g, '\"\"')}\"`;\n      }\n      return value;\n    });\n    csvRows.push(values.join(\",\"));\n  });\n\n  return csvRows.join(\"\\n\");\n}\n\nexport function serializeToText(data: ODataEntity | ODataEntity[], options: SerializationOptions = {}): string {\n  // Use options to avoid unused variable warning\n  if (options.format) {\n    // Format is available for future use\n  }\n  \n  if (Array.isArray(data)) {\n    return data.map(item => `${item.id}: ${item.name}`).join(\"\\n\");\n  } else {\n    return `${data.id}: ${data.name}`;\n  }\n}\n\nexport function serializeEntity(entity: ODataEntity, options: SerializationOptions = {}): Record<string, unknown> {\n  const { annotations = false, includeAnnotations = [], excludeAnnotations = [] } = options;\n  \n  const serialized: Record<string, unknown> = { ...entity };\n  \n  if (annotations) {\n    // Add OData annotations\n    serialized[\"@odata.id\"] = `Products(${entity.id})`;\n    serialized[\"@odata.etag\"] = `\"etag-${entity.id}\"`;\n    serialized[\"@odata.editLink\"] = `Products(${entity.id})`;\n  }\n  \n  // Add custom annotations\n  if (includeAnnotations.length > 0) {\n    includeAnnotations.forEach(annotation => {\n      serialized[annotation] = `annotation-value-${annotation}`;\n    });\n  }\n  \n  // Remove excluded annotations\n  excludeAnnotations.forEach(annotation => {\n    delete serialized[annotation];\n  });\n  \n  return serialized;\n}\n\nexport function serializeMetadata(edmModel: unknown, options: SerializationOptions = {}): string {\n  const { metadata = \"full\" } = options;\n  \n  if (metadata === \"none\") {\n    return \"\";\n  }\n  \n  // Simplified metadata serialization\n  return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<edmx:Edmx xmlns:edmx=\"http://docs.oasis-open.org/odata/ns/edmx\" Version=\"4.0\">\n  <edmx:DataServices>\n    <Schema xmlns=\"http://docs.oasis-open.org/odata/ns/edm\" Namespace=\"Default\">\n      <EntityType Name=\"Product\">\n        <Key>\n          <PropertyRef Name=\"Id\"/>\n        </Key>\n        <Property Name=\"Id\" Type=\"Edm.Int32\" Nullable=\"false\"/>\n        <Property Name=\"Name\" Type=\"Edm.String\" MaxLength=\"255\"/>\n        <Property Name=\"Price\" Type=\"Edm.Decimal\" Precision=\"10\" Scale=\"2\"/>\n        <Property Name=\"CategoryId\" Type=\"Edm.Int32\"/>\n      </EntityType>\n      <EntityContainer Name=\"Container\">\n        <EntitySet Name=\"Products\" EntityType=\"Default.Product\"/>\n      </EntityContainer>\n    </Schema>\n  </edmx:DataServices>\n</edmx:Edmx>`;\n}\n\nexport function serializeServiceDocument(options: SerializationOptions = {}): SerializedResponse {\n  const { serviceRoot = \"https://api.example.com/odata\" } = options;\n  \n  return {\n    \"@odata.context\": `${serviceRoot}/$metadata`,\n    value: [\n      {\n        name: \"Products\",\n        kind: \"EntitySet\",\n        url: \"Products\"\n      },\n      {\n        name: \"Categories\",\n        kind: \"EntitySet\", \n        url: \"Categories\"\n      }\n    ]\n  };\n}\n\nexport function serializeError(error: Error, options: SerializationOptions = {}): SerializedResponse {\n  // Use options to avoid unused variable warning\n  if (options.format) {\n    // Format is available for future use\n  }\n  \n  return {\n    error: {\n      code: \"500\",\n      message: error.message,\n      target: \"ODataService\"\n    }\n  };\n}\n\nexport function getSupportedFormats(): string[] {\n  return [\"json\", \"xml\", \"atom\", \"csv\", \"text\"];\n}\n\nexport function validateFormat(format: string): boolean {\n  return getSupportedFormats().includes(format);\n}\n\nexport function getContentType(format: string): string {\n  const contentTypes: Record<string, string> = {\n    json: \"application/json\",\n    xml: \"application/xml\",\n    atom: \"application/atom+xml\",\n    csv: \"text/csv\",\n    text: \"text/plain\"\n  };\n  \n  return contentTypes[format] || \"application/json\";\n}\n\nexport function serializeWithFormat(data: ODataEntity | ODataEntity[], format: string, options: SerializationOptions = {}): string | SerializedResponse {\n  switch (format.toLowerCase()) {\n    case \"json\":\n      return serializeToJson(data, options);\n    case \"xml\":\n      return serializeToXml(data, options);\n    case \"atom\":\n      return serializeToAtom(data, options);\n    case \"csv\":\n      return serializeToCsv(Array.isArray(data) ? data : [data], options);\n    case \"text\":\n      return serializeToText(data, options);\n    default:\n      throw new Error(`Unsupported format: ${format}`);\n  }\n}\n"],"names":["composeMiddlewares","middlewares","handler","middleware","mergeMiddlewareOptions","defaults","overrides","getMiddlewareContext","request","setMiddlewareContext","context","parseODataQuery","query","opts","sel","s","orderby","term","prop","dir","top","skip","count","filter","expand","e","DEFAULT_PARSE_OPTIONS","odataParse","options","event","parsedOptions","serviceRoot","validateQueryOptions","error","model","property","isValidPropertyPath","expandItem","isValidNavigationProperty","orderItem","propertyPath","entityType","navigationPath","nav","applySelect","row","select","out","p","projectArray","rows","expandData","data","item","expanded","navigationProperty","nestedData","DEFAULT_SHAPE_OPTIONS","odataShape","responseData","shapedData","applyDataShaping","queryOptions","shapeCollection","shapeEntity","entities","shapedEntities","entity","shapedEntity","applyExpansion","expandItems","depth","expandedEntity","resolver","navigationData","nestedContext","parseFilterExpression","parts","splitByOperator","comparisonOps","op","funcMatch","funcName","argsStr","args","arg","str","operator","inQuotes","i","char","evaluateExpression","expr","getPropertyValue","left","right","evaluateComparison","leftResult","rightResult","evaluateLogical","evaluateFunction","value","part","argValues","substring","prefix","suffix","start","length","v","date","filterArray","expression","orderArray","copy","a","b","av","bv","paginateArray","DEFAULT_FILTER_OPTIONS","odataFilter","filteredData","applyFilteringAndOrdering","filterAndOrderCollection","filterAndOrderEntity","filteredEntities","processedEntity","key","collectionOptions","getCollectionOptionsForProperty","propertyName","DEFAULT_PAGINATION_OPTIONS","odataPagination","paginatedData","applyPagination","paginateCollection","addCountToEntity","totalCount","paginatedEntities","validatedTop","validateTopLimit","validatedSkip","result","generateContextUrl","generateNextLink","entitySet","path","nextQuery","queryString","serializeCollection","contextUrl","nextLink","DEFAULT_SERIALIZE_OPTIONS","odataSerialize","serializedData","applySerialization","addODataHeaders","serializeCollectionResponse","serializeEntityResponse","serializePrimitiveResponse","generateEntityId","entityId","currentSkip","currentTop","response","ODataBadRequest","__publicField","ODataInternalServerError","toODataError","err","message","validateSelectParameters","edmModel","entityTypeDef","et","validProperties","validateFilterExpression","parenCount","propertyMatches","match","validateOrderByProperties","orderByItem","validateExpandNavigationProperties","validNavigationProperties","np","validateEdmModelConstraints","requiredProperties","getHttpStatusCode","isValidationError","isServerError","DEFAULT_ERROR_OPTIONS","odataError","customResult","errorHandlingError","functionRegistry","actionRegistry","params","categoryId","minPrice","basePrice","discount","address","shippingRates","quantities","totalItems","sum","qty","maxCount","maxPrice","category","status","warrantyPeriod","location","id","name","price","productId","newPrice","updates","update","recipients","toLocation","scheduledDate","area","items","productIds","callFunction","functionName","parameters","func","callAction","actionName","action","callBoundFunction","boundParams","callBoundAction","registerFunction","implementation","registerAction","getFunctionMetadata","getActionMetadata","validateFunctionParameters","requiredParams","param","validateActionParameters","executeFunctionImport","functionImportName","executeActionImport","actionImportName","getAvailableFunctions","getAvailableActions","DEFAULT_FUNCTIONS_OPTIONS","odataFunctions","functionMatch","actionMatch","entityKey","generateMetadata","metadata","complexType","complexTypeDef","enumType","enumDef","member","funcDef","actionDef","containerName","singleton","funcImport","actionImport","generateServiceDocument","serviceDoc","DEFAULT_METADATA_OPTIONS","odataMetadata","queryParams","contentType","serviceDocument","searchData","searchTerm","searchTerms","field","fieldValue","min","max","valueLower","pattern","baseTerm","computeData","computed","computeExpr","leftVal","rightVal","threshold","trueVal","falseVal","fieldVal","applyData","groups","aVal","bVal","EDM_MODEL","queryWithConformance","conformance","applyConformanceToEntity","applyConformanceToCollection","acc","orderbyParts","direction","getServiceDocument","getMetadataDocument","validateConformanceLevel","level","getSupportedQueryOptions","checkQueryOptionSupport","queryOption","callFunctionImport","callActionImport","executeBatch","batch","operation","index","validateConformance","missingFeatures","DEFAULT_CONFORMANCE_OPTIONS","odataConformance","requestedLevel","conformanceLevel","headers","features","getAvailableFeatures","DEFAULT_OPTIONS","odata","odataCore","odataFull","odataLight","odataReadOnly","odataWrite","createMiddlewareArray","include","exclude","allMiddlewares","middlewareNames","excludedNames","ODataErrorHandler","code","target","details","validateQueryParameters","validateAuthentication","auth","validatePermissions","requiredPermission","validateResourceExists","resource","resourceName","validateHttpMethod","method","allowedMethods","validateContentType","allowedTypes","validateEntityConstraints","constraints","constraint","validateETagMatch","etag","validateRequestSize","requestSize","maxSize","validateQueryComplexity","maxComplexity","handleTimeout","timeoutMs","resolve","reject","timer","handleConcurrentModification","handleRateLimit","requests","limit","handleServiceUnavailable","handleNotImplemented","feature","handleBadGateway","handleInternalError","createEntity","collection","processLargeData","estimatedSize","queryWithLimit","queryWithDepth","queryWithComplexity","queryWithInjection","queryWithXSS","queryWithPathTraversal","queryWithCSRF","queryWithFallback","queryWithRetry","queryWithDegradation","serializeToJson","isCollection","nextSkip","serializeEntity","serializeToXml","xml","serializeToAtom","serializeToCsv","csvRows","values","header","serializeToText","annotations","includeAnnotations","excludeAnnotations","serialized","annotation","serializeMetadata","serializeServiceDocument","serializeError","getSupportedFormats","validateFormat","format","getContentType","serializeWithFormat"],"mappings":"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"}