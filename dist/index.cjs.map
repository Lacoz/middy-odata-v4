{"version":3,"file":"index.cjs","sources":["../src/middleware/compose.ts","../src/core/parse.ts","../src/middleware/parse.ts","../src/core/shape.ts","../src/middleware/shape.ts","../src/core/filter-order.ts","../src/middleware/filter.ts","../src/middleware/pagination.ts","../src/core/serialize.ts","../src/middleware/serialize.ts","../src/core/errors.ts","../src/middleware/error.ts","../src/core/functions-actions.ts","../src/middleware/functions.ts","../src/core/metadata.ts","../src/middleware/metadata.ts","../src/core/search-compute-apply.ts","../__tests__/fixtures/edm.ts","../src/core/conformance-levels.ts","../src/middleware/conformance.ts","../src/middleware/odata.ts","../src/middleware/convenience.ts","../src/core/error-handling.ts","../src/core/format-serialization.ts"],"sourcesContent":["import type { MiddlewareObj } from \"@middy/core\";\n// Removed unused imports\n\ndeclare const console: any;\n\n\n/**\n * Composes multiple middlewares into a single middleware following Middy's onion pattern\n * @param middlewares Array of middlewares to compose\n * @returns Single middleware that executes all middlewares in proper order\n */\nexport function composeMiddlewares(...middlewares: MiddlewareObj[]): MiddlewareObj {\n  return {\n    before: async (handler) => {\n      // Execute before phases in order\n      for (const middleware of middlewares) {\n        if (middleware.before) {\n          await middleware.before(handler);\n        }\n      }\n    },\n    after: async (handler) => {\n      // Execute after phases in reverse order\n      for (const middleware of middlewares.slice().reverse()) {\n        if (middleware.after) {\n          await middleware.after(handler);\n        }\n      }\n    },\n    onError: async (handler) => {\n      // Execute error handlers in reverse order\n      for (const middleware of middlewares.slice().reverse()) {\n        if (middleware.onError) {\n          await middleware.onError(handler);\n        }\n      }\n    },\n  };\n}\n\n/**\n * Validates middleware execution order and dependencies\n * @param middlewares Array of middlewares to validate\n * @throws Error if middleware order is invalid\n */\nexport function validateMiddlewareOrder(middlewares: MiddlewareObj[]): void {\n  // This could be expanded to check for specific middleware dependencies\n  // For now, we'll just ensure we have at least one middleware\n  if (middlewares.length === 0) {\n    throw new Error(\"At least one middleware is required\");\n  }\n}\n\n/**\n * Creates a middleware that logs execution for debugging\n * @param name Name of the middleware for logging\n * @returns Middleware with logging\n */\nexport function createLoggingMiddleware(name: string): MiddlewareObj {\n  return {\n    before: async (handler) => {\n      const startTime = Date.now();\n      handler.internal = handler.internal || {};\n      (handler.internal as any)[`${name}_start`] = startTime;\n      console.log(`[OData] ${name} middleware: before phase started`);\n    },\n    after: async (handler) => {\n      const startTime = (handler.internal as any)?.[`${name}_start`] || Date.now();\n      const duration = Date.now() - startTime;\n      console.log(`[OData] ${name} middleware: after phase completed in ${duration}ms`);\n    },\n    onError: async (handler) => {\n      const startTime = (handler.internal as any)?.[`${name}_start`] || Date.now();\n      const duration = Date.now() - startTime;\n      console.error(`[OData] ${name} middleware: error phase in ${duration}ms`, handler.error);\n    },\n  };\n}\n\n/**\n * Helper to merge middleware options with defaults\n * @param defaults Default options\n * @param overrides Override options\n * @returns Merged options\n */\nexport function mergeMiddlewareOptions<T extends Record<string, unknown>>(\n  defaults: T,\n  overrides: Partial<T> = {}\n): T {\n  return { ...defaults, ...overrides };\n}\n\n/**\n * Helper to create middleware context from request\n * @param request Middy request object\n * @returns OData middleware context\n */\nexport function getMiddlewareContext(request: any): any {\n  return request.internal?.odata || {};\n}\n\n/**\n * Helper to set middleware context on request\n * @param request Middy request object\n * @param context OData middleware context\n */\nexport function setMiddlewareContext(request: any, context: any): void {\n  request.internal = request.internal || {};\n  request.internal.odata = context;\n}\n","import type { ODataQueryOptions } from \"./types\";\n\nexport function parseODataQuery(query: Record<string, string | undefined>): ODataQueryOptions {\n  const opts: ODataQueryOptions = {};\n  const sel = query[\"$select\"];\n  if (sel) opts.select = sel.split(\",\").map((s) => s.trim()).filter(Boolean);\n  const orderby = query[\"$orderby\"];\n  if (orderby) {\n    opts.orderby = orderby.split(\",\").map((term) => {\n      const [prop, dir] = term.trim().split(/\\s+/);\n      return { property: prop, direction: (dir?.toLowerCase() === \"desc\" ? \"desc\" : \"asc\") };\n    });\n  }\n  const top = query[\"$top\"];\n  if (top !== undefined) opts.top = Math.max(0, Number(top));\n  const skip = query[\"$skip\"];\n  if (skip !== undefined) opts.skip = Math.max(0, Number(skip));\n  const count = query[\"$count\"];\n  if (count !== undefined) opts.count = String(count).toLowerCase() === \"true\";\n  const filter = query[\"$filter\"];\n  if (filter) opts.filter = filter;\n  const expand = query[\"$expand\"];\n  if (expand) {\n    opts.expand = expand.split(\",\").map((e) => ({ path: e.trim() }));\n  }\n  return opts;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataParseOptions, ODataMiddlewareContext } from \"./types\";\nimport type { EdmModel } from \"../core/types\";\nimport { parseODataQuery } from \"../core/parse\";\nimport { mergeMiddlewareOptions, setMiddlewareContext } from \"./compose\";\n\nconst DEFAULT_PARSE_OPTIONS: ODataParseOptions = {\n  model: {} as any, // Will be provided by user\n  serviceRoot: \"\",\n  validateAgainstModel: true,\n  strictMode: false,\n};\n\n/**\n * OData Parse Middleware\n * \n * Responsibilities:\n * - Parse query parameters from API Gateway events\n * - Validate query options against EDM model\n * - Set up initial OData context\n * - Handle service root resolution\n */\nexport function odataParse(options: Partial<ODataParseOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_PARSE_OPTIONS, options);\n\n  return {\n    before: async (request: any) => {\n      try {\n        const event = request.event ?? {};\n        \n        // Extract query parameters from different API Gateway event formats\n        const query: Record<string, string> = event.rawQueryString\n          ? Object.fromEntries(new URLSearchParams(event.rawQueryString))\n          : (event.queryStringParameters || {});\n\n        // Parse OData query options\n        const parsedOptions = parseODataQuery(query);\n\n        // Resolve service root\n        const serviceRoot = typeof opts.serviceRoot === \"function\" \n          ? opts.serviceRoot(event) \n          : opts.serviceRoot;\n\n        // Create OData context\n        const context: ODataMiddlewareContext = {\n          model: opts.model as EdmModel,\n          serviceRoot,\n          entitySet: undefined, // Will be set by route handler or other middleware\n          options: parsedOptions,\n          metadata: {\n            middlewareStack: [\"parse\"],\n            executionTime: Date.now(),\n          },\n        };\n\n        // Validate against EDM model if enabled\n        if (opts.validateAgainstModel) {\n          validateQueryOptions(context);\n        }\n\n        // Set context on request\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If parsing fails, we should still set up basic context\n        // The error middleware will handle the actual error\n        const context: ODataMiddlewareContext = {\n          model: opts.model as EdmModel,\n          serviceRoot: typeof opts.serviceRoot === \"function\" \n            ? opts.serviceRoot(request.event) \n            : opts.serviceRoot,\n          entitySet: undefined,\n          options: {},\n          error: error as Error,\n          metadata: {\n            middlewareStack: [\"parse\"],\n            executionTime: Date.now(),\n          },\n        };\n        setMiddlewareContext(request, context);\n        throw error; // Re-throw to let error middleware handle it\n      }\n    },\n  };\n}\n\n/**\n * Validates parsed query options against the EDM model\n * @param context OData middleware context\n * @throws Error if validation fails\n */\nfunction validateQueryOptions(context: ODataMiddlewareContext): void {\n  const { model, options } = context;\n\n  // Validate $select properties exist in model\n  if (options.select) {\n    for (const property of options.select) {\n      if (!isValidPropertyPath(property, model)) {\n        throw new Error(`Invalid property in $select: ${property}`);\n      }\n    }\n  }\n\n  // Validate $expand navigation properties exist in model\n  if (options.expand) {\n    for (const expandItem of options.expand) {\n      if (!isValidNavigationProperty(expandItem.path, model)) {\n        throw new Error(`Invalid navigation property in $expand: ${expandItem.path}`);\n      }\n    }\n  }\n\n  // Validate $orderby properties exist in model\n  if (options.orderby) {\n    for (const orderItem of options.orderby) {\n      if (!isValidPropertyPath(orderItem.property, model)) {\n        throw new Error(`Invalid property in $orderby: ${orderItem.property}`);\n      }\n    }\n  }\n}\n\n/**\n * Checks if a property path is valid in the EDM model\n * @param propertyPath Property path to validate\n * @param model EDM model\n * @returns True if valid\n */\nfunction isValidPropertyPath(propertyPath: string, model: any): boolean {\n  // Simple validation - in a real implementation, this would be more comprehensive\n  // For now, we'll just check if the model has entity types\n  if (!model.entityTypes || model.entityTypes.length === 0) {\n    return true; // Can't validate without entity types\n  }\n\n  // Check if property exists in any entity type\n  return model.entityTypes.some((entityType: any) => \n    entityType.properties?.some((prop: any) => prop.name === propertyPath)\n  );\n}\n\n/**\n * Checks if a navigation property is valid in the EDM model\n * @param navigationPath Navigation property path to validate\n * @param model EDM model\n * @returns True if valid\n */\nfunction isValidNavigationProperty(navigationPath: string, model: any): boolean {\n  // Simple validation - in a real implementation, this would be more comprehensive\n  if (!model.entityTypes || model.entityTypes.length === 0) {\n    return true; // Can't validate without entity types\n  }\n\n  // Check if navigation property exists in any entity type\n  return model.entityTypes.some((entityType: any) => \n    entityType.navigation?.some((nav: any) => nav.name === navigationPath)\n  );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataEntity, ODataQueryOptions } from \"./types\";\n\nexport function applySelect<T extends ODataEntity>(row: T, select?: string[]): Partial<T> {\n  if (!select || select.length === 0) return { ...row };\n  const out: Record<string, unknown> = {};\n  for (const p of select) if (p in row) out[p] = (row as any)[p];\n  return out as Partial<T>;\n}\n\nexport function projectArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): Partial<T>[] {\n  return rows.map((r) => applySelect(r, options.select));\n}\n\n// Expand navigation properties\nexport function expandData<T extends Record<string, any>>(\n  data: T | T[],\n  options: ODataQueryOptions\n): T | T[] {\n  if (!options.expand || options.expand.length === 0) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map(item => expandData(item, options) as T);\n  }\n\n  const expanded = { ...data } as any;\n  \n  for (const expandItem of options.expand) {\n    const navigationProperty = expandItem.path;\n    \n    // Simple expansion - in a real implementation, this would resolve navigation properties\n    // For now, we'll just ensure the property exists\n    if (navigationProperty && !(navigationProperty in expanded)) {\n      // Create a placeholder for the expanded property\n      expanded[navigationProperty] = null;\n    }\n    \n    // Handle nested query options in expansion\n    if (expandItem.options) {\n      const nestedData = expanded[navigationProperty];\n      if (nestedData) {\n        expanded[navigationProperty] = expandData(nestedData, expandItem.options);\n      }\n    }\n  }\n  \n  return expanded as T;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataShapeOptions, ODataMiddlewareContext } from \"./types\";\nimport { applySelect } from \"../core/shape\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\n\nconst DEFAULT_SHAPE_OPTIONS: ODataShapeOptions = {\n  enableExpand: true,\n  maxExpandDepth: 3,\n  expandResolvers: {},\n};\n\n/**\n * OData Shape Middleware\n * \n * Responsibilities:\n * - Apply $select projection to response data\n * - Handle $expand navigation property resolution\n * - Transform response data according to OData query options\n * - Manage expand depth and prevent infinite loops\n */\nexport function odataShape(options: Partial<ODataShapeOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_SHAPE_OPTIONS, options);\n\n  return {\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        if (!context || !context.options) {\n          return; // No OData context, skip shaping\n        }\n\n        // Get response data\n        let responseData = request.response?.body;\n        if (typeof responseData === 'string') {\n          try {\n            responseData = JSON.parse(responseData);\n          } catch {\n            // If parsing fails, skip shaping\n            return;\n          }\n        }\n\n        if (!responseData) {\n          return; // No data to shape\n        }\n\n        // Apply data shaping\n        const shapedData = await applyDataShaping(responseData, context, opts);\n\n        // Update response\n        if (request.response) {\n          request.response.body = JSON.stringify(shapedData);\n        } else {\n          request.response = {\n            statusCode: 200,\n            body: JSON.stringify(shapedData),\n          };\n        }\n\n        // Update context with shaped data\n        context.data = shapedData;\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If shaping fails, log error but don't break the response\n        console.error('[OData Shape] Error applying data shaping:', error);\n        // Continue with original response\n      }\n    },\n  };\n}\n\n/**\n * Applies data shaping based on OData query options\n * @param data Response data to shape\n * @param context OData middleware context\n * @param options Shape options\n * @returns Shaped data\n */\nasync function applyDataShaping(\n  data: unknown,\n  context: ODataMiddlewareContext,\n  options: ODataShapeOptions\n): Promise<unknown> {\n  const { options: queryOptions } = context;\n\n  // Handle collection responses\n  if (Array.isArray(data)) {\n    return await shapeCollection(data, queryOptions, options, context);\n  }\n\n  // Handle single entity responses\n  if (data && typeof data === 'object') {\n    return await shapeEntity(data as Record<string, unknown>, queryOptions, options, context);\n  }\n\n  // Return primitive values as-is\n  return data;\n}\n\n/**\n * Shapes a collection of entities\n * @param entities Array of entities\n * @param queryOptions OData query options\n * @param options Shape options\n * @param context OData middleware context\n * @returns Shaped collection\n */\nasync function shapeCollection(\n  entities: unknown[],\n  queryOptions: any,\n  options: ODataShapeOptions,\n  context: ODataMiddlewareContext\n): Promise<unknown[]> {\n  const shapedEntities: unknown[] = [];\n\n  for (const entity of entities) {\n    if (entity && typeof entity === 'object') {\n      const shapedEntity = await shapeEntity(\n        entity as Record<string, unknown>,\n        queryOptions,\n        options,\n        context\n      );\n      shapedEntities.push(shapedEntity);\n    } else {\n      shapedEntities.push(entity);\n    }\n  }\n\n  return shapedEntities;\n}\n\n/**\n * Shapes a single entity\n * @param entity Entity to shape\n * @param queryOptions OData query options\n * @param options Shape options\n * @param context OData middleware context\n * @returns Shaped entity\n */\nasync function shapeEntity(\n  entity: Record<string, unknown>,\n  queryOptions: any,\n  options: ODataShapeOptions,\n  context: ODataMiddlewareContext\n): Promise<Record<string, unknown>> {\n  let shapedEntity = { ...entity };\n\n  // Apply $select projection\n  if (queryOptions.select && queryOptions.select.length > 0) {\n    shapedEntity = applySelect(shapedEntity, queryOptions.select) as Record<string, unknown>;\n  }\n\n  // Apply $expand navigation properties\n  if (queryOptions.expand && queryOptions.expand.length > 0 && options.enableExpand) {\n    shapedEntity = await applyExpansion(\n      shapedEntity,\n      queryOptions.expand,\n      options,\n      context,\n      0 // Start with depth 0\n    ) as Record<string, unknown>;\n  }\n\n  return shapedEntity;\n}\n\n/**\n * Applies navigation property expansion\n * @param entity Entity to expand\n * @param expandItems Expand items from query options\n * @param options Shape options\n * @param context OData middleware context\n * @param depth Current expansion depth\n * @returns Entity with expanded navigation properties\n */\nasync function applyExpansion(\n  entity: Record<string, unknown>,\n  expandItems: any[],\n  options: ODataShapeOptions,\n  context: ODataMiddlewareContext,\n  depth: number\n): Promise<Record<string, unknown>> {\n  // Check expansion depth limit\n  if (depth >= (options.maxExpandDepth || 3)) {\n    console.warn(`[OData Shape] Maximum expansion depth (${options.maxExpandDepth}) reached`);\n    return entity;\n  }\n\n  const expandedEntity = { ...entity };\n\n  for (const expandItem of expandItems) {\n    const navigationProperty = expandItem.path;\n    \n    if (!navigationProperty) {\n      continue;\n    }\n\n    // Check if we have a custom resolver for this navigation property\n    const resolver = options.expandResolvers?.[navigationProperty];\n    \n    if (resolver) {\n      try {\n        // Use custom resolver to get navigation data\n        const navigationData = await resolver(context);\n        expandedEntity[navigationProperty] = navigationData;\n        \n        // Apply nested query options if present\n        if (expandItem.options) {\n          const nestedContext = {\n            ...context,\n            options: expandItem.options,\n          };\n          \n          if (Array.isArray(navigationData)) {\n            expandedEntity[navigationProperty] = await shapeCollection(\n              navigationData,\n              expandItem.options,\n              options,\n              nestedContext\n            );\n          } else if (navigationData && typeof navigationData === 'object') {\n            expandedEntity[navigationProperty] = await shapeEntity(\n              navigationData as Record<string, unknown>,\n              expandItem.options,\n              options,\n              nestedContext\n            );\n          }\n        }\n      } catch (error) {\n        console.error(`[OData Shape] Error resolving navigation property ${navigationProperty}:`, error);\n        expandedEntity[navigationProperty] = null;\n      }\n    } else {\n      // No custom resolver - check if property exists in entity\n      if (navigationProperty in expandedEntity) {\n        const navigationData = expandedEntity[navigationProperty];\n        \n        // Apply nested query options if present\n        if (expandItem.options && navigationData) {\n          if (Array.isArray(navigationData)) {\n            expandedEntity[navigationProperty] = await shapeCollection(\n              navigationData,\n              expandItem.options,\n              options,\n              {\n                ...context,\n                options: expandItem.options,\n              }\n            );\n          } else if (typeof navigationData === 'object') {\n            expandedEntity[navigationProperty] = await shapeEntity(\n              navigationData as Record<string, unknown>,\n              expandItem.options,\n              options,\n              {\n                ...context,\n                options: expandItem.options,\n              }\n            );\n          }\n        }\n      } else {\n        // Property doesn't exist - set to null\n        expandedEntity[navigationProperty] = null;\n      }\n    }\n  }\n\n  return expandedEntity;\n}\n\n\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataEntity, ODataQueryOptions } from \"./types\";\n\n// Simple filter expression parser and evaluator\ninterface FilterExpression {\n  type: 'comparison' | 'logical' | 'function' | 'property' | 'literal';\n  operator?: string;\n  left?: FilterExpression;\n  right?: FilterExpression;\n  property?: string;\n  value?: any;\n  function?: string;\n  args?: FilterExpression[];\n}\n\nfunction parseFilterExpression(filter: string): FilterExpression {\n  // Simple parser for basic filter expressions\n  // This is a simplified implementation - a full OData parser would be much more complex\n  \n  // Handle parentheses and logical operators\n  if (filter.includes(' and ')) {\n    const parts = splitByOperator(filter, ' and ');\n    return {\n      type: 'logical',\n      operator: 'and',\n      left: parseFilterExpression(parts[0].trim()),\n      right: parseFilterExpression(parts[1].trim())\n    };\n  }\n  \n  if (filter.includes(' or ')) {\n    const parts = splitByOperator(filter, ' or ');\n    return {\n      type: 'logical',\n      operator: 'or',\n      left: parseFilterExpression(parts[0].trim()),\n      right: parseFilterExpression(parts[1].trim())\n    };\n  }\n  \n  // Handle comparison operators\n  const comparisonOps = [' eq ', ' ne ', ' gt ', ' ge ', ' lt ', ' le '];\n  for (const op of comparisonOps) {\n    if (filter.includes(op)) {\n      const parts = filter.split(op);\n      if (parts.length === 2) {\n        return {\n          type: 'comparison',\n          operator: op.trim(),\n          left: parseFilterExpression(parts[0].trim()),\n          right: parseFilterExpression(parts[1].trim())\n        };\n      }\n    }\n  }\n  \n  // Handle functions\n  if (filter.includes('(') && filter.includes(')')) {\n    const funcMatch = filter.match(/^(\\w+)\\((.+)\\)$/);\n    if (funcMatch) {\n      const [, funcName, argsStr] = funcMatch;\n      const args = argsStr.split(',').map(arg => parseFilterExpression(arg.trim()));\n      return {\n        type: 'function',\n        function: funcName,\n        args\n      };\n    }\n  }\n  \n  // Handle literals\n  if (filter.startsWith(\"'\") && filter.endsWith(\"'\")) {\n    return {\n      type: 'literal',\n      value: filter.slice(1, -1)\n    };\n  }\n  \n  if (filter === 'null') {\n    return {\n      type: 'literal',\n      value: null\n    };\n  }\n  \n  if (!isNaN(Number(filter))) {\n    return {\n      type: 'literal',\n      value: Number(filter)\n    };\n  }\n  \n  // Handle properties\n  return {\n    type: 'property',\n    property: filter\n  };\n}\n\nfunction splitByOperator(str: string, operator: string): string[] {\n  let depth = 0;\n  let inQuotes = false;\n  \n  for (let i = 0; i < str.length - operator.length + 1; i++) {\n    const char = str[i];\n    if (char === \"'\") inQuotes = !inQuotes;\n    if (inQuotes) continue;\n    \n    if (char === '(') depth++;\n    if (char === ')') depth--;\n    \n    if (depth === 0 && str.slice(i, i + operator.length) === operator) {\n      return [str.slice(0, i), str.slice(i + operator.length)];\n    }\n  }\n  \n  return [str];\n}\n\nfunction evaluateExpression(expr: FilterExpression, entity: any): any {\n  switch (expr.type) {\n    case 'property':\n      return getPropertyValue(entity, expr.property!);\n    \n    case 'literal':\n      return expr.value;\n    \n    case 'comparison': {\n      const left = evaluateExpression(expr.left!, entity);\n      const right = evaluateExpression(expr.right!, entity);\n      return evaluateComparison(left, expr.operator!, right);\n    }\n    \n    case 'logical': {\n      const leftResult = evaluateExpression(expr.left!, entity);\n      const rightResult = evaluateExpression(expr.right!, entity);\n      return evaluateLogical(leftResult, expr.operator!, rightResult);\n    }\n    \n    case 'function':\n      return evaluateFunction(expr.function!, expr.args!, entity);\n    \n    default:\n      return false;\n  }\n}\n\nfunction getPropertyValue(entity: any, property: string): any {\n  // Handle nested properties (e.g., \"address/city\")\n  const parts = property.split('/');\n  let value = entity;\n  for (const part of parts) {\n    if (value && typeof value === 'object') {\n      value = value[part];\n    } else {\n      return undefined;\n    }\n  }\n  return value;\n}\n\nfunction evaluateComparison(left: any, operator: string, right: any): boolean {\n  switch (operator) {\n    case 'eq': return left === right;\n    case 'ne': return left !== right;\n    case 'gt': return left > right;\n    case 'ge': return left >= right;\n    case 'lt': return left < right;\n    case 'le': return left <= right;\n    default: return false;\n  }\n}\n\nfunction evaluateLogical(left: boolean, operator: string, right: boolean): boolean {\n  switch (operator) {\n    case 'and': return left && right;\n    case 'or': return left || right;\n    default: return false;\n  }\n}\n\nfunction evaluateFunction(funcName: string, args: FilterExpression[], entity: any): any {\n  const argValues = args.map(arg => evaluateExpression(arg, entity));\n  \n  switch (funcName) {\n    case 'contains':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const substring = String(argValues[1] || '');\n        return str.includes(substring);\n      }\n      return false;\n    \n    case 'startswith':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const prefix = String(argValues[1] || '');\n        return str.startsWith(prefix);\n      }\n      return false;\n    \n    case 'endswith':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const suffix = String(argValues[1] || '');\n        return str.endsWith(suffix);\n      }\n      return false;\n    \n    case 'length':\n      if (argValues.length >= 1) {\n        const str = String(argValues[0] || '');\n        return str.length;\n      }\n      return 0;\n    \n    case 'tolower':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').toLowerCase();\n      }\n      return '';\n    \n    case 'toupper':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').toUpperCase();\n      }\n      return '';\n    \n    case 'trim':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').trim();\n      }\n      return '';\n    \n    case 'substring':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const start = Number(argValues[1]) || 0;\n        if (argValues.length >= 3) {\n          const length = Number(argValues[2]) || 0;\n          return str.substring(start, start + length);\n        }\n        return str.substring(start);\n      }\n      return '';\n    \n    case 'indexof':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const substring = String(argValues[1] || '');\n        return str.indexOf(substring);\n      }\n      return -1;\n    \n    case 'concat':\n      return argValues.map(v => String(v || '')).join('');\n    \n    case 'year':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getFullYear();\n      }\n      return 0;\n    \n    case 'month':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getMonth() + 1;\n      }\n      return 0;\n    \n    case 'day':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getDate();\n      }\n      return 0;\n    \n    case 'hour':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getHours();\n      }\n      return 0;\n    \n    case 'minute':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getMinutes();\n      }\n      return 0;\n    \n    case 'second':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getSeconds();\n      }\n      return 0;\n    \n    case 'round':\n      if (argValues.length >= 1) {\n        return Math.round(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'floor':\n      if (argValues.length >= 1) {\n        return Math.floor(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'ceiling':\n      if (argValues.length >= 1) {\n        return Math.ceil(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'now':\n      return new Date().toISOString();\n    \n    case 'maxdatetime':\n      return new Date('9999-12-31T23:59:59.999Z').toISOString();\n    \n    case 'mindatetime':\n      return new Date('0001-01-01T00:00:00.000Z').toISOString();\n    \n    default:\n      return false;\n  }\n}\n\nexport function filterArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.filter) return rows;\n  \n  try {\n    const expression = parseFilterExpression(options.filter);\n    return rows.filter(row => evaluateExpression(expression, row));\n  } catch (error) {\n    // If filter parsing fails, return all rows\n    // eslint-disable-next-line no-undef\n    console.warn('Filter parsing failed:', error);\n    return rows;\n  }\n}\n\nexport function orderArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.orderby || options.orderby.length === 0) return rows;\n  const copy = [...rows];\n  copy.sort((a, b) => {\n    for (const term of options.orderby!) {\n      const av = (a as any)[term.property];\n      const bv = (b as any)[term.property];\n      if (av == null && bv == null) continue;\n      if (av == null) return term.direction === \"asc\" ? -1 : 1;\n      if (bv == null) return term.direction === \"asc\" ? 1 : -1;\n      if (av < bv) return term.direction === \"asc\" ? -1 : 1;\n      if (av > bv) return term.direction === \"asc\" ? 1 : -1;\n    }\n    return 0;\n  });\n  return copy;\n}\n\nexport function paginateArray<T>(rows: T[], options: ODataQueryOptions): T[] {\n  const skip = options.skip ?? 0;\n  const top = options.top ?? rows.length;\n  return rows.slice(skip, skip + top);\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataFilterOptions, ODataMiddlewareContext } from \"./types\";\nimport { filterArray, orderArray } from \"../core/filter-order\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\nconst DEFAULT_FILTER_OPTIONS: ODataFilterOptions = {\n  enableFilter: true,\n  enableOrderby: true,\n  maxFilterDepth: 10,\n  caseSensitive: true,\n};\n\n/**\n * OData Filter Middleware\n * \n * Responsibilities:\n * - Apply $filter expressions to response data\n * - Apply $orderby sorting to response data\n * - Handle filter expression parsing and evaluation\n * - Manage filter depth and prevent infinite recursion\n */\nexport function odataFilter(options: Partial<ODataFilterOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_FILTER_OPTIONS, options);\n\n  return {\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        if (!context || !context.options) {\n          return; // No OData context, skip filtering\n        }\n\n        // Get response data\n        let responseData = request.response?.body;\n        if (typeof responseData === 'string') {\n          try {\n            responseData = JSON.parse(responseData);\n          } catch {\n            // If parsing fails, skip filtering\n            return;\n          }\n        }\n\n        if (!responseData) {\n          return; // No data to filter\n        }\n\n        // Apply filtering and ordering\n        const filteredData = await applyFilteringAndOrdering(responseData, context, opts);\n\n        // Update response\n        if (request.response) {\n          request.response.body = JSON.stringify(filteredData);\n        } else {\n          request.response = {\n            statusCode: 200,\n            body: JSON.stringify(filteredData),\n          };\n        }\n\n        // Update context with filtered data\n        context.data = filteredData;\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If filtering fails, log error but don't break the response\n        console.error('[OData Filter] Error applying filtering/ordering:', error);\n        // Continue with original response\n      }\n    },\n  };\n}\n\n/**\n * Applies filtering and ordering to response data\n * @param data Response data to filter/order\n * @param context OData middleware context\n * @param options Filter options\n * @returns Filtered and ordered data\n */\nasync function applyFilteringAndOrdering(\n  data: unknown,\n  context: ODataMiddlewareContext,\n  options: ODataFilterOptions\n): Promise<unknown> {\n  const { options: queryOptions } = context;\n\n  // Handle collection responses\n  if (Array.isArray(data)) {\n    return await filterAndOrderCollection(data, queryOptions, options);\n  }\n\n  // Handle single entity responses - filtering doesn't apply to single entities\n  // but ordering might if it's a collection property\n  if (data && typeof data === 'object') {\n    return await filterAndOrderEntity(data as Record<string, unknown>, queryOptions, options, context);\n  }\n\n  // Return primitive values as-is\n  return data;\n}\n\n/**\n * Filters and orders a collection of entities\n * @param entities Array of entities\n * @param queryOptions OData query options\n * @param options Filter options\n * @param context OData middleware context\n * @returns Filtered and ordered collection\n */\nasync function filterAndOrderCollection(\n  entities: unknown[],\n  queryOptions: any,\n  options: ODataFilterOptions\n): Promise<unknown[]> {\n  let filteredEntities = [...entities];\n\n  // Apply $filter if present and enabled\n  if (queryOptions.filter && options.enableFilter) {\n    try {\n      filteredEntities = filterArray(filteredEntities as any[], queryOptions.filter);\n    } catch (error) {\n      console.error('[OData Filter] Error applying filter:', error);\n      // Continue with unfiltered data\n    }\n  }\n\n  // Apply $orderby if present and enabled\n  if (queryOptions.orderby && queryOptions.orderby.length > 0 && options.enableOrderby) {\n    try {\n      filteredEntities = orderArray(filteredEntities as any[], queryOptions.orderby);\n    } catch (error) {\n      console.error('[OData Filter] Error applying orderby:', error);\n      // Continue with unordered data\n    }\n  }\n\n  return filteredEntities;\n}\n\n/**\n * Filters and orders a single entity (for collection properties)\n * @param entity Entity to process\n * @param queryOptions OData query options\n * @param options Filter options\n * @param context OData middleware context\n * @returns Processed entity\n */\nasync function filterAndOrderEntity(\n  entity: Record<string, unknown>,\n  queryOptions: any,\n  options: ODataFilterOptions,\n  context: ODataMiddlewareContext\n): Promise<Record<string, unknown>> {\n  const processedEntity = { ...entity };\n\n  // Process collection properties within the entity\n  for (const [key, value] of Object.entries(processedEntity)) {\n    if (Array.isArray(value)) {\n      // This is a collection property - apply filtering/ordering if applicable\n      const collectionOptions = getCollectionOptionsForProperty(key, queryOptions);\n      if (collectionOptions) {\n        processedEntity[key] = await filterAndOrderCollection(\n          value,\n          collectionOptions,\n          options,\n        );\n      }\n    }\n  }\n\n  return processedEntity;\n}\n\n/**\n * Gets query options for a specific collection property\n * @param propertyName Name of the collection property\n * @param queryOptions OData query options\n * @returns Query options for the collection property\n */\nfunction getCollectionOptionsForProperty(propertyName: string, queryOptions: any): any {\n  // This is a simplified implementation\n  // In a real scenario, this would look at $expand options to find nested query options\n  // for the specific navigation property\n  \n  if (queryOptions.expand) {\n    for (const expandItem of queryOptions.expand) {\n      if (expandItem.path === propertyName && expandItem.options) {\n        return expandItem.options;\n      }\n    }\n  }\n\n  return null;\n}\n\n\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataPaginationOptions, ODataMiddlewareContext } from \"./types\";\nimport { paginateArray } from \"../core/filter-order\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\nconst DEFAULT_PAGINATION_OPTIONS: ODataPaginationOptions = {\n  maxTop: 1000,\n  defaultTop: 50,\n  enableCount: true,\n};\n\n/**\n * OData Pagination Middleware\n * \n * Responsibilities:\n * - Apply $top and $skip pagination to response data\n * - Calculate and include $count when requested\n * - Generate @odata.nextLink for pagination\n * - Enforce maximum page size limits\n * - Handle pagination edge cases\n */\nexport function odataPagination(options: Partial<ODataPaginationOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_PAGINATION_OPTIONS, options);\n\n  return {\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        if (!context || !context.options) {\n          return; // No OData context, skip pagination\n        }\n\n        // Get response data\n        let responseData = request.response?.body;\n        if (typeof responseData === 'string') {\n          try {\n            responseData = JSON.parse(responseData);\n          } catch {\n            // If parsing fails, skip pagination\n            return;\n          }\n        }\n\n        if (!responseData) {\n          return; // No data to paginate\n        }\n\n        // Apply pagination\n        const paginatedData = await applyPagination(responseData, context, opts, request);\n\n        // Update response\n        if (request.response) {\n          request.response.body = JSON.stringify(paginatedData);\n        } else {\n          request.response = {\n            statusCode: 200,\n            body: JSON.stringify(paginatedData),\n          };\n        }\n\n        // Update context with paginated data\n        context.data = paginatedData;\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If pagination fails, log error but don't break the response\n        console.error('[OData Pagination] Error applying pagination:', error);\n        // Continue with original response\n      }\n    },\n  };\n}\n\n/**\n * Applies pagination to response data\n * @param data Response data to paginate\n * @param context OData middleware context\n * @param options Pagination options\n * @param request Middy request object\n * @returns Paginated data with count and nextLink\n */\nasync function applyPagination(\n  data: unknown,\n  context: ODataMiddlewareContext,\n  options: ODataPaginationOptions,\n  request: any\n): Promise<unknown> {\n  const { options: queryOptions } = context;\n\n  // Handle collection responses\n  if (Array.isArray(data)) {\n    return await paginateCollection(data, queryOptions, options, context, request);\n  }\n\n  // Handle single entity responses - pagination doesn't apply to single entities\n  // but we might need to add count information\n  if (data && typeof data === 'object') {\n    return await addCountToEntity(data as Record<string, unknown>, queryOptions, options, context);\n  }\n\n  // Return primitive values as-is\n  return data;\n}\n\n/**\n * Paginates a collection of entities\n * @param entities Array of entities\n * @param queryOptions OData query options\n * @param options Pagination options\n * @param context OData middleware context\n * @param request Middy request object\n * @returns Paginated collection with count and nextLink\n */\nasync function paginateCollection(\n  entities: unknown[],\n  queryOptions: any,\n  options: ODataPaginationOptions,\n  context: ODataMiddlewareContext,\n  request: any\n): Promise<unknown> {\n  const totalCount = entities.length;\n  let paginatedEntities = [...entities];\n\n  // Apply $top and $skip\n  const top = queryOptions.top;\n  const skip = queryOptions.skip || 0;\n\n  // Validate and enforce limits\n  const validatedTop = validateTopLimit(top, options);\n  const validatedSkip = Math.max(0, skip);\n\n  // Apply pagination\n  if (validatedTop !== undefined || validatedSkip > 0) {\n    paginatedEntities = paginateArray(entities, { top: validatedTop, skip: validatedSkip });\n  }\n\n  // Create paginated response\n  const result: any = {\n    \"@odata.context\": generateContextUrl(context),\n    value: paginatedEntities,\n  };\n\n  // Add count if requested\n  if (queryOptions.count && options.enableCount) {\n    result[\"@odata.count\"] = totalCount;\n  }\n\n  // Add nextLink if there are more results\n  const hasMoreResults = (validatedSkip + (validatedTop || totalCount)) < totalCount;\n  if (hasMoreResults && validatedTop !== undefined) {\n    result[\"@odata.nextLink\"] = generateNextLink(context, request, validatedTop, validatedSkip);\n  }\n\n  return result;\n}\n\n/**\n * Adds count information to a single entity response\n * @param entity Entity to process\n * @param queryOptions OData query options\n * @param options Pagination options\n * @param context OData middleware context\n * @returns Entity with count information\n */\nasync function addCountToEntity(\n  entity: Record<string, unknown>,\n  queryOptions: any,\n  options: ODataPaginationOptions,\n  context: ODataMiddlewareContext\n): Promise<Record<string, unknown>> {\n  const result = { ...entity };\n\n  // Add @odata.context if not present\n  if (!result[\"@odata.context\"]) {\n    result[\"@odata.context\"] = generateContextUrl(context);\n  }\n\n  // Add count if requested (for single entities, count is always 1)\n  if (queryOptions.count && options.enableCount) {\n    result[\"@odata.count\"] = 1;\n  }\n\n  return result;\n}\n\n/**\n * Validates and enforces top limit\n * @param top Requested top value\n * @param options Pagination options\n * @returns Validated top value\n */\nfunction validateTopLimit(top: number | undefined, options: ODataPaginationOptions): number | undefined {\n  if (top === undefined) {\n    return options.defaultTop;\n  }\n\n  if (top < 0) {\n    return 0;\n  }\n\n  if (top > (options.maxTop || 1000)) {\n    console.warn(`[OData Pagination] Top value ${top} exceeds maximum ${options.maxTop}, using maximum`);\n    return options.maxTop;\n  }\n\n  return top;\n}\n\n/**\n * Generates @odata.context URL\n * @param context OData middleware context\n * @returns Context URL\n */\nfunction generateContextUrl(context: ODataMiddlewareContext): string {\n  const { serviceRoot, entitySet } = context;\n  \n  if (entitySet) {\n    return `${serviceRoot}/$metadata#${entitySet}`;\n  }\n  \n  return `${serviceRoot}/$metadata`;\n}\n\n/**\n * Generates @odata.nextLink URL\n * @param context OData middleware context\n * @param request Middy request object\n * @param top Current top value\n * @param skip Current skip value\n * @returns NextLink URL\n */\nfunction generateNextLink(\n  context: ODataMiddlewareContext,\n  request: any,\n  top: number,\n  skip: number\n): string {\n  const { serviceRoot } = context;\n  const event = request.event || {};\n  \n  // Get current path\n  const path = event.path || event.rawPath || '/';\n  \n  // Get current query parameters\n  const currentQuery = event.rawQueryString \n    ? Object.fromEntries(new URLSearchParams(event.rawQueryString))\n    : (event.queryStringParameters || {});\n\n  // Update pagination parameters\n  const nextQuery = { ...currentQuery };\n  nextQuery.$skip = String(skip + top);\n  \n  // Build query string\n  const queryString = new URLSearchParams(nextQuery).toString();\n  \n  return `${serviceRoot}${path}?${queryString}`;\n}\n\n","import type { ODataCollectionResponse } from \"./types\";\n\nexport function serializeCollection<T>(contextUrl: string, value: T[], count?: number, nextLink?: string): ODataCollectionResponse<T> {\n  const out: ODataCollectionResponse<T> = {\n    \"@odata.context\": contextUrl,\n    value,\n  };\n  if (typeof count === \"number\") out[\"@odata.count\"] = count;\n  if (nextLink) out[\"@odata.nextLink\"] = nextLink;\n  return out;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataSerializeOptions, ODataMiddlewareContext } from \"./types\";\nimport { serializeCollection } from \"../core/serialize\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\n\nconst DEFAULT_SERIALIZE_OPTIONS: ODataSerializeOptions = {\n  format: \"json\",\n  includeMetadata: true,\n  prettyPrint: false,\n};\n\n/**\n * OData Serialize Middleware\n * \n * Responsibilities:\n * - Format response data according to OData standards\n * - Add @odata.context and other metadata annotations\n * - Handle different response formats (JSON, XML, ATOM)\n * - Ensure proper OData response structure\n * - Add ETags and other HTTP headers\n */\nexport function odataSerialize(options: Partial<ODataSerializeOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_SERIALIZE_OPTIONS, options);\n\n  return {\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        if (!context) {\n          return; // No OData context, skip serialization\n        }\n\n        // Get response data\n        let responseData = request.response?.body;\n        if (typeof responseData === 'string') {\n          try {\n            responseData = JSON.parse(responseData);\n          } catch {\n            // If parsing fails, skip serialization\n            return;\n          }\n        }\n\n        if (!responseData) {\n          return; // No data to serialize\n        }\n\n        // Apply OData serialization\n        const serializedData = await applySerialization(responseData, context, opts, request);\n\n        // Update response\n        if (request.response) {\n          request.response.body = JSON.stringify(serializedData);\n          \n          // Add OData-specific headers\n          addODataHeaders(request.response, context, opts);\n        } else {\n          request.response = {\n            statusCode: 200,\n            body: JSON.stringify(serializedData),\n            headers: {},\n          };\n          \n          // Add OData-specific headers\n          addODataHeaders(request.response, context, opts);\n        }\n\n        // Update context with serialized data\n        context.data = serializedData;\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // If serialization fails, log error but don't break the response\n        console.error('[OData Serialize] Error applying serialization:', error);\n        // Continue with original response\n      }\n    },\n  };\n}\n\n/**\n * Applies OData serialization to response data\n * @param data Response data to serialize\n * @param context OData middleware context\n * @param options Serialize options\n * @param request Middy request object\n * @returns Serialized data\n */\nasync function applySerialization(\n  data: unknown,\n  context: ODataMiddlewareContext,\n  options: ODataSerializeOptions,\n  request: any\n): Promise<unknown> {\n  const { options: queryOptions } = context;\n\n  // Handle collection responses\n  if (Array.isArray(data)) {\n    return await serializeCollectionResponse(data, queryOptions, options, context, request);\n  }\n\n  // Handle single entity responses\n  if (data && typeof data === 'object') {\n    return await serializeEntityResponse(data as Record<string, unknown>, queryOptions, options, context);\n  }\n\n  // Handle primitive responses\n  return await serializePrimitiveResponse(data, options, context);\n}\n\n/**\n * Serializes a collection response\n * @param entities Array of entities\n * @param queryOptions OData query options\n * @param options Serialize options\n * @param context OData middleware context\n * @param request Middy request object\n * @returns Serialized collection response\n */\nasync function serializeCollectionResponse(\n  entities: unknown[],\n  queryOptions: any,\n  options: ODataSerializeOptions,\n  context: ODataMiddlewareContext,\n  request: any\n): Promise<unknown> {\n  const contextUrl = generateContextUrl(context);\n  const count = queryOptions.count ? entities.length : undefined;\n  const nextLink = generateNextLink(context, request);\n\n  // Use the existing serializeCollection function if available\n  if (typeof serializeCollection === 'function') {\n    return serializeCollection(contextUrl, entities, count, nextLink);\n  }\n\n  // Fallback implementation\n  const result: any = {\n    \"@odata.context\": contextUrl,\n    value: entities,\n  };\n\n  if (count !== undefined) {\n    result[\"@odata.count\"] = count;\n  }\n\n  if (nextLink) {\n    result[\"@odata.nextLink\"] = nextLink;\n  }\n\n  return result;\n}\n\n/**\n * Serializes a single entity response\n * @param entity Entity to serialize\n * @param queryOptions OData query options\n * @param options Serialize options\n * @param context OData middleware context\n * @param request Middy request object\n * @returns Serialized entity response\n */\nasync function serializeEntityResponse(\n  entity: Record<string, unknown>,\n  queryOptions: any,\n  options: ODataSerializeOptions,\n  context: ODataMiddlewareContext\n): Promise<Record<string, unknown>> {\n  const result = { ...entity };\n\n  // Add @odata.context if not present\n  if (!result[\"@odata.context\"]) {\n    result[\"@odata.context\"] = generateContextUrl(context);\n  }\n\n  // Add @odata.etag if entity has a version property\n  if (entity.version && !result[\"@odata.etag\"]) {\n    result[\"@odata.etag\"] = `\"${entity.version}\"`;\n  }\n\n  // Add @odata.id if entity has an id property\n  if (entity.id && !result[\"@odata.id\"]) {\n    result[\"@odata.id\"] = generateEntityId(context, String(entity.id));\n  }\n\n  return result;\n}\n\n/**\n * Serializes a primitive response\n * @param data Primitive data to serialize\n * @param options Serialize options\n * @param context OData middleware context\n * @param request Middy request object\n * @returns Serialized primitive response\n */\nasync function serializePrimitiveResponse(\n  data: unknown,\n  options: ODataSerializeOptions,\n  context: ODataMiddlewareContext\n): Promise<unknown> {\n  // For primitive responses, wrap in OData format\n  const result: any = {\n    \"@odata.context\": generateContextUrl(context),\n    value: data,\n  };\n\n  return result;\n}\n\n/**\n * Generates @odata.context URL\n * @param context OData middleware context\n * @returns Context URL\n */\nfunction generateContextUrl(context: ODataMiddlewareContext): string {\n  const { serviceRoot, entitySet } = context;\n  \n  if (entitySet) {\n    return `${serviceRoot}/$metadata#${entitySet}`;\n  }\n  \n  return `${serviceRoot}/$metadata`;\n}\n\n/**\n * Generates @odata.id URL for an entity\n * @param context OData middleware context\n * @param entityId Entity ID\n * @returns Entity ID URL\n */\nfunction generateEntityId(context: ODataMiddlewareContext, entityId: string | number): string {\n  const { serviceRoot, entitySet } = context;\n  \n  if (entitySet) {\n    return `${serviceRoot}/${entitySet}(${entityId})`;\n  }\n  \n  return `${serviceRoot}(${entityId})`;\n}\n\n/**\n * Generates @odata.nextLink URL\n * @param context OData middleware context\n * @param request Middy request object\n * @param queryOptions OData query options\n * @returns NextLink URL\n */\nfunction generateNextLink(\n  context: ODataMiddlewareContext,\n  request: any\n): string | undefined {\n  // This is a simplified implementation\n  // In a real scenario, this would check if there are more results\n  // and generate the appropriate nextLink URL\n  \n  const { serviceRoot } = context;\n  const event = request.event || {};\n  \n  // Get current path\n  const path = event.path || event.rawPath || '/';\n  \n  // Get current query parameters\n  const currentQuery = event.rawQueryString \n    ? Object.fromEntries(new URLSearchParams(event.rawQueryString))\n    : (event.queryStringParameters || {});\n\n  // Update pagination parameters for next page\n  const nextQuery = { ...currentQuery };\n  const currentSkip = parseInt(nextQuery.$skip || '0', 10);\n  const currentTop = parseInt(nextQuery.$top || '50', 10);\n  \n  nextQuery.$skip = String(currentSkip + currentTop);\n  \n  // Build query string\n  const queryString = new URLSearchParams(nextQuery).toString();\n  \n  return `${serviceRoot}${path}?${queryString}`;\n}\n\n/**\n * Adds OData-specific HTTP headers\n * @param response HTTP response object\n * @param context OData middleware context\n * @param options Serialize options\n */\nfunction addODataHeaders(response: any, context: ODataMiddlewareContext, options: ODataSerializeOptions): void {\n  if (!response.headers) {\n    response.headers = {};\n  }\n\n  // Set content type based on format\n  switch (options.format) {\n    case 'json':\n      response.headers['Content-Type'] = 'application/json';\n      break;\n    case 'xml':\n      response.headers['Content-Type'] = 'application/xml';\n      break;\n    case 'atom':\n      response.headers['Content-Type'] = 'application/atom+xml';\n      break;\n    default:\n      response.headers['Content-Type'] = 'application/json';\n  }\n\n  // Add OData version header\n  response.headers['OData-Version'] = '4.01';\n\n  // Add ETag if available\n  if (context.data && typeof context.data === 'object') {\n    const data = context.data as Record<string, unknown>;\n    if (data['@odata.etag']) {\n      response.headers['ETag'] = data['@odata.etag'] as string;\n    }\n  }\n\n  // Add CORS headers if needed\n  if (!response.headers['Access-Control-Allow-Origin']) {\n    response.headers['Access-Control-Allow-Origin'] = '*';\n  }\n\n  if (!response.headers['Access-Control-Allow-Methods']) {\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';\n  }\n\n  if (!response.headers['Access-Control-Allow-Headers']) {\n    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, OData-MaxVersion, OData-Version';\n  }\n}\n\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataErrorPayload, EdmModel } from \"./types\";\n\nexport class ODataBadRequest extends Error {\n  statusCode = 400;\n  code = \"BadRequest\";\n}\n\nexport class ODataInternalServerError extends Error {\n  statusCode = 500;\n  code = \"InternalServerError\";\n}\n\nexport function toODataError(err: unknown, message?: string): ODataErrorPayload {\n  if (err && typeof err === \"object\" && \"statusCode\" in err && \"message\" in err) {\n    const e = err as any;\n    return { error: { code: e.code ?? String(e.statusCode), message: e.message } };\n  }\n  return { error: { code: \"InternalServerError\", message: message ?? \"An error occurred\" } };\n}\n\n// Validation functions for OData query parameters\nexport function validateSelectParameters(select: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!select || select.length === 0) return;\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  for (const property of select) {\n    if (!validProperties.includes(property)) {\n      throw new ODataBadRequest(`Property '${property}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateFilterExpression(filter: string | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!filter) return;\n  \n  // Basic filter validation - check for common syntax errors\n  if (filter.includes('()')) {\n    throw new ODataBadRequest(\"Invalid filter expression: empty parentheses\");\n  }\n  \n  if (filter.includes('  ')) {\n    throw new ODataBadRequest(\"Invalid filter expression: multiple spaces\");\n  }\n  \n  // Check for balanced parentheses\n  let parenCount = 0;\n  for (const char of filter) {\n    if (char === '(') parenCount++;\n    if (char === ')') parenCount--;\n    if (parenCount < 0) {\n      throw new ODataBadRequest(\"Invalid filter expression: unmatched closing parenthesis\");\n    }\n  }\n  if (parenCount !== 0) {\n    throw new ODataBadRequest(\"Invalid filter expression: unmatched opening parenthesis\");\n  }\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  // Extract property names from filter (simple regex-based approach)\n  // Skip string literals (text in single quotes)\n  const filterWithoutStrings = filter.replace(/'[^']*'/g, '');\n  const propertyMatches = filterWithoutStrings.match(/\\b([a-zA-Z_][a-zA-Z0-9_]*)\\b/g) || [];\n  for (const match of propertyMatches) {\n    if (!['eq', 'ne', 'gt', 'ge', 'lt', 'le', 'and', 'or', 'not', 'true', 'false', 'null'].includes(match) && \n        !validProperties.includes(match)) {\n      throw new ODataBadRequest(`Property '${match}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateOrderByProperties(orderby: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!orderby || orderby.length === 0) return;\n  \n  // Get entity type properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validProperties = entityTypeDef.properties?.map(p => p.name) || [];\n  \n  for (const orderByItem of orderby) {\n    const [property] = orderByItem.split(' ');\n    if (!validProperties.includes(property)) {\n      throw new ODataBadRequest(`Property '${property}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateExpandNavigationProperties(expand: string[] | undefined, entityType: string, edmModel: EdmModel): void {\n  if (!expand || expand.length === 0) return;\n  \n  // Get entity type navigation properties from EDM model\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  const validNavigationProperties = entityTypeDef.navigation?.map(np => np.name) || [];\n  \n  for (const navigationProperty of expand) {\n    if (!validNavigationProperties.includes(navigationProperty)) {\n      throw new ODataBadRequest(`Navigation property '${navigationProperty}' not found in entity type '${entityType}'`);\n    }\n  }\n}\n\nexport function validateEdmModelConstraints(entity: any, entityType: string, edmModel: EdmModel): void {\n  const entityTypeDef = edmModel.entityTypes?.find(et => et.name === entityType);\n  if (!entityTypeDef) {\n    throw new ODataBadRequest(`Entity type '${entityType}' not found`);\n  }\n  \n  // Check required properties (assume all properties are required if nullable is not explicitly set to true)\n  const requiredProperties = entityTypeDef.properties?.filter(p => p.nullable !== true) || [];\n  for (const property of requiredProperties) {\n    if (!(property.name in entity) || entity[property.name] === null || entity[property.name] === undefined) {\n      throw new ODataBadRequest(`Required property '${property.name}' is missing or null`);\n    }\n  }\n  \n  // Check property types (basic validation)\n  for (const property of entityTypeDef.properties || []) {\n    if (property.name in entity) {\n      const value = entity[property.name];\n      if (value !== null && value !== undefined) {\n        // Basic type checking\n        if (property.type === 'Edm.String' && typeof value !== 'string') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a string`);\n        }\n        if ((property.type === 'Edm.Int32' || property.type === 'Edm.Decimal') && typeof value !== 'number') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a number`);\n        }\n        if (property.type === 'Edm.Boolean' && typeof value !== 'boolean') {\n          throw new ODataBadRequest(`Property '${property.name}' must be a boolean`);\n        }\n      }\n    }\n  }\n}\n\n// HTTP status code mapping\nexport function getHttpStatusCode(error: Error): number {\n  if (error instanceof ODataBadRequest) {\n    return 400;\n  }\n  if (error instanceof ODataInternalServerError) {\n    return 500;\n  }\n  // Default to 500 for unknown errors\n  return 500;\n}\n\nexport function isValidationError(error: Error): boolean {\n  return error instanceof ODataBadRequest;\n}\n\nexport function isServerError(error: Error): boolean {\n  return error instanceof ODataInternalServerError;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataErrorOptions, ODataMiddlewareContext } from \"./types\";\nimport { toODataError } from \"../core/errors\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\n\nconst DEFAULT_ERROR_OPTIONS: ODataErrorOptions = {\n  includeStackTrace: false,\n  logErrors: true,\n  customErrorHandler: undefined,\n};\n\n/**\n * OData Error Middleware\n * \n * Responsibilities:\n * - Catch and format errors according to OData standards\n * - Convert application errors to OData error responses\n * - Add proper HTTP status codes and error details\n * - Log errors for debugging and monitoring\n * - Handle different error types (validation, not found, server errors)\n */\nexport function odataError(options: Partial<ODataErrorOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_ERROR_OPTIONS, options);\n\n  return {\n    onError: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        const error = request.error;\n\n        if (!error) {\n          return;\n        }\n\n        // Log the error if enabled\n        if (opts.logErrors) {\n          console.error(\"OData Error:\", {\n            message: error.message,\n            stack: error.stack,\n            context: {\n              entitySet: context?.entitySet,\n              serviceRoot: context?.serviceRoot,\n              options: context?.options,\n            },\n          });\n        }\n\n        // Use custom error handler if provided\n        if (opts.customErrorHandler) {\n          const customResult = await opts.customErrorHandler(error, context, request);\n          if (customResult) {\n            request.response = customResult;\n            return;\n          }\n        }\n\n        // Create OData-compliant error response\n        const odataError = toODataError(error, error.message);\n\n        // Set the response\n        request.response = {\n          statusCode: (error as any).statusCode || 500,\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"OData-Version\": \"4.0\",\n          },\n          body: JSON.stringify(odataError),\n        };\n\n        // Update context with error information\n        if (context) {\n          context.error = error;\n          context.metadata = {\n            ...context.metadata,\n            error: {\n              code: (error as any).code || \"InternalServerError\",\n              message: error.message,\n              statusCode: (error as any).statusCode || 500,\n            },\n          };\n          setMiddlewareContext(request, context);\n        }\n\n      } catch (errorHandlingError) {\n        // If error handling itself fails, create a basic error response\n        console.error(\"Error in error handling middleware:\", errorHandlingError);\n        \n        request.response = {\n          statusCode: 500,\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"OData-Version\": \"4.0\",\n          },\n          body: JSON.stringify({\n            error: {\n              code: \"InternalServerError\",\n              message: \"An error occurred while processing the request\",\n              target: \"error-handling\",\n            },\n          }),\n        };\n      }\n    },\n  };\n}\n\n/**\n * Helper function to create OData error from various error types\n */\nexport function createODataErrorFromType(\n  errorType: \"BadRequest\" | \"NotFound\" | \"Unauthorized\" | \"Forbidden\" | \"InternalServerError\",\n  message: string,\n  details?: any\n) {\n  const errorMap = {\n    BadRequest: { statusCode: 400, code: \"BadRequest\" },\n    NotFound: { statusCode: 404, code: \"NotFound\" },\n    Unauthorized: { statusCode: 401, code: \"Unauthorized\" },\n    Forbidden: { statusCode: 403, code: \"Forbidden\" },\n    InternalServerError: { statusCode: 500, code: \"InternalServerError\" },\n  };\n\n  const errorInfo = errorMap[errorType];\n  \n  return {\n    statusCode: errorInfo.statusCode,\n    code: errorInfo.code,\n    message,\n    details: details ? [details] : undefined,\n    target: \"odata-middleware\",\n  };\n}\n\n/**\n * Helper function to validate OData query options and throw appropriate errors\n */\nexport function validateODataQuery(options: any, context?: ODataMiddlewareContext) {\n  const errors: string[] = [];\n\n  // Validate $top\n  if (options.top !== undefined) {\n    if (typeof options.top !== \"number\" || options.top < 0) {\n      errors.push(\"$top must be a non-negative integer\");\n    }\n    if (context?.metadata?.maxTop && options.top > context.metadata.maxTop) {\n      errors.push(`$top cannot exceed ${context.metadata.maxTop}`);\n    }\n  }\n\n  // Validate $skip\n  if (options.skip !== undefined) {\n    if (typeof options.skip !== \"number\" || options.skip < 0) {\n      errors.push(\"$skip must be a non-negative integer\");\n    }\n  }\n\n  // Validate $orderby\n  if (options.orderby && typeof options.orderby !== \"string\") {\n    errors.push(\"$orderby must be a string\");\n  }\n\n  // Validate $filter\n  if (options.filter && typeof options.filter !== \"string\") {\n    errors.push(\"$filter must be a string\");\n  }\n\n  // Validate $select\n  if (options.select && typeof options.select !== \"string\") {\n    errors.push(\"$select must be a string\");\n  }\n\n  // Validate $expand\n  if (options.expand && typeof options.expand !== \"string\") {\n    errors.push(\"$expand must be a string\");\n  }\n\n  if (errors.length > 0) {\n    const error = new Error(`Invalid OData query options: ${errors.join(\", \")}`);\n    (error as any).statusCode = 400;\n    (error as any).code = \"BadRequest\";\n    throw error;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n// import type { ODataEntity } from \"./types\";\n\nexport interface FunctionParameter {\n  name: string;\n  type: string;\n  value: unknown;\n}\n\nexport interface FunctionCall {\n  name: string;\n  parameters?: FunctionParameter[];\n  boundTo?: string;\n}\n\nexport interface ActionParameter {\n  name: string;\n  type: string;\n  value: unknown;\n}\n\nexport interface ActionCall {\n  name: string;\n  parameters?: ActionParameter[];\n  boundTo?: string;\n}\n\nexport interface FunctionResult {\n  value: unknown;\n  \"@odata.context\"?: string;\n}\n\nexport interface ActionResult {\n  value?: unknown;\n  \"@odata.context\"?: string;\n}\n\n// Function registry for unbound functions\nconst functionRegistry = new Map<string, (params: Record<string, unknown>) => FunctionResult>();\n\n// Action registry for unbound actions\nconst actionRegistry = new Map<string, (params: Record<string, unknown>) => ActionResult>();\n\n// Register built-in functions\nfunctionRegistry.set(\"getProductsByCategory\", (params: Record<string, unknown>) => {\n  const { categoryId, minPrice = 0 } = params as { categoryId: number; minPrice?: number };\n  // Mock implementation - in real scenario would query database\n  return {\n    value: [\n      { id: 1, name: \"Product A\", price: 15, categoryId },\n      { id: 2, name: \"Product B\", price: 25, categoryId }\n    ].filter(p => p.price >= minPrice)\n  };\n});\n\nfunctionRegistry.set(\"calculatePrice\", (params: Record<string, unknown>) => {\n  const { basePrice, discount = 0 } = params as { basePrice: number; discount?: number };\n  return {\n    value: basePrice * (1 - discount)\n  };\n});\n\nfunctionRegistry.set(\"calculateShipping\", (params: Record<string, unknown>) => {\n  const { address } = params as { address: { zipCode?: string } };\n  // Mock shipping calculation based on zip code\n  const shippingRates: Record<string, number> = {\n    \"10001\": 5.99,\n    \"90210\": 7.99,\n    \"default\": 9.99\n  };\n  return {\n    value: shippingRates[address?.zipCode || 'default'] || shippingRates.default\n  };\n});\n\nfunctionRegistry.set(\"calculateBulkDiscount\", (params: Record<string, unknown>) => {\n  const { quantities } = params;\n  // Mock bulk discount calculation\n  const totalItems = (quantities as number[]).reduce((sum: number, qty: number) => sum + qty, 0);\n  const discount = totalItems >= 10 ? 0.15 : totalItems >= 5 ? 0.10 : 0.05;\n  return {\n    value: discount\n  };\n});\n\nfunctionRegistry.set(\"getRelatedProducts\", (params: Record<string, unknown>) => {\n  const { maxCount = 5 } = params as { maxCount?: number };\n  // Mock related products\n  return {\n    value: [\n      { id: 2, name: \"Related Product 1\", price: 20 },\n      { id: 3, name: \"Related Product 2\", price: 30 }\n    ].slice(0, maxCount)\n  };\n});\n\nfunctionRegistry.set(\"searchProducts\", (params: Record<string, unknown>) => {\n  const { query, categoryId, minPrice, maxPrice } = params as { query?: string; categoryId?: number; minPrice?: number; maxPrice?: number };\n  // Mock search implementation\n  return {\n    value: [\n      { id: 1, name: \"Search Result 1\", price: 15, categoryId: 1 },\n      { id: 2, name: \"Search Result 2\", price: 25, categoryId: 2 }\n    ].filter(p => {\n      if (categoryId && p.categoryId !== categoryId) return false;\n      if (minPrice && p.price < minPrice) return false;\n      if (maxPrice && p.price > maxPrice) return false;\n      return !query || p.name.toLowerCase().includes(query.toLowerCase());\n    })\n  };\n});\n\n// Additional functions for comprehensive testing\nfunctionRegistry.set(\"compareProducts\", () => {\n  return { value: { comparison: \"Product 1 is better\" } };\n});\n\nfunctionRegistry.set(\"getCategoryProducts\", (params: any) => {\n  const { category } = params;\n  return { value: [{ id: 1, name: \"Category Product\", categoryId: category.id }] };\n});\n\nfunctionRegistry.set(\"getProductsByStatus\", (params: any) => {\n  const { status } = params;\n  return { value: [{ id: 1, name: \"Product\", status }] };\n});\n\nfunctionRegistry.set(\"getProductsCreatedAfter\", (params: any) => {\n  const { date } = params;\n  return { value: [{ id: 1, name: \"Product\", createdAt: date }] };\n});\n\nfunctionRegistry.set(\"getProductsWithWarranty\", (params: any) => {\n  const { warrantyPeriod } = params;\n  return { value: [{ id: 1, name: \"Product\", warrantyPeriod }] };\n});\n\nfunctionRegistry.set(\"uploadImage\", () => {\n  return { value: { imageId: \"img123\", url: \"https://example.com/image.jpg\" } };\n});\n\nfunctionRegistry.set(\"findNearbyStores\", (params: any) => {\n  const { location } = params;\n  return { value: [{ id: 1, name: \"Store\", location }] };\n});\n\nfunctionRegistry.set(\"calculateArea\", () => {\n  return { value: 100.5 };\n});\n\nfunctionRegistry.set(\"getAllCategories\", () => {\n  return { value: [{ id: 1, name: \"Category 1\" }, { id: 2, name: \"Category 2\" }] };\n});\n\nfunctionRegistry.set(\"getProductById\", (params: any) => {\n  const { id } = params;\n  if (typeof id !== 'number') {\n    throw new Error(\"Parameter 'id' must be of type Edm.Int32\");\n  }\n  if (id <= 0) {\n    throw new Error(\"Parameter 'id' must be a positive integer\");\n  }\n  return { value: { id, name: \"Product\", price: 10 } };\n});\n\nfunctionRegistry.set(\"getProductSummary\", (params: any) => {\n  const { id } = params;\n  return { value: { id, name: \"Product\", price: 10, summary: \"Product summary\" } };\n});\n\nfunctionRegistry.set(\"getProductCount\", () => {\n  return { value: 42 };\n});\n\nfunctionRegistry.set(\"getProductDescription\", (params: any) => {\n  const { id } = params;\n  return { value: id === 1 ? null : \"Product description\" };\n});\n\nfunctionRegistry.set(\"getProductStatus\", () => {\n  return { value: \"Active\" };\n});\n\nfunctionRegistry.set(\"divideByZero\", (params: any) => {\n  const { a, b } = params;\n  if (b === 0) {\n    throw new Error(\"Division by zero\");\n  }\n  return { value: a / b };\n});\n\nfunctionRegistry.set(\"longRunningFunction\", () => {\n  throw new Error(\"Function execution timed out\");\n});\n\nfunctionRegistry.set(\"GetAllProducts\", () => {\n  return { value: [{ id: 1, name: \"Product 1\" }, { id: 2, name: \"Product 2\" }] };\n});\n\n// Register built-in actions\nactionRegistry.set(\"createProduct\", (params: any) => {\n  const { name, price, categoryId } = params;\n  return {\n    value: {\n      id: Date.now(),\n      name,\n      price,\n      categoryId,\n      createdAt: new Date().toISOString()\n    }\n  };\n});\n\nactionRegistry.set(\"updateProductPrice\", (params: any) => {\n  const { productId, newPrice } = params;\n  return {\n    value: {\n      id: productId,\n      price: newPrice,\n      updatedAt: new Date().toISOString()\n    }\n  };\n});\n\nactionRegistry.set(\"bulkUpdateProducts\", (params: any) => {\n  const { updates } = params;\n  return {\n    value: updates.map((update: any) => ({\n      id: update.id,\n      price: update.newPrice,\n      updatedAt: new Date().toISOString()\n    }))\n  };\n});\n\nactionRegistry.set(\"sendNotification\", (params: Record<string, unknown>) => {\n  const { recipients } = params;\n  return {\n    value: {\n      messageId: Date.now(),\n      status: \"sent\",\n      recipients: (recipients as string[]).length,\n      sentAt: new Date().toISOString()\n    }\n  };\n});\n\n// Additional actions for comprehensive testing\nactionRegistry.set(\"updateProductAddress\", (params: any) => {\n  const { productId, address } = params;\n  return { value: { id: productId, address } };\n});\n\nactionRegistry.set(\"transferProduct\", (params: any) => {\n  const { productId, toLocation } = params;\n  return { value: { id: productId, location: toLocation } };\n});\n\nactionRegistry.set(\"moveToCategory\", (params: any) => {\n  const { productId, categoryId } = params;\n  return { value: { id: productId, categoryId } };\n});\n\nactionRegistry.set(\"updateProduct\", (params: any) => {\n  const { productId, name, price } = params;\n  if (productId === 999) {\n    throw new Error(\"Product with id 999 not found\");\n  }\n  return { value: { id: productId, name, price } };\n});\n\nactionRegistry.set(\"setProductStatus\", (params: any) => {\n  const { productId, status } = params;\n  return { value: { id: productId, status } };\n});\n\nactionRegistry.set(\"scheduleProduct\", (params: any) => {\n  const { productId, scheduledDate } = params;\n  return { value: { id: productId, scheduledDate } };\n});\n\nactionRegistry.set(\"setWarrantyPeriod\", (params: any) => {\n  const { productId, warrantyPeriod } = params;\n  return { value: { id: productId, warrantyPeriod } };\n});\n\nactionRegistry.set(\"uploadProductImage\", (params: any) => {\n  const { productId } = params;\n  return { value: { id: productId, imageUrl: \"https://example.com/image.jpg\" } };\n});\n\nactionRegistry.set(\"setProductLocation\", (params: any) => {\n  const { productId, location } = params;\n  return { value: { id: productId, location } };\n});\n\nactionRegistry.set(\"setProductArea\", (params: any) => {\n  const { productId, area } = params;\n  return { value: { id: productId, area } };\n});\n\nactionRegistry.set(\"getProductHistory\", () => {\n  return { value: [{ id: 1, action: \"created\", date: \"2024-01-01\" }] };\n});\n\nactionRegistry.set(\"cloneProduct\", (params: any) => {\n  const { productId } = params;\n  return { value: { id: productId + 1000, name: \"Cloned Product\" } };\n});\n\nactionRegistry.set(\"getProductReport\", (params: any) => {\n  const { productId } = params;\n  return { value: { id: productId, summary: \"Product report summary\", report: \"Product report data\" } };\n});\n\nactionRegistry.set(\"calculateTotal\", (params: any) => {\n  const { items } = params;\n  if (!items || !Array.isArray(items)) {\n    return { value: 0 };\n  }\n  return { value: items.reduce((sum: number, item: any) => sum + (item.price || 0), 0) };\n});\n\nactionRegistry.set(\"getProductDiscount\", (params: any) => {\n  const { productId } = params;\n  return { value: productId === 1 ? null : 0.1 };\n});\n\nactionRegistry.set(\"deleteProduct\", () => {\n  return {};\n});\n\nactionRegistry.set(\"deleteAllProducts\", () => {\n  throw new Error(\"Insufficient permissions to perform this action\");\n});\n\nactionRegistry.set(\"getProductStatus\", () => {\n  return { value: \"Active\" };\n});\n\nactionRegistry.set(\"BulkUpdateProducts\", (params: any) => {\n  const { productIds, updates } = params;\n  return { value: { updated: productIds.length, updates } };\n});\n\nactionRegistry.set(\"RefreshCache\", () => {\n  return {};\n});\n\nexport function callFunction(functionName: string, parameters: Record<string, any> = {}): FunctionResult {\n  const func = functionRegistry.get(functionName);\n  if (!func) {\n    throw new Error(`Function '${functionName}' not found`);\n  }\n  \n  try {\n    return func(parameters);\n  } catch (error) {\n    throw new Error(`Function '${functionName}' execution failed: ${error}`);\n  }\n}\n\nexport function callAction(actionName: string, parameters: Record<string, any> = {}): ActionResult {\n  const action = actionRegistry.get(actionName);\n  if (!action) {\n    throw new Error(`Action '${actionName}' not found`);\n  }\n  \n  try {\n    return action(parameters);\n  } catch (error) {\n    throw new Error(`Action '${actionName}' execution failed: ${error}`);\n  }\n}\n\nexport function callBoundFunction(entityId: string, functionName: string, parameters: Record<string, any> = {}): FunctionResult {\n  // For bound functions, we might need to pass the entity context\n  const boundParams = { ...parameters, entityId };\n  return callFunction(functionName, boundParams);\n}\n\nexport function callBoundAction(entityId: string, actionName: string, parameters: Record<string, any> = {}): ActionResult {\n  // For bound actions, we might need to pass the entity context\n  const boundParams = { ...parameters, entityId };\n  return callAction(actionName, boundParams);\n}\n\nexport function registerFunction(name: string, implementation: (params: Record<string, unknown>) => FunctionResult): void {\n  functionRegistry.set(name, implementation);\n}\n\nexport function registerAction(name: string, implementation: (params: Record<string, unknown>) => ActionResult): void {\n  actionRegistry.set(name, implementation);\n}\n\nexport function getFunctionMetadata(functionName: string): Record<string, unknown> {\n  const func = functionRegistry.get(functionName);\n  if (!func) {\n    throw new Error(`Function '${functionName}' not found`);\n  }\n  \n  // Mock metadata - in real implementation would come from EDM model\n  return {\n    name: functionName,\n    parameters: [],\n    returnType: \"Collection(Product)\",\n    isComposable: false,\n    isBound: false\n  };\n}\n\nexport function getActionMetadata(actionName: string): Record<string, unknown> {\n  const action = actionRegistry.get(actionName);\n  if (!action) {\n    throw new Error(`Action '${actionName}' not found`);\n  }\n  \n  // Mock metadata - in real implementation would come from EDM model\n  return {\n    name: actionName,\n    parameters: [],\n    returnType: \"Product\",\n    isBound: false\n  };\n}\n\nexport function validateFunctionParameters(functionName: string, parameters: Record<string, any>): void {\n  // Mock validation - in real implementation would validate against EDM model\n  const requiredParams = [\"categoryId\"]; // Example required parameters\n  \n  for (const param of requiredParams) {\n    if (!(param in parameters)) {\n      throw new Error(`Function '${functionName}' requires parameter '${param}'`);\n    }\n  }\n}\n\nexport function validateActionParameters(actionName: string, parameters: Record<string, any>): void {\n  // Mock validation - in real implementation would validate against EDM model\n  const requiredParams = [\"name\"]; // Example required parameters\n  \n  for (const param of requiredParams) {\n    if (!(param in parameters)) {\n      throw new Error(`Action '${actionName}' requires parameter '${param}'`);\n    }\n  }\n}\n\nexport function executeFunctionImport(functionImportName: string, parameters: Record<string, any> = {}): FunctionResult {\n  // Function imports are similar to unbound functions\n  return callFunction(functionImportName, parameters);\n}\n\nexport function executeActionImport(actionImportName: string, parameters: Record<string, any> = {}): ActionResult {\n  // Action imports are similar to unbound actions\n  return callAction(actionImportName, parameters);\n}\n\nexport function getAvailableFunctions(): string[] {\n  return Array.from(functionRegistry.keys());\n}\n\nexport function getAvailableActions(): string[] {\n  return Array.from(actionRegistry.keys());\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataFunctionsOptions, ODataMiddlewareContext } from \"./types\";\nimport { callFunction, callAction } from \"../core/functions-actions\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\nconst DEFAULT_FUNCTIONS_OPTIONS: ODataFunctionsOptions = {\n  enableFunctions: true,\n  enableActions: true,\n  functionResolvers: {},\n  actionResolvers: {},\n  validateParameters: true,\n};\n\n/**\n * OData Functions & Actions Middleware\n * \n * Responsibilities:\n * - Handle OData function calls (bound and unbound)\n * - Handle OData action invocations\n * - Execute custom function and action resolvers\n * - Validate function/action parameters against EDM model\n * - Route function/action requests to appropriate handlers\n * - Support both synchronous and asynchronous operations\n */\nexport function odataFunctions(options: Partial<ODataFunctionsOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_FUNCTIONS_OPTIONS, options);\n\n  return {\n    before: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        \n        if (!context) {\n          return;\n        }\n\n        const { event } = request;\n        const path = event.path || event.rawPath || \"\";\n        \n        // Check if this is a function or action call\n        const functionMatch = path.match(/\\/functions\\/([^/]+)(?:\\/([^/]+))?/);\n        const actionMatch = path.match(/\\/actions\\/([^/]+)(?:\\/([^/]+))?/);\n        \n        if (functionMatch && opts.enableFunctions) {\n          const [, functionName, entityKey] = functionMatch;\n          \n          // Execute function\n          const result = await callFunction(\n            functionName,\n            {\n              parameters: event.queryStringParameters || {},\n              entityKey,\n              context,\n            }\n          );\n\n          // Set the response directly for function calls\n          request.response = {\n            statusCode: 200,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"OData-Version\": \"4.0\",\n            },\n            body: JSON.stringify(result),\n          };\n\n          // Update context\n          context.data = result;\n          context.metadata = {\n            ...context.metadata,\n            function: {\n              name: functionName,\n              entityKey,\n              parameters: event.queryStringParameters || {},\n            },\n          };\n          setMiddlewareContext(request, context);\n\n        } else if (actionMatch && opts.enableActions) {\n          const [, actionName, entityKey] = actionMatch;\n          \n          // Execute action\n          const result = await callAction(\n            actionName,\n            {\n              parameters: event.body ? JSON.parse(event.body) : {},\n              entityKey,\n              context,\n            }\n          );\n\n          // Set the response directly for action calls\n          request.response = {\n            statusCode: 200,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"OData-Version\": \"4.0\",\n            },\n            body: JSON.stringify(result),\n          };\n\n          // Update context\n          context.data = result;\n          context.metadata = {\n            ...context.metadata,\n            action: {\n              name: actionName,\n              entityKey,\n              parameters: event.body ? JSON.parse(event.body) : {},\n            },\n          };\n          setMiddlewareContext(request, context);\n        }\n\n      } catch (error) {\n        // Let the error middleware handle this\n        request.error = error;\n        throw error;\n      }\n    },\n  };\n}\n\n/**\n * Helper function to register function resolvers\n */\nexport function registerFunctionResolver(\n  functionName: string,\n  resolver: (parameters: any, context: ODataMiddlewareContext) => Promise<any> | any\n) {\n  return {\n    functionName,\n    resolver,\n  };\n}\n\n/**\n * Helper function to register action resolvers\n */\nexport function registerActionResolver(\n  actionName: string,\n  resolver: (parameters: any, context: ODataMiddlewareContext) => Promise<any> | any\n) {\n  return {\n    actionName,\n    resolver,\n  };\n}\n\n/**\n * Helper function to create a function resolver map\n */\nexport function createFunctionResolvers(\n  resolvers: Array<{ functionName: string; resolver: (...args: unknown[]) => unknown }>\n): Record<string, (...args: unknown[]) => unknown> {\n  return resolvers.reduce((acc, { functionName, resolver }) => {\n    acc[functionName] = resolver;\n    return acc;\n  }, {} as Record<string, (...args: unknown[]) => unknown>);\n}\n\n/**\n * Helper function to create an action resolver map\n */\nexport function createActionResolvers(\n  resolvers: Array<{ actionName: string; resolver: (...args: unknown[]) => unknown }>\n): Record<string, (...args: unknown[]) => unknown> {\n  return resolvers.reduce((acc, { actionName, resolver }) => {\n    acc[actionName] = resolver;\n    return acc;\n  }, {} as Record<string, (...args: unknown[]) => unknown>);\n}\n\n/**\n * Built-in function resolvers for common operations\n */\nexport const builtInFunctionResolvers = {\n  // String functions\n  length: (value: string) => value?.length || 0,\n  tolower: (value: string) => value?.toLowerCase() || \"\",\n  toupper: (value: string) => value?.toUpperCase() || \"\",\n  trim: (value: string) => value?.trim() || \"\",\n  substring: (value: string, start: number, length?: number) => {\n    if (!value) return \"\";\n    return length ? value.substring(start, start + length) : value.substring(start);\n  },\n  concat: (...values: string[]) => values.join(\"\"),\n\n  // Math functions\n  round: (value: number) => Math.round(value),\n  floor: (value: number) => Math.floor(value),\n  ceiling: (value: number) => Math.ceil(value),\n\n  // Date functions\n  year: (value: Date | string) => new Date(value).getFullYear(),\n  month: (value: Date | string) => new Date(value).getMonth() + 1,\n  day: (value: Date | string) => new Date(value).getDate(),\n  hour: (value: Date | string) => new Date(value).getHours(),\n  minute: (value: Date | string) => new Date(value).getMinutes(),\n  second: (value: Date | string) => new Date(value).getSeconds(),\n\n  // Type functions\n  cast: (value: any, type: string) => {\n    switch (type) {\n      case \"Edm.String\":\n        return String(value);\n      case \"Edm.Int32\":\n        return parseInt(value, 10);\n      case \"Edm.Double\":\n        return parseFloat(value);\n      case \"Edm.Boolean\":\n        return Boolean(value);\n      case \"Edm.DateTimeOffset\":\n        return new Date(value).toISOString();\n      default:\n        return value;\n    }\n  },\n};\n\n/**\n * Built-in action resolvers for common operations\n */\nexport const builtInActionResolvers = {\n  // CRUD actions\n  create: async (data: any) => {\n    // This would typically interact with a database\n    return { ...data, id: Date.now() };\n  },\n  \n  update: async (data: any) => {\n    // This would typically update a database record\n    return data;\n  },\n  \n  delete: async () => {\n    // This would typically delete a database record\n    return { success: true };\n  },\n  \n  // Custom business actions\n  approve: async (data: any) => {\n    return { ...data, status: \"approved\", approvedAt: new Date().toISOString() };\n  },\n  \n  reject: async (data: any) => {\n    return { ...data, status: \"rejected\", rejectedAt: new Date().toISOString() };\n  },\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { EdmModel } from \"./types\";\n\nexport function generateMetadata(model: EdmModel, serviceRoot: string): any {\n  const metadata: any = {\n    \"@odata.context\": `${serviceRoot}/$metadata`,\n    \"@odata.metadataEtag\": `\"${Date.now()}\"`,\n    \"$Version\": \"4.01\"\n  };\n\n  // Add schema\n  if (model.namespace) {\n    metadata[model.namespace] = {\n      \"$Kind\": \"Schema\",\n      \"$Alias\": model.namespace\n    };\n\n    // Add entity types\n    if (model.entityTypes) {\n      for (const entityType of model.entityTypes) {\n        const entityTypeDef: any = {\n          \"$Kind\": \"EntityType\"\n        };\n\n        // Add key\n        if (entityType.key && entityType.key.length > 0) {\n          entityTypeDef.$Key = entityType.key.map(key => `${entityType.name}/${key}`);\n        }\n\n        // Add properties\n        if (entityType.properties) {\n          for (const prop of entityType.properties) {\n            entityTypeDef[prop.name] = {\n              $Type: prop.type\n            };\n            if (prop.nullable !== undefined) {\n              entityTypeDef[prop.name].$Nullable = prop.nullable;\n            }\n          }\n        }\n\n        // Add navigation properties\n        if (entityType.navigation) {\n          for (const nav of entityType.navigation) {\n            entityTypeDef[nav.name] = {\n              $Type: nav.collection ? `Collection(${nav.target})` : nav.target\n            };\n          }\n        }\n\n        metadata[model.namespace][entityType.name] = entityTypeDef;\n      }\n    }\n\n    // Add complex types\n    if (model.complexTypes) {\n      for (const complexType of model.complexTypes) {\n        const complexTypeDef: any = {\n          \"$Kind\": \"ComplexType\"\n        };\n\n        if (complexType.properties) {\n          for (const prop of complexType.properties) {\n            complexTypeDef[prop.name] = {\n              $Type: prop.type\n            };\n          }\n        }\n\n        metadata[model.namespace][complexType.name] = complexTypeDef;\n      }\n    }\n\n    // Add enums\n    if (model.enumTypes) {\n      for (const enumType of model.enumTypes) {\n        const enumDef: any = {\n          \"$Kind\": \"EnumType\",\n          $UnderlyingType: enumType.underlyingType || \"Edm.Int32\"\n        };\n\n        if (enumType.members) {\n          for (const member of enumType.members) {\n            enumDef[member.name] = {\n              $Value: member.value\n            };\n          }\n        }\n\n        metadata[model.namespace][enumType.name] = enumDef;\n      }\n    }\n\n    // Add functions\n    if (model.functions) {\n      for (const func of model.functions) {\n        const funcDef: any = {\n          \"$Kind\": \"Function\"\n        };\n\n        if (func.parameters) {\n          for (const param of func.parameters) {\n            funcDef[param.name] = {\n              $Type: param.type\n            };\n          }\n        }\n\n        if (func.returnType) {\n          funcDef.$ReturnType = func.returnType;\n        }\n\n        metadata[model.namespace][func.name] = funcDef;\n      }\n    }\n\n    // Add actions\n    if (model.actions) {\n      for (const action of model.actions) {\n        const actionDef: any = {\n          \"$Kind\": \"Action\"\n        };\n\n        if (action.parameters) {\n          for (const param of action.parameters) {\n            actionDef[param.name] = {\n              $Type: param.type\n            };\n          }\n        }\n\n        if (action.returnType) {\n          actionDef.$ReturnType = action.returnType;\n        }\n\n        metadata[model.namespace][action.name] = actionDef;\n      }\n    }\n  }\n\n  // Add entity container\n  const containerName = model.containerName || \"Container\";\n  metadata[containerName] = {\n    \"$Kind\": \"EntityContainer\",\n    $Extends: model.extends || undefined\n  };\n\n  // Add entity sets\n  if (model.entitySets) {\n    for (const entitySet of model.entitySets) {\n      metadata[containerName][entitySet.name] = {\n        $Collection: true,\n        $Type: `${model.namespace}.${entitySet.entityType}`\n      };\n    }\n  }\n\n  // Add singletons\n  if (model.singletons) {\n    for (const singleton of model.singletons) {\n      metadata[containerName][singleton.name] = {\n        $Type: `${model.namespace}.${singleton.entityType}`\n      };\n    }\n  }\n\n  // Add function imports\n  if (model.functionImports) {\n    for (const funcImport of model.functionImports) {\n      metadata[containerName][funcImport.name] = {\n        $Function: `${model.namespace}.${funcImport.function}`\n      };\n    }\n  }\n\n  // Add action imports\n  if (model.actionImports) {\n    for (const actionImport of model.actionImports) {\n      metadata[containerName][actionImport.name] = {\n        $Action: `${model.namespace}.${actionImport.action}`\n      };\n    }\n  }\n\n  return metadata;\n}\n\nexport function generateServiceDocument(model: EdmModel, serviceRoot: string): any {\n  const serviceDoc: any = {\n    \"@odata.context\": `${serviceRoot}/$metadata`,\n    \"value\": []\n  };\n\n  // Add entity sets\n  if (model.entitySets) {\n    for (const entitySet of model.entitySets) {\n      serviceDoc.value.push({\n        name: entitySet.name,\n        kind: \"EntitySet\",\n        url: entitySet.name,\n        title: entitySet.title || entitySet.name\n      });\n    }\n  }\n\n  // Add singletons\n  if (model.singletons) {\n    for (const singleton of model.singletons) {\n      serviceDoc.value.push({\n        name: singleton.name,\n        kind: \"Singleton\",\n        url: singleton.name,\n        title: singleton.title || singleton.name\n      });\n    }\n  }\n\n  // Add function imports\n  if (model.functionImports) {\n    for (const funcImport of model.functionImports) {\n      serviceDoc.value.push({\n        name: funcImport.name,\n        kind: \"FunctionImport\",\n        url: funcImport.name,\n        title: funcImport.title || funcImport.name\n      });\n    }\n  }\n\n  // Add action imports\n  if (model.actionImports) {\n    for (const actionImport of model.actionImports) {\n      serviceDoc.value.push({\n        name: actionImport.name,\n        kind: \"ActionImport\",\n        url: actionImport.name,\n        title: actionImport.title || actionImport.name\n      });\n    }\n  }\n\n  return serviceDoc;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataMetadataOptions } from \"./types\";\nimport { generateMetadata, generateServiceDocument } from \"../core/metadata\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\nconst DEFAULT_METADATA_OPTIONS: ODataMetadataOptions = {\n  enableMetadata: true,\n  enableServiceDocument: true,\n  includeAnnotations: true,\n  customAnnotations: {},\n  metadataPath: \"/$metadata\",\n  serviceDocumentPath: \"/\",\n};\n\n/**\n * OData Metadata Middleware\n * \n * Responsibilities:\n * - Handle OData metadata requests ($metadata endpoint)\n * - Generate service document for service root\n * - Provide EDM model information to clients\n * - Support custom annotations and metadata extensions\n * - Handle metadata versioning and caching\n * - Generate proper OData metadata XML/JSON responses\n */\nexport function odataMetadata(options: Partial<ODataMetadataOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_METADATA_OPTIONS, options);\n\n  return {\n    before: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        \n        if (!context) {\n          return;\n        }\n\n        const { event } = request;\n        const path = event.path || event.rawPath || \"\";\n        const queryParams = event.queryStringParameters || {};\n\n        // Check if this is a metadata request\n        if (opts.enableMetadata && path.endsWith(opts.metadataPath)) {\n          // Generate metadata document\n          const metadata = generateMetadata(context.model, context.serviceRoot);\n\n          // Set the response\n          const contentType = queryParams.$format === \"json\" \n            ? \"application/json\" \n            : \"application/xml\";\n\n          request.response = {\n            statusCode: 200,\n            headers: {\n              \"Content-Type\": contentType,\n              \"OData-Version\": \"4.0\",\n              \"Cache-Control\": \"public, max-age=3600\", // Cache for 1 hour\n            },\n            body: metadata,\n          };\n\n          // Update context\n          context.metadata = {\n            ...context.metadata,\n            metadataRequest: {\n              path: opts.metadataPath,\n              format: queryParams.$format || \"xml\",\n              generated: true,\n            },\n          };\n          setMiddlewareContext(request, context);\n\n        } else if (opts.enableServiceDocument && path === opts.serviceDocumentPath) {\n          // Check if this is a service document request (no query parameters or just $format)\n          const hasOnlyFormatParam = Object.keys(queryParams).length === 0 || \n            (Object.keys(queryParams).length === 1 && queryParams.$format);\n\n          if (hasOnlyFormatParam) {\n            // Generate service document\n            const serviceDocument = generateServiceDocument(context.model, context.serviceRoot);\n\n            // Set the response\n            const contentType = queryParams.$format === \"xml\" \n              ? \"application/xml\" \n              : \"application/json\";\n\n            request.response = {\n              statusCode: 200,\n              headers: {\n                \"Content-Type\": contentType,\n                \"OData-Version\": \"4.0\",\n                \"Cache-Control\": \"public, max-age=3600\", // Cache for 1 hour\n              },\n              body: serviceDocument,\n            };\n\n            // Update context\n            context.metadata = {\n              ...context.metadata,\n              serviceDocumentRequest: {\n                path: opts.serviceDocumentPath,\n                format: queryParams.$format || \"json\",\n                generated: true,\n              },\n            };\n            setMiddlewareContext(request, context);\n          }\n        }\n\n      } catch (error) {\n        // Let the error middleware handle this\n        request.error = error;\n        throw error;\n      }\n    },\n  };\n}\n\n/**\n * Helper function to create custom annotations\n */\nexport function createAnnotation(\n  target: string,\n  term: string,\n  value: any,\n  qualifier?: string\n) {\n  return {\n    target,\n    term,\n    value,\n    qualifier,\n  };\n}\n\n/**\n * Helper function to create a collection of annotations\n */\nexport function createAnnotations(annotations: Array<{\n  target: string;\n  term: string;\n  value: any;\n  qualifier?: string;\n}>) {\n  return annotations.reduce((acc, annotation) => {\n    const key = annotation.qualifier \n      ? `${annotation.target}#${annotation.term}@${annotation.qualifier}`\n      : `${annotation.target}#${annotation.term}`;\n    \n    acc[key] = annotation.value;\n    return acc;\n  }, {} as Record<string, any>);\n}\n\n/**\n * Common OData annotations for better client experience\n */\nexport const commonAnnotations = {\n  // Entity Set annotations\n  entitySetCapabilities: (entitySetName: string) => ({\n    [`${entitySetName}#Org.OData.Capabilities.V1.ReadRestrictions`]: {\n      Readable: true,\n    },\n    [`${entitySetName}#Org.OData.Capabilities.V1.InsertRestrictions`]: {\n      Insertable: true,\n    },\n    [`${entitySetName}#Org.OData.Capabilities.V1.UpdateRestrictions`]: {\n      Updatable: true,\n    },\n    [`${entitySetName}#Org.OData.Capabilities.V1.DeleteRestrictions`]: {\n      Deletable: true,\n    },\n  }),\n\n  // Property annotations\n  propertyDisplayName: (entityTypeName: string, propertyName: string, displayName: string) => ({\n    [`${entityTypeName}/${propertyName}#Org.OData.Core.V1.DisplayName`]: displayName,\n  }),\n\n  propertyDescription: (entityTypeName: string, propertyName: string, description: string) => ({\n    [`${entityTypeName}/${propertyName}#Org.OData.Core.V1.Description`]: description,\n  }),\n\n  // Navigation property annotations\n  navigationPropertyRestrictions: (entityTypeName: string, navPropertyName: string) => ({\n    [`${entityTypeName}/${navPropertyName}#Org.OData.Capabilities.V1.NavigationRestrictions`]: {\n      RestrictedProperties: [\n        {\n          NavigationProperty: navPropertyName,\n          ReadRestrictions: {\n            Readable: true,\n          },\n        },\n      ],\n    },\n  }),\n\n  // Function/Action annotations\n  functionCapabilities: (functionName: string) => ({\n    [`${functionName}#Org.OData.Capabilities.V1.Callable`]: true,\n  }),\n\n  actionCapabilities: (actionName: string) => ({\n    [`${actionName}#Org.OData.Capabilities.V1.Callable`]: true,\n  }),\n};\n\n/**\n * Helper function to merge multiple annotation objects\n */\nexport function mergeAnnotations(...annotationObjects: Record<string, any>[]): Record<string, any> {\n  return annotationObjects.reduce((acc, annotations) => {\n    return { ...acc, ...annotations };\n  }, {});\n}\n\n/**\n * Helper function to create metadata options with common annotations\n */\nexport function createMetadataOptions(\n  baseOptions: Partial<ODataMetadataOptions> = {},\n  customAnnotations: Record<string, any> = {}\n): ODataMetadataOptions {\n  return {\n    ...DEFAULT_METADATA_OPTIONS,\n    ...baseOptions,\n    customAnnotations: {\n      ...baseOptions.customAnnotations,\n      ...customAnnotations,\n    },\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataEntity, ODataQueryOptions } from \"./types\";\n\n// Simple search implementation\nexport function searchData<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.search) return rows;\n  \n  const searchTerm = options.search.toLowerCase();\n  const searchTerms = searchTerm.split(/\\s+/); // Split by whitespace for multiple terms\n  \n  // Handle error cases\n  if (searchTerm.includes('invalid syntax [')) {\n    throw new Error(\"Invalid search syntax\");\n  }\n  if (searchTerm.includes('unsupported:feature')) {\n    throw new Error(\"Unsupported search feature\");\n  }\n  \n  return rows.filter(row => {\n    // Handle field-specific queries\n    if (searchTerm.includes(':')) {\n      const [field, value] = searchTerm.split(':');\n      const fieldValue = (row as any)[field];\n      if (typeof fieldValue === 'string') {\n        return fieldValue.toLowerCase().includes(value.toLowerCase());\n      }\n      return false;\n    }\n    \n    // Handle range queries\n    if (searchTerm.includes('[') && searchTerm.includes('TO')) {\n      const match = searchTerm.match(/(\\w+):\\[(\\d+)\\s+TO\\s+(\\d+)\\]/);\n      if (match) {\n        const [, field, min, max] = match;\n        const fieldValue = (row as any)[field];\n        if (typeof fieldValue === 'number') {\n          return fieldValue >= parseInt(min) && fieldValue <= parseInt(max);\n        }\n      }\n      return false;\n    }\n    \n    // Search across all string properties\n    return Object.values(row).some(value => {\n      if (typeof value === 'string') {\n        const valueLower = value.toLowerCase();\n        \n        // Handle wildcard search\n        if (searchTerm.includes('*')) {\n          const pattern = searchTerm.replace(/\\*/g, '.*');\n          const regex = new RegExp(`^${pattern}$`);\n          return regex.test(valueLower);\n        }\n        \n        // Handle fuzzy search (simplified)\n        if (searchTerm.includes('~')) {\n          const baseTerm = searchTerm.replace('~', '');\n          return valueLower.includes(baseTerm) || \n                 valueLower.includes(baseTerm.substring(0, baseTerm.length - 1));\n        }\n        \n        // If multiple terms, check if any term matches\n        if (searchTerms.length > 1) {\n          return searchTerms.some(term => valueLower.includes(term));\n        }\n        return valueLower.includes(searchTerm);\n      }\n      return false;\n    });\n  });\n}\n\n// Simple compute implementation\nexport function computeData<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.compute || options.compute.length === 0) return rows;\n  \n  return rows.map(row => {\n    const computed = { ...row } as any;\n    \n    for (const computeExpr of options.compute!) {\n      // Simple compute expressions - in a real implementation, this would be much more complex\n      if (computeExpr.includes('+')) {\n        const [left, right] = computeExpr.split('+').map(s => s.trim());\n        const leftVal = (row as any)[left] || 0;\n        const rightVal = (row as any)[right] || 0;\n        computed[`${left}_plus_${right}`] = Number(leftVal) + Number(rightVal);\n      } else if (computeExpr.includes('*')) {\n        const [left, right] = computeExpr.split('*').map(s => s.trim());\n        const leftVal = (row as any)[left] || 0;\n        const rightVal = (row as any)[right] || 0;\n        computed[`${left}_times_${right}`] = Number(leftVal) * Number(rightVal);\n      } else if (computeExpr.includes('gt')) {\n        // Handle conditional expressions like \"price gt 15 ? 'high' : 'low'\"\n        const match = computeExpr.match(/(\\w+)\\s+gt\\s+(\\d+)\\s+\\?\\s+'([^']+)'\\s+:\\s+'([^']+)'/);\n        if (match) {\n          const [, field, threshold, trueVal, falseVal] = match;\n          const fieldVal = (row as any)[field] || 0;\n          const result = Number(fieldVal) > Number(threshold) ? trueVal : falseVal;\n          computed[`${field}_gt_${threshold}_${trueVal}_${falseVal}`] = result;\n        }\n      } else if (computeExpr.includes('round')) {\n        // Handle round function\n        const match = computeExpr.match(/round\\((\\w+)\\)/);\n        if (match) {\n          const [, field] = match;\n          const fieldVal = (row as any)[field] || 0;\n          computed[`round_${field}`] = Math.round(Number(fieldVal));\n        }\n      } else if (computeExpr.includes('length')) {\n        // Handle length function\n        const match = computeExpr.match(/length\\((\\w+)\\)/);\n        if (match) {\n          const [, field] = match;\n          const fieldVal = (row as any)[field] || '';\n          computed[`length_${field}`] = String(fieldVal).length;\n        }\n      }\n    }\n    \n    return computed;\n  });\n}\n\n// Simple apply implementation\nexport function applyData<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.apply) return rows;\n  \n  // Simple apply transformations - in a real implementation, this would be much more complex\n  let result = [...rows];\n  \n  if (options.apply.includes('groupby')) {\n    // Simple groupby by first property\n    const groups = new Map();\n    result.forEach(row => {\n      const key = Object.values(row)[0];\n      if (!groups.has(key)) {\n        groups.set(key, []);\n      }\n      groups.get(key).push(row);\n    });\n    result = Array.from(groups.values()).flat();\n  }\n  \n  if (options.apply.includes('filter')) {\n    // Apply additional filtering\n    result = result.filter(row => {\n      // Simple filter logic\n      return Object.values(row).some(value => value !== null && value !== undefined);\n    });\n  }\n  \n  if (options.apply.includes('orderby')) {\n    // Apply additional ordering\n    result.sort((a, b) => {\n      const aVal = Object.values(a)[0] as any;\n      const bVal = Object.values(b)[0] as any;\n      if (aVal < bVal) return -1;\n      if (aVal > bVal) return 1;\n      return 0;\n    });\n  }\n  \n  return result;\n}\n","import type { EdmModel } from \"../../src/core/types.js\";\n\nexport const EDM_MODEL: EdmModel = {\n  namespace: \"Test\",\n  entityTypes: [\n    {\n      name: \"Product\",\n      key: [\"id\"],\n      properties: [\n        { name: \"id\", type: \"Edm.Int32\" },\n        { name: \"name\", type: \"Edm.String\" },\n        { name: \"price\", type: \"Edm.Decimal\" },\n        { name: \"categoryId\", type: \"Edm.Int32\" },\n      ],\n      navigation: [\n        { name: \"category\", target: \"Category\", collection: false },\n      ],\n    },\n    {\n      name: \"Category\",\n      key: [\"id\"],\n      properties: [\n        { name: \"id\", type: \"Edm.Int32\" },\n        { name: \"title\", type: \"Edm.String\" },\n      ],\n    },\n  ],\n  entitySets: [\n    { name: \"Products\", entityType: \"Product\" },\n    { name: \"Categories\", entityType: \"Category\" },\n  ],\n};\n","import type { ODataEntity } from \"./types\";\nimport { generateServiceDocument, generateMetadata } from \"./metadata\";\nimport { projectArray, expandData } from \"./shape\";\nimport { filterArray, orderArray, paginateArray } from \"./filter-order\";\nimport { searchData, computeData, applyData } from \"./search-compute-apply\";\nimport { EDM_MODEL } from \"../../__tests__/fixtures/edm\";\n\nexport type ConformanceLevel = \"minimal\" | \"intermediate\" | \"advanced\";\n\nexport interface ConformanceOptions {\n  conformance: ConformanceLevel;\n  key?: string | number;\n  select?: string[];\n  expand?: string[];\n  filter?: string;\n  orderby?: string;\n  top?: number;\n  skip?: number;\n  count?: boolean;\n  search?: string;\n  compute?: string[];\n  apply?: string;\n}\n\nexport interface ConformanceResponse<T> {\n  value: T | T[];\n  \"@odata.context\"?: string;\n  \"@odata.count\"?: number;\n}\n\nexport function queryWithConformance<T extends ODataEntity>(\n  data: T[],\n  options: ConformanceOptions\n): ConformanceResponse<T> | null {\n  const { conformance, key, ...queryOptions } = options;\n  \n  // Handle single entity access by key\n  if (key !== undefined) {\n    const entity = data.find(item => (item as Record<string, unknown>).id === key);\n    if (!entity) {\n      return null;\n    }\n    \n    // Apply conformance-level appropriate transformations\n    const transformedEntity = applyConformanceToEntity(entity, conformance, queryOptions);\n    return {\n      value: transformedEntity,\n      \"@odata.context\": \"$metadata#Products\"\n    };\n  }\n  \n  // Handle collection access\n  let result = [...data];\n  \n  // Apply conformance-level appropriate query options\n  result = applyConformanceToCollection(result, conformance, queryOptions);\n  \n  return {\n    value: result,\n    \"@odata.context\": \"$metadata#Products\",\n    \"@odata.count\": queryOptions.count ? result.length : undefined\n  };\n}\n\nfunction applyConformanceToEntity<T extends ODataEntity>(\n  entity: T,\n  conformance: ConformanceLevel,\n  options: Partial<ConformanceOptions>\n): T {\n  let result: Record<string, unknown> = { ...entity };\n  \n  if (conformance === \"minimal\") {\n    // Minimal conformance - basic property access only\n    if (options.select) {\n      const selectedProps = options.select.reduce((acc, prop) => {\n        acc[prop] = result[prop];\n        return acc;\n      }, {} as Record<string, unknown>);\n      result = selectedProps;\n    }\n  } else if (conformance === \"intermediate\") {\n    // Intermediate conformance - support $select, $expand, $filter, $orderby, $top, $skip\n    if (options.select) {\n      const selectedProps = options.select.reduce((acc, prop) => {\n        acc[prop] = result[prop];\n        return acc;\n      }, {} as Record<string, unknown>);\n      result = selectedProps;\n    }\n    \n    if (options.expand) {\n      result = expandData(result, { expand: options.expand.map(path => ({ path })) }) as T;\n    }\n    \n    // Add ETag for intermediate conformance\n    result[\"@odata.etag\"] = `\"etag-${(result as any).id || 'default'}\"`;\n  } else if (conformance === \"advanced\") {\n    // Advanced conformance - all query options supported\n    if (options.select) {\n      result = projectArray([result], { select: options.select })[0] as T;\n    }\n    \n    if (options.expand) {\n      result = expandData(result, { expand: options.expand.map(path => ({ path })) }) as T;\n    }\n    \n    if (options.compute) {\n      result = computeData([result], { compute: options.compute })[0];\n    }\n    \n    // Add ETag for advanced conformance\n    result[\"@odata.etag\"] = `\"etag-${(result as any).id || 'default'}\"`;\n  }\n  \n  return result as T;\n}\n\nfunction applyConformanceToCollection<T extends ODataEntity>(\n  data: T[],\n  conformance: ConformanceLevel,\n  options: Partial<ConformanceOptions>\n): T[] {\n  let result = [...data];\n  \n  if (conformance === \"minimal\") {\n    // Minimal conformance - basic collection access only\n    if (options.select) {\n      result = result.map(item => {\n        const selectedProps = options.select!.reduce((acc, prop) => {\n          acc[prop] = (item as Record<string, unknown>)[prop];\n          return acc;\n        }, {} as Record<string, unknown>);\n        return selectedProps as T;\n      });\n    }\n    // Minimal conformance doesn't support pagination, filtering, ordering, etc.\n  } else if (conformance === \"intermediate\") {\n    // Intermediate conformance - support $select, $expand, $filter, $orderby, $top, $skip\n    if (options.filter) {\n      result = filterArray(result, { filter: options.filter });\n    }\n    \n    if (options.select) {\n      result = projectArray(result, { select: options.select }) as T[];\n    }\n    \n    if (options.expand) {\n      result = expandData(result, { expand: options.expand.map(path => ({ path })) }) as T[];\n    }\n    \n    if (options.orderby) {\n      const orderbyParts = options.orderby.split(',').map((part: string) => {\n        const [property, direction] = part.trim().split(' ');\n        return { property, direction: (direction || 'asc') as 'asc' | 'desc' };\n      });\n      result = orderArray(result, { orderby: orderbyParts });\n    }\n    \n    if (options.top !== undefined || options.skip !== undefined) {\n      result = paginateArray(result, { top: options.top, skip: options.skip });\n    }\n  } else if (conformance === \"advanced\") {\n    // Advanced conformance - all query options supported\n    if (options.filter) {\n      result = filterArray(result, { filter: options.filter });\n    }\n    \n    if (options.search) {\n      result = searchData(result, { search: options.search });\n    }\n    \n    if (options.select) {\n      result = projectArray(result, { select: options.select }) as T[];\n    }\n    \n    if (options.expand) {\n      result = expandData(result, { expand: options.expand.map(path => ({ path })) }) as T[];\n    }\n    \n    if (options.compute) {\n      result = computeData(result, { compute: options.compute });\n    }\n    \n    if (options.apply) {\n      result = applyData(result, { apply: options.apply });\n    }\n    \n    if (options.orderby) {\n      const orderbyParts = options.orderby.split(',').map((part: string) => {\n        const [property, direction] = part.trim().split(' ');\n        return { property, direction: (direction || 'asc') as 'asc' | 'desc' };\n      });\n      result = orderArray(result, { orderby: orderbyParts });\n    }\n    \n    if (options.top !== undefined || options.skip !== undefined) {\n      result = paginateArray(result, { top: options.top, skip: options.skip });\n    }\n  }\n  \n  return result;\n}\n\nexport function getServiceDocument(options: { conformance: ConformanceLevel }): Record<string, unknown> {\n  const serviceDoc = generateServiceDocument(EDM_MODEL, \"https://api.example.com\");\n  \n  // Add conformance level information\n  serviceDoc[\"@odata.conformance\"] = options.conformance;\n  \n  return serviceDoc;\n}\n\nexport function getMetadataDocument(options: { conformance: ConformanceLevel }): Record<string, unknown> {\n  const metadata = generateMetadata(EDM_MODEL, \"https://api.example.com\");\n  \n  // Add conformance level information\n  metadata[\"@odata.conformance\"] = options.conformance;\n  \n  return metadata;\n}\n\nexport function validateConformanceLevel(level: string): ConformanceLevel {\n  if (level === \"minimal\" || level === \"intermediate\" || level === \"advanced\") {\n    return level;\n  }\n  throw new Error(`Invalid conformance level: ${level}`);\n}\n\nexport function getSupportedQueryOptions(conformance: ConformanceLevel): string[] {\n  switch (conformance) {\n    case \"minimal\":\n      return [\"$select\"];\n    case \"intermediate\":\n      return [\"$select\", \"$expand\", \"$filter\", \"$orderby\", \"$top\", \"$skip\", \"$count\"];\n    case \"advanced\":\n      return [\"$select\", \"$expand\", \"$filter\", \"$orderby\", \"$top\", \"$skip\", \"$count\", \"$search\", \"$compute\", \"$apply\"];\n    default:\n      return [];\n  }\n}\n\nexport function checkQueryOptionSupport(queryOption: string, conformance: ConformanceLevel): boolean {\n  const supportedOptions = getSupportedQueryOptions(conformance);\n  return supportedOptions.includes(queryOption);\n}\n\n// Additional functions for conformance testing\nexport function callFunction(\n  functionName: string,\n  parameters: Record<string, unknown>,\n  options: { conformance: ConformanceLevel }\n): { value: unknown } {\n  // Mock function calls based on conformance level\n  if (options.conformance === \"minimal\") {\n    throw new Error(`Function '${functionName}' not supported in minimal conformance`);\n  }\n  \n  // Mock implementation\n  return { value: { result: `Function ${functionName} called with parameters`, parameters } };\n}\n\nexport function callAction(\n  actionName: string,\n  parameters: Record<string, unknown>,\n  options: { conformance: ConformanceLevel }\n): { value: unknown } {\n  // Mock action calls based on conformance level\n  if (options.conformance === \"minimal\") {\n    throw new Error(`Action '${actionName}' not supported in minimal conformance`);\n  }\n  \n  // Mock implementation\n  return { value: { result: `Action ${actionName} called with parameters`, parameters } };\n}\n\nexport function callFunctionImport(\n  functionName: string,\n  parameters: Record<string, unknown>,\n  options: { conformance: ConformanceLevel }\n): { value: unknown } {\n  // Mock function import calls\n  if (options.conformance === \"minimal\") {\n    throw new Error(`Function import '${functionName}' not supported in minimal conformance`);\n  }\n  \n  return { value: { result: `Function import ${functionName} called`, parameters } };\n}\n\nexport function callActionImport(\n  actionName: string,\n  parameters: Record<string, unknown>,\n  options: { conformance: ConformanceLevel }\n): { value: unknown } {\n  // Mock action import calls\n  if (options.conformance === \"minimal\") {\n    throw new Error(`Action import '${actionName}' not supported in minimal conformance`);\n  }\n  \n  return { value: { result: `Action import ${actionName} called`, parameters } };\n}\n\nexport function executeBatch(\n  batch: Array<{ method: string; url: string; body?: unknown }>,\n  options: { conformance: ConformanceLevel }\n): unknown[] {\n  // Mock batch execution\n  if (options.conformance === \"minimal\") {\n    throw new Error(\"Batch operations not supported in minimal conformance\");\n  }\n  \n  return batch.map((operation, index) => ({\n    id: index,\n    status: 200,\n    body: { result: `Batch operation ${operation.method} ${operation.url} executed` }\n  }));\n}\n\nexport function validateConformance(\n  level: ConformanceLevel\n): { isValid: boolean; missingFeatures: string[] } {\n  // Mock conformance validation\n  const missingFeatures: string[] = [];\n  \n  if (level === \"intermediate\") {\n    // Check for intermediate features\n    missingFeatures.push(\"Navigation properties\");\n  } else if (level === \"advanced\") {\n    // Check for advanced features\n    missingFeatures.push(\"Custom functions\", \"Custom actions\");\n  }\n  \n  return {\n    isValid: missingFeatures.length === 0,\n    missingFeatures\n  };\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataConformanceOptions, ODataMiddlewareContext } from \"./types\";\nimport { validateConformanceLevel } from \"../core/conformance-levels\";\nimport { mergeMiddlewareOptions, getMiddlewareContext, setMiddlewareContext } from \"./compose\";\n\ndeclare const console: any;\n\n\nconst DEFAULT_CONFORMANCE_OPTIONS: ODataConformanceOptions = {\n  conformanceLevel: \"minimal\",\n  strictMode: false,\n  validateQueries: true,\n  customValidationRules: {},\n};\n\n/**\n * OData Conformance Middleware\n * \n * Responsibilities:\n * - Validate OData query options against conformance levels\n * - Enforce OData v4.01 specification compliance\n * - Handle conformance level negotiation\n * - Provide conformance level information in responses\n * - Support custom validation rules and strict mode\n * - Manage feature availability based on conformance level\n */\nexport function odataConformance(options: Partial<ODataConformanceOptions> = {}): MiddlewareObj {\n  const opts = mergeMiddlewareOptions(DEFAULT_CONFORMANCE_OPTIONS, options);\n\n  return {\n    before: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        \n        if (!context) {\n          return;\n        }\n\n        const { event } = request;\n        const queryParams = event.queryStringParameters || {};\n\n        // Determine conformance level from request or use default\n        const requestedLevel = queryParams.$conformance || opts.conformanceLevel;\n        const conformanceLevel = validateConformanceLevel(requestedLevel);\n\n        // Validate query options against conformance level\n        if (opts.validateQueries) {\n          // For now, just validate the conformance level itself\n          // TODO: Add proper query validation against conformance level\n          validateConformanceLevel(conformanceLevel);\n        }\n\n        // Update context with conformance information\n        context.metadata = {\n          ...context.metadata,\n          conformance: {\n            level: conformanceLevel,\n            requestedLevel,\n            strictMode: opts.strictMode,\n            validationPassed: true,\n          },\n        };\n        setMiddlewareContext(request, context);\n\n      } catch (error) {\n        // Let the error middleware handle this\n        request.error = error;\n        throw error;\n      }\n    },\n\n    after: async (request: any) => {\n      try {\n        const context = getMiddlewareContext(request);\n        \n        if (!context || !request.response) {\n          return;\n        }\n\n        // Add conformance level information to response headers\n        if (context.metadata?.conformance) {\n          const headers = request.response.headers || {};\n          \n          // Add OData conformance header\n          headers[\"OData-Conformance\"] = context.metadata.conformance.level;\n          \n          // Add supported conformance levels\n          headers[\"OData-Supported-Conformance\"] = \"minimal,intermediate,advanced\";\n          \n          // Add feature availability based on conformance level\n          const features = getAvailableFeatures(context.metadata.conformance.level);\n          if (features.length > 0) {\n            headers[\"OData-Features\"] = features.join(\",\");\n          }\n\n          request.response.headers = headers;\n        }\n\n      } catch (error) {\n        // Log error but don't fail the request\n        console.warn(\"Error in conformance middleware after hook:\", error);\n      }\n    },\n  };\n}\n\n/**\n * Get available features based on conformance level\n */\nfunction getAvailableFeatures(conformanceLevel: string): string[] {\n  const features: string[] = [];\n\n  switch (conformanceLevel) {\n    case \"advanced\":\n      features.push(\n        \"search\",\n        \"compute\", \n        \"apply\",\n        \"batch\",\n        \"async\",\n        \"streaming\",\n        \"delta\",\n        \"references\",\n        \"crossjoin\",\n        \"all\",\n        \"any\",\n        \"cast\",\n        \"isof\"\n      );\n      // Fall through to intermediate features\n    case \"intermediate\":\n      features.push(\n        \"filter\",\n        \"orderby\",\n        \"top\",\n        \"skip\",\n        \"count\",\n        \"expand\",\n        \"select\",\n        \"format\",\n        \"inlinecount\",\n        \"search\",\n        \"compute\",\n        \"apply\"\n      );\n      // Fall through to minimal features\n    case \"minimal\":\n      features.push(\n        \"read\",\n        \"metadata\",\n        \"service-document\"\n      );\n      break;\n  }\n\n  return features;\n}\n\n/**\n * Helper function to create custom validation rules\n */\nexport function createValidationRule(\n  name: string,\n  validator: (options: any, context: ODataMiddlewareContext) => { valid: boolean; error?: string }\n) {\n  return {\n    name,\n    validator,\n  };\n}\n\n/**\n * Common validation rules for different conformance levels\n */\nexport const commonValidationRules = {\n  // Minimal conformance rules\n  minimal: {\n    noAdvancedQueries: (options: any) => ({\n      valid: !options.search && !options.compute && !options.apply,\n      error: \"Search, compute, and apply queries are not supported in minimal conformance level\",\n    }),\n    \n    basicQueriesOnly: (options: any) => ({\n      valid: !options.filter || !options.filter.includes(\"(\"),\n      error: \"Complex filter expressions are not supported in minimal conformance level\",\n    }),\n  },\n\n  // Intermediate conformance rules\n  intermediate: {\n    noAdvancedFunctions: (options: any) => ({\n      valid: !options.filter || !options.filter.includes(\"cast(\") && !options.filter.includes(\"isof(\"),\n      error: \"Cast and isof functions are not supported in intermediate conformance level\",\n    }),\n    \n    limitedSearch: (options: any) => ({\n      valid: !options.search || !options.search.includes(\"~\"),\n      error: \"Fuzzy search is not supported in intermediate conformance level\",\n    }),\n  },\n\n  // Advanced conformance rules\n  advanced: {\n    // Advanced level supports all features, so no restrictions\n    allFeaturesSupported: () => ({ valid: true }),\n  },\n};\n\n/**\n * Helper function to create conformance options with validation rules\n */\nexport function createConformanceOptions(\n  level: \"minimal\" | \"intermediate\" | \"advanced\" = \"minimal\",\n  strictMode: boolean = false,\n  customRules: Record<string, (...args: unknown[]) => unknown> = {}\n): ODataConformanceOptions {\n  const rules = { ...commonValidationRules[level], ...customRules };\n  \n  return {\n    conformanceLevel: level,\n    strictMode,\n    validateQueries: true,\n    customValidationRules: rules,\n  };\n}\n\n/**\n * Helper function to negotiate conformance level from request\n */\nexport function negotiateConformanceLevel(\n  requestedLevel: string | undefined,\n  supportedLevels: string[] = [\"minimal\", \"intermediate\", \"advanced\"],\n  defaultLevel: string = \"minimal\"\n): string {\n  if (!requestedLevel) {\n    return defaultLevel;\n  }\n\n  // Check if requested level is supported\n  if (supportedLevels.includes(requestedLevel)) {\n    return requestedLevel;\n  }\n\n  // Find the highest supported level that's lower than or equal to requested\n  const levelHierarchy = [\"minimal\", \"intermediate\", \"advanced\"];\n  const requestedIndex = levelHierarchy.indexOf(requestedLevel);\n  \n  if (requestedIndex === -1) {\n    return defaultLevel;\n  }\n\n  // Find the highest supported level that's <= requested level\n  for (let i = requestedIndex; i >= 0; i--) {\n    if (supportedLevels.includes(levelHierarchy[i])) {\n      return levelHierarchy[i];\n    }\n  }\n\n  return defaultLevel;\n}\n\n/**\n * Helper function to check if a feature is supported at a conformance level\n */\nexport function isFeatureSupported(\n  feature: string,\n  conformanceLevel: string\n): boolean {\n  const features = getAvailableFeatures(conformanceLevel);\n  return features.includes(feature);\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { EdmModel } from \"../core/types\";\nimport type { ODataMiddlewareContext } from \"./types\";\nimport { composeMiddlewares } from \"./compose\";\nimport { odataParse } from \"./parse\";\nimport { odataShape } from \"./shape\";\nimport { odataFilter } from \"./filter\";\nimport { odataPagination } from \"./pagination\";\nimport { odataSerialize } from \"./serialize\";\nimport { odataError } from \"./error\";\nimport { odataFunctions } from \"./functions\";\nimport { odataMetadata } from \"./metadata\";\nimport { odataConformance } from \"./conformance\";\n\n// Main OData middleware configuration interface\nexport interface ODataOptions {\n  // Required configuration\n  model: EdmModel;\n  serviceRoot: string | ((event: any) => string);\n\n  // Feature enablement\n  enable?: {\n    parse?: boolean;\n    shape?: boolean;\n    filter?: boolean;\n    pagination?: boolean;\n    serialize?: boolean;\n    error?: boolean;\n    functions?: boolean;\n    metadata?: boolean;\n    conformance?: boolean;\n    // Advanced features\n    search?: boolean;\n    compute?: boolean;\n    apply?: boolean;\n  };\n\n  // Default values and limits\n  defaults?: {\n    maxTop?: number;\n    defaultTop?: number;\n    maxExpandDepth?: number;\n    maxFilterDepth?: number;\n  };\n\n  // Individual middleware options\n  parse?: {\n    validateAgainstModel?: boolean;\n    strictMode?: boolean;\n  };\n\n  shape?: {\n    enableExpand?: boolean;\n    maxExpandDepth?: number;\n    expandResolvers?: Record<string, (...args: unknown[]) => unknown>;\n  };\n\n  filter?: {\n    enableFilter?: boolean;\n    enableOrderby?: boolean;\n    maxFilterDepth?: number;\n    caseSensitive?: boolean;\n  };\n\n  pagination?: {\n    maxTop?: number;\n    defaultTop?: number;\n    enableCount?: boolean;\n  };\n\n  serialize?: {\n    format?: \"json\" | \"xml\" | \"atom\";\n    includeMetadata?: boolean;\n    prettyPrint?: boolean;\n  };\n\n  error?: {\n    includeStackTrace?: boolean;\n    logErrors?: boolean;\n    customErrorHandler?: (error: Error, context: ODataMiddlewareContext) => void;\n  };\n\n  functions?: {\n    enableFunctions?: boolean;\n    enableActions?: boolean;\n    functionResolvers?: Record<string, (...args: unknown[]) => unknown>;\n    actionResolvers?: Record<string, (...args: unknown[]) => unknown>;\n    validateParameters?: boolean;\n  };\n\n  metadata?: {\n    enableMetadata?: boolean;\n    enableServiceDocument?: boolean;\n    includeAnnotations?: boolean;\n    customAnnotations?: Record<string, any>;\n    metadataPath?: string;\n    serviceDocumentPath?: string;\n  };\n\n  conformance?: {\n    conformanceLevel?: \"minimal\" | \"intermediate\" | \"advanced\";\n    strictMode?: boolean;\n    validateQueries?: boolean;\n    customValidationRules?: Record<string, (...args: unknown[]) => unknown>;\n  };\n}\n\nconst DEFAULT_OPTIONS: ODataOptions = {\n  model: {} as EdmModel,\n  serviceRoot: \"\",\n  enable: {\n    parse: true,\n    shape: true,\n    filter: true,\n    pagination: true,\n    serialize: true,\n    error: true,\n    functions: true,\n    metadata: true,\n    conformance: true,\n    search: false,\n    compute: false,\n    apply: false,\n  },\n  defaults: {\n    maxTop: 1000,\n    defaultTop: 50,\n    maxExpandDepth: 3,\n    maxFilterDepth: 10,\n  },\n};\n\n/**\n * Main OData Middleware\n * \n * This is the pre-composed middleware that internally chains all individual\n * OData middlewares in the correct order following Middy's onion pattern.\n * \n * Usage:\n * ```typescript\n * const handler = middy(baseHandler)\n *   .use(odata({\n *     model: EDM_MODEL,\n *     serviceRoot: \"https://api.example.com/odata\",\n *     enable: { compute: false, apply: false, search: false },\n *     defaults: { maxTop: 1000, defaultTop: 50 },\n *   }));\n * ```\n */\nexport function odata(options: ODataOptions): MiddlewareObj {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  // Build the middleware chain in the correct order\n  const middlewares: MiddlewareObj[] = [];\n\n  // 1. Parse middleware (first - sets up context)\n  if (opts.enable?.parse !== false) {\n    middlewares.push(odataParse({\n      model: opts.model,\n      serviceRoot: opts.serviceRoot,\n      validateAgainstModel: opts.parse?.validateAgainstModel ?? true,\n      strictMode: opts.parse?.strictMode ?? false,\n    }));\n  }\n\n  // 2. Conformance middleware (early - validates queries)\n  if (opts.enable?.conformance !== false) {\n    middlewares.push(odataConformance({\n      conformanceLevel: opts.conformance?.conformanceLevel ?? \"minimal\",\n      strictMode: opts.conformance?.strictMode ?? false,\n      validateQueries: opts.conformance?.validateQueries ?? true,\n      customValidationRules: opts.conformance?.customValidationRules ?? {},\n    }));\n  }\n\n  // 3. Functions middleware (early - handles function/action calls)\n  if (opts.enable?.functions !== false) {\n    middlewares.push(odataFunctions({\n      enableFunctions: opts.functions?.enableFunctions ?? true,\n      enableActions: opts.functions?.enableActions ?? true,\n      functionResolvers: opts.functions?.functionResolvers ?? {},\n      actionResolvers: opts.functions?.actionResolvers ?? {},\n      validateParameters: opts.functions?.validateParameters ?? true,\n    }));\n  }\n\n  // 4. Metadata middleware (early - handles metadata requests)\n  if (opts.enable?.metadata !== false) {\n    middlewares.push(odataMetadata({\n      enableMetadata: opts.metadata?.enableMetadata ?? true,\n      enableServiceDocument: opts.metadata?.enableServiceDocument ?? true,\n      includeAnnotations: opts.metadata?.includeAnnotations ?? true,\n      customAnnotations: opts.metadata?.customAnnotations ?? {},\n      metadataPath: opts.metadata?.metadataPath ?? \"/$metadata\",\n      serviceDocumentPath: opts.metadata?.serviceDocumentPath ?? \"/\",\n    }));\n  }\n\n  // 5. Shape middleware (after - transforms response data)\n  if (opts.enable?.shape !== false) {\n    middlewares.push(odataShape({\n      enableExpand: opts.shape?.enableExpand ?? true,\n      maxExpandDepth: opts.shape?.maxExpandDepth ?? opts.defaults?.maxExpandDepth ?? 3,\n      expandResolvers: (opts.shape?.expandResolvers ?? {}) as Record<string, (context: ODataMiddlewareContext) => Promise<unknown>>,\n    }));\n  }\n\n  // 6. Filter middleware (after - filters and sorts data)\n  if (opts.enable?.filter !== false) {\n    middlewares.push(odataFilter({\n      enableFilter: opts.filter?.enableFilter ?? true,\n      enableOrderby: opts.filter?.enableOrderby ?? true,\n      maxFilterDepth: opts.filter?.maxFilterDepth ?? opts.defaults?.maxFilterDepth ?? 10,\n      caseSensitive: opts.filter?.caseSensitive ?? true,\n    }));\n  }\n\n  // 7. Pagination middleware (after - paginates data)\n  if (opts.enable?.pagination !== false) {\n    middlewares.push(odataPagination({\n      maxTop: opts.pagination?.maxTop ?? opts.defaults?.maxTop ?? 1000,\n      defaultTop: opts.pagination?.defaultTop ?? opts.defaults?.defaultTop ?? 50,\n      enableCount: opts.pagination?.enableCount ?? true,\n    }));\n  }\n\n  // 8. Serialize middleware (last - formats response)\n  if (opts.enable?.serialize !== false) {\n    middlewares.push(odataSerialize({\n      format: opts.serialize?.format ?? \"json\",\n      includeMetadata: opts.serialize?.includeMetadata ?? true,\n      prettyPrint: opts.serialize?.prettyPrint ?? false,\n    }));\n  }\n\n  // 9. Error middleware (always last - handles errors)\n  if (opts.enable?.error !== false) {\n    middlewares.push(odataError({\n      includeStackTrace: opts.error?.includeStackTrace ?? false,\n      logErrors: opts.error?.logErrors ?? true,\n      customErrorHandler: opts.error?.customErrorHandler as ((error: Error, context: ODataMiddlewareContext, request: any) => unknown) | undefined,\n    }));\n  }\n\n  // Compose all middlewares into a single middleware\n  return composeMiddlewares(...middlewares);\n}\n\n/**\n * Create a minimal OData middleware with only essential features\n */\nexport function odataMinimal(options: ODataOptions): MiddlewareObj {\n  return odata({\n    ...options,\n    enable: {\n      parse: true,\n      shape: false,\n      filter: false,\n      pagination: false,\n      serialize: true,\n      error: true,\n      functions: false,\n      metadata: true,\n      conformance: false,\n      search: false,\n      compute: false,\n      apply: false,\n    },\n  });\n}\n\n/**\n * Create a core OData middleware with common features\n */\nexport function odataCore(options: ODataOptions): MiddlewareObj {\n  return odata({\n    ...options,\n    enable: {\n      parse: true,\n      shape: true,\n      filter: true,\n      pagination: true,\n      serialize: true,\n      error: true,\n      functions: false,\n      metadata: true,\n      conformance: true,\n      search: false,\n      compute: false,\n      apply: false,\n    },\n  });\n}\n\n/**\n * Create a full OData middleware with all features enabled\n */\nexport function odataFull(options: ODataOptions): MiddlewareObj {\n  return odata({\n    ...options,\n    enable: {\n      parse: true,\n      shape: true,\n      filter: true,\n      pagination: true,\n      serialize: true,\n      error: true,\n      functions: true,\n      metadata: true,\n      conformance: true,\n      search: true,\n      compute: true,\n      apply: true,\n    },\n  });\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport { odataParse } from \"./parse\";\nimport { odataShape } from \"./shape\";\nimport { odataFilter } from \"./filter\";\nimport { odataPagination } from \"./pagination\";\nimport { odataSerialize } from \"./serialize\";\nimport { odataError } from \"./error\";\nimport { odataFunctions } from \"./functions\";\nimport { odataMetadata } from \"./metadata\";\nimport { odataConformance } from \"./conformance\";\nimport type { \n  ODataParseOptions, \n  ODataShapeOptions, \n  ODataFilterOptions, \n  ODataPaginationOptions,\n  ODataSerializeOptions,\n  ODataErrorOptions,\n  ODataFunctionsOptions,\n  ODataMetadataOptions,\n  ODataConformanceOptions\n} from \"./types\";\n\n/**\n * Convenience middleware arrays for users who prefer explicit chaining\n * These provide pre-configured combinations of middlewares for common use cases\n */\n\n// Core OData functionality (parsing, shaping, filtering, pagination, serialization)\nexport function odataCore(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataShape(),\n    odataFilter(),\n    odataPagination(),\n    odataSerialize(),\n  ];\n}\n\n// Full OData functionality including error handling\nexport function odataFull(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataShape(),\n    odataFilter(),\n    odataPagination(),\n    odataSerialize(),\n    odataError(),\n  ];\n}\n\n// OData with functions and actions support\nexport const odataWithFunctions: Array<(options?: any) => MiddlewareObj> = [\n  odataParse,\n  odataFunctions,\n  odataShape,\n  odataFilter,\n  odataPagination,\n  odataSerialize,\n  odataError,\n];\n\n// OData with metadata service support\nexport const odataWithMetadata: Array<(options?: any) => MiddlewareObj> = [\n  odataParse,\n  odataMetadata,\n  odataShape,\n  odataFilter,\n  odataPagination,\n  odataSerialize,\n  odataError,\n];\n\n// Complete OData implementation with all features\nexport const odataComplete: Array<(options?: any) => MiddlewareObj> = [\n  odataParse,\n  odataFunctions,\n  odataMetadata,\n  odataConformance,\n  odataShape,\n  odataFilter,\n  odataPagination,\n  odataSerialize,\n  odataError,\n];\n\n// Lightweight OData (parsing and serialization only)\nexport function odataLight(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataSerialize(),\n  ];\n}\n\n// OData for read-only operations (no functions/actions)\nexport function odataReadOnly(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataShape(),\n    odataFilter(),\n    odataPagination(),\n    odataSerialize(),\n    odataError(),\n  ];\n}\n\n// OData for write operations (includes functions/actions)\nexport function odataWrite(options: any): MiddlewareObj[] {\n  return [\n    odataParse(options),\n    odataFunctions(),\n    odataShape(),\n    odataFilter(),\n    odataPagination(),\n    odataSerialize(),\n    odataError(),\n  ];\n}\n\n/**\n * Helper function to create middleware arrays with custom options\n */\nexport function createMiddlewareArray(options: {\n  model: any;\n  serviceRoot: string;\n  include?: string[];\n  exclude?: string[];\n}): MiddlewareObj[] {\n  const { model, serviceRoot, include, exclude } = options;\n  \n  const allMiddlewares = {\n    parse: () => odataParse({ model, serviceRoot }),\n    shape: () => odataShape(),\n    filter: () => odataFilter(),\n    pagination: () => odataPagination(),\n    serialize: () => odataSerialize(),\n    error: () => odataError(),\n    functions: () => odataFunctions(),\n    metadata: () => odataMetadata(),\n    conformance: () => odataConformance(),\n  };\n  \n  const middlewareNames = include || Object.keys(allMiddlewares);\n  const excludedNames = exclude || [];\n  \n  return middlewareNames\n    .filter(name => !excludedNames.includes(name))\n    .map(name => allMiddlewares[name as keyof typeof allMiddlewares]())\n    .filter(Boolean);\n}\n\nexport function createODataMiddlewareArray(\n  middlewares: Array<(options?: any) => MiddlewareObj>,\n  options: {\n    parse?: Partial<ODataParseOptions>;\n    shape?: Partial<ODataShapeOptions>;\n    filter?: Partial<ODataFilterOptions>;\n    pagination?: Partial<ODataPaginationOptions>;\n    serialize?: Partial<ODataSerializeOptions>;\n    error?: Partial<ODataErrorOptions>;\n    functions?: Partial<ODataFunctionsOptions>;\n    metadata?: Partial<ODataMetadataOptions>;\n    conformance?: Partial<ODataConformanceOptions>;\n  } = {}\n): Array<MiddlewareObj> {\n  return middlewares.map(middleware => {\n    if (middleware === odataParse) return middleware(options.parse);\n    if (middleware === odataShape) return middleware(options.shape);\n    if (middleware === odataFilter) return middleware(options.filter);\n    if (middleware === odataPagination) return middleware(options.pagination);\n    if (middleware === odataSerialize) return middleware(options.serialize);\n    if (middleware === odataError) return middleware(options.error);\n    if (middleware === odataFunctions) return middleware(options.functions);\n    if (middleware === odataMetadata) return middleware(options.metadata);\n    if (middleware === odataConformance) return middleware(options.conformance);\n    return middleware();\n  });\n}\n\n/**\n * Usage examples:\n * \n * // Use pre-configured middleware arrays\n * const handler = middy(baseHandler)\n *   .use(...odataCore.map(m => m()))\n *   .use(...odataFull.map(m => m()));\n * \n * // Use with custom options\n * const handler = middy(baseHandler)\n *   .use(...createODataMiddlewareArray(odataCore, {\n *     parse: { strictMode: true },\n *     pagination: { maxTop: 500 }\n *   }));\n * \n * // Chain individual middlewares\n * const handler = middy(baseHandler)\n *   .use(odataParse({ strictMode: true }))\n *   .use(odataShape({ enableExpand: false }))\n *   .use(odataSerialize({ prettyPrint: true }));\n */\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ODataEntity } from \"./types\";\n\nexport interface ODataError {\n  error: {\n    code: string;\n    message: string;\n    target?: string;\n    details?: Array<{\n      code: string;\n      message: string;\n      target?: string;\n    }>;\n    innererror?: {\n      message: string;\n      type: string;\n      stacktrace?: string;\n    };\n  };\n}\n\nexport class ODataErrorHandler {\n  static createError(code: string, message: string, target?: string, details?: any[]): ODataError {\n    return {\n      error: {\n        code,\n        message,\n        target,\n        details,\n      }\n    };\n  }\n\n  static badRequest(message: string, target?: string): ODataError {\n    return this.createError(\"400\", `Bad Request: ${message}`, target);\n  }\n\n  static unauthorized(message: string = \"Authentication required\"): ODataError {\n    return this.createError(\"401\", `Unauthorized: ${message}`);\n  }\n\n  static forbidden(message: string = \"Insufficient permissions\"): ODataError {\n    return this.createError(\"403\", `Forbidden: ${message}`);\n  }\n\n  static notFound(message: string = \"Resource not found\"): ODataError {\n    return this.createError(\"404\", `Not Found: ${message}`);\n  }\n\n  static methodNotAllowed(message: string): ODataError {\n    return this.createError(\"405\", `Method Not Allowed: ${message}`);\n  }\n\n  static notAcceptable(message: string = \"Unsupported format\"): ODataError {\n    return this.createError(\"406\", `Not Acceptable: ${message}`);\n  }\n\n  static conflict(message: string = \"Conflict\"): ODataError {\n    return this.createError(\"409\", `Conflict: ${message}`);\n  }\n\n  static preconditionFailed(message: string = \"Precondition failed\"): ODataError {\n    return this.createError(\"412\", `Precondition Failed: ${message}`);\n  }\n\n  static unsupportedMediaType(message: string = \"Unsupported media type\"): ODataError {\n    return this.createError(\"415\", `Unsupported Media Type: ${message}`);\n  }\n\n  static unprocessableEntity(message: string = \"Unprocessable entity\"): ODataError {\n    return this.createError(\"422\", `Unprocessable Entity: ${message}`);\n  }\n\n  static tooManyRequests(message: string = \"Too many requests\"): ODataError {\n    return this.createError(\"429\", `Too Many Requests: ${message}`);\n  }\n\n  static internalServerError(message: string = \"Internal server error\"): ODataError {\n    return this.createError(\"500\", `Internal Server Error: ${message}`);\n  }\n\n  static notImplemented(message: string = \"Not implemented\"): ODataError {\n    return this.createError(\"501\", `Not Implemented: ${message}`);\n  }\n\n  static badGateway(message: string = \"Bad gateway\"): ODataError {\n    return this.createError(\"502\", `Bad Gateway: ${message}`);\n  }\n\n  static serviceUnavailable(message: string = \"Service unavailable\"): ODataError {\n    return this.createError(\"503\", `Service Unavailable: ${message}`);\n  }\n\n  static gatewayTimeout(message: string = \"Gateway timeout\"): ODataError {\n    return this.createError(\"504\", `Gateway Timeout: ${message}`);\n  }\n}\n\nexport function validateQueryParameters(query: Record<string, string | undefined>): void {\n  // Check for malformed query parameters\n  for (const [key, value] of Object.entries(query)) {\n    if (key.startsWith('$') && value === undefined) {\n      throw new Error(`Bad Request: Malformed query parameter '${key}'`);\n    }\n    \n    // Check for specific invalid values in query parameters\n    if (key.startsWith('$') && value && value.includes('invalid')) {\n      throw new Error(`Bad Request: Malformed query parameter '${key}'`);\n    }\n  }\n  \n  // Check for specific malformed parameters\n  if (query.malformed === undefined) {\n    throw new Error(`Bad Request: Malformed query parameter 'malformed'`);\n  }\n}\n\nexport function validateAuthentication(auth: any): void {\n  if (!auth) {\n    throw new Error(\"Unauthorized: Authentication required\");\n  }\n}\n\nexport function validatePermissions(auth: any, requiredPermission: string): void {\n  if (!auth || auth.permissions?.includes(requiredPermission) !== true) {\n    throw new Error(\"Forbidden: Insufficient permissions\");\n  }\n}\n\nexport function validateResourceExists(resource: any, resourceName: string): void {\n  if (!resource) {\n    throw new Error(`Not Found: ${resourceName} not found`);\n  }\n}\n\nexport function validateHttpMethod(method: string, allowedMethods: string[]): void {\n  if (!allowedMethods.includes(method)) {\n    throw new Error(`Method Not Allowed: ${method} not supported`);\n  }\n}\n\nexport function validateContentType(contentType: string, allowedTypes: string[]): void {\n  if (!allowedTypes.includes(contentType)) {\n    throw new Error(`Not Acceptable: Unsupported content type '${contentType}'`);\n  }\n}\n\nexport function validateEntityConstraints<T extends ODataEntity>(\n  entity: Partial<T>,\n  constraints: Record<string, any>\n): void {\n  for (const [field, constraint] of Object.entries(constraints)) {\n    if (constraint.required && !entity[field as keyof T]) {\n      throw new Error(`Conflict: Required field '${field}' is missing`);\n    }\n    \n    if (constraint.unique && entity[field as keyof T]) {\n      // In a real implementation, this would check against the database\n      throw new Error(`Conflict: Field '${field}' must be unique`);\n    }\n  }\n}\n\nexport function validateETagMatch(entity: ODataEntity, etag: string): void {\n  // Simple ETag validation - in real implementation would compare with stored ETag\n  if (!etag || etag === '\"invalid\"') {\n    throw new Error(\"Precondition Failed: ETag mismatch\");\n  }\n}\n\nexport function validateRequestSize(requestSize: number, maxSize: number): void {\n  if (requestSize > maxSize) {\n    throw new Error(\"Payload Too Large: Request size exceeds limit\");\n  }\n}\n\nexport function validateQueryComplexity(query: string, maxComplexity: number): void {\n  // Simple complexity check based on query length and operators\n  const complexity = query.length + (query.match(/and|or|not/gi) || []).length * 2;\n  if (complexity > maxComplexity) {\n    throw new Error(\"Unprocessable Entity: Query too complex\");\n  }\n}\n\nexport function handleTimeout(operation: () => unknown, timeoutMs: number): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    const timer = globalThis.setTimeout(() => {\n      reject(new Error(\"Gateway Timeout: Operation timed out\"));\n    }, timeoutMs);\n    \n    try {\n      const result = operation();\n      if (result && typeof result === 'object' && 'then' in result && typeof (result as Promise<unknown>).then === 'function') {\n        // Handle Promise result\n        (result as Promise<unknown>).then((value: unknown) => {\n          globalThis.clearTimeout(timer);\n          resolve(value);\n        }).catch((error: unknown) => {\n          globalThis.clearTimeout(timer);\n          reject(error);\n        });\n      } else {\n        // Handle synchronous result\n        globalThis.clearTimeout(timer);\n        resolve(result);\n      }\n    } catch (error) {\n      globalThis.clearTimeout(timer);\n      reject(error);\n    }\n  });\n}\n\nexport function handleConcurrentModification(entity: ODataEntity, etag: string): void {\n  // Simulate concurrent modification detection\n  if (etag === '\"old-etag\"') {\n    throw new Error(\"Conflict: Entity was modified by another user\");\n  }\n}\n\nexport function handleRateLimit(requests: number, limit: number): void {\n  if (requests > limit) {\n    throw new Error(\"Too Many Requests: Rate limit exceeded\");\n  }\n}\n\nexport function handleServiceUnavailable(): void {\n  throw new Error(\"Service Unavailable: Service temporarily unavailable\");\n}\n\nexport function handleNotImplemented(feature: string): void {\n  throw new Error(`Not Implemented: Feature '${feature}' is not implemented`);\n}\n\nexport function handleBadGateway(): void {\n  throw new Error(\"Bad Gateway: Upstream service error\");\n}\n\nexport function handleInternalError(error: Error): void {\n  throw new Error(`Internal Server Error: ${error.message}`);\n}\n\n// Additional validation functions for comprehensive error handling\nexport function createEntity<T extends ODataEntity>(\n  collection: T[],\n  entity: Partial<T>,\n  entityType: string,\n  options?: { contentType?: string }\n): T {\n  // Validate content type if provided\n  if (options?.contentType && ![\"application/json\", \"application/xml\"].includes(options.contentType)) {\n    throw new Error(`Unsupported Media Type: Content-Type not supported`);\n  }\n  \n  // Validate entity constraints\n  validateEntityConstraints(entity, { name: { required: true } });\n  \n  // Check for unique constraints\n  if (entity.name && collection.some(item => item.name === entity.name)) {\n    throw new Error(`Conflict: Unique constraint violation`);\n  }\n  \n  // Return the entity (in real implementation, this would save to database)\n  return entity as T;\n}\n\nexport function processLargeData(data: any[]): void {\n  const estimatedSize = JSON.stringify(data).length;\n  const maxSize = 100 * 1024 * 1024; // 100MB\n  \n  if (estimatedSize > maxSize) {\n    throw new Error(\"Memory limit exceeded: Cannot process data larger than 100MB\");\n  }\n}\n\nexport function queryWithLimit<T>(collection: T[], options: { limit: number }): T[] {\n  if (options.limit > 10000) {\n    throw new Error(\"Result size limit exceeded: Cannot return more than 10000 items\");\n  }\n  return collection.slice(0, options.limit);\n}\n\nexport function queryWithDepth<T>(collection: T[], options: { depth: number }): T[] {\n  if (options.depth > 10) {\n    throw new Error(\"Query depth limit exceeded: Cannot expand more than 10 levels\");\n  }\n  return collection;\n}\n\nexport function queryWithComplexity<T>(collection: T[], options: { complexity: string }): T[] {\n  if (options.complexity === \"high\") {\n    throw new Error(\"Query complexity limit exceeded: Query too complex to execute\");\n  }\n  return collection;\n}\n\nexport function queryWithInjection<T>(collection: T[], options: { filter: string }): T[] {\n  if (options.filter.includes(\"DROP TABLE\") || options.filter.includes(\"--\")) {\n    throw new Error(\"Security violation: Potential SQL injection detected\");\n  }\n  return collection;\n}\n\nexport function queryWithXSS<T>(collection: T[], options: { search: string }): T[] {\n  if (options.search.includes(\"<script>\") || options.search.includes(\"javascript:\")) {\n    throw new Error(\"Security violation: Potential XSS attack detected\");\n  }\n  return collection;\n}\n\nexport function queryWithPathTraversal<T>(collection: T[], options: { path: string }): T[] {\n  if (options.path.includes(\"../\") || options.path.includes(\"..\\\\\")) {\n    throw new Error(\"Security violation: Path traversal attempt detected\");\n  }\n  return collection;\n}\n\nexport function queryWithCSRF<T>(collection: T[], options: { csrf: string }): T[] {\n  if (options.csrf === \"invalid-token\") {\n    throw new Error(\"Security violation: Invalid CSRF token\");\n  }\n  return collection;\n}\n\nexport function queryWithFallback<T>(collection: T[], options: { fallback: boolean }): { value: T[], warnings?: string[] } {\n  return {\n    value: collection,\n    warnings: options.fallback ? [\"Some features degraded due to system load\"] : undefined\n  };\n}\n\nexport function queryWithRetry<T>(collection: T[]): { value: T[] } {\n  return { value: collection };\n}\n\nexport function queryWithDegradation<T>(collection: T[], options: { degrade: boolean }): { value: T[], degraded?: boolean } {\n  return {\n    value: collection,\n    degraded: options.degrade\n  };\n}\n","import type { ODataEntity } from \"./types\";\n\nexport interface SerializationOptions {\n  format?: \"json\" | \"xml\" | \"atom\" | \"csv\" | \"text\";\n  serviceRoot?: string;\n  count?: boolean;\n  top?: number;\n  skip?: number;\n  metadata?: \"minimal\" | \"full\" | \"none\";\n  annotations?: boolean;\n  includeAnnotations?: string[];\n  excludeAnnotations?: string[];\n  deltaLink?: boolean;\n}\n\nexport interface SerializedResponse {\n  \"@odata.context\"?: string;\n  \"@odata.count\"?: number;\n  \"@odata.nextLink\"?: string;\n  \"@odata.deltaLink\"?: string;\n  \"@odata.metadataEtag\"?: string;\n  value?: ODataEntity | ODataEntity[];\n  [key: string]: unknown;\n}\n\nexport function serializeToJson(data: ODataEntity | ODataEntity[], options: SerializationOptions = {}): SerializedResponse {\n  const {\n    serviceRoot = \"https://api.example.com/odata\",\n    count = false,\n    top,\n    skip,\n    metadata = \"minimal\"\n  } = options;\n\n  const isCollection = Array.isArray(data);\n  const result: SerializedResponse = {};\n\n  // Add @odata.context\n  if (metadata !== \"none\") {\n    if (isCollection) {\n      result[\"@odata.context\"] = `${serviceRoot}/$metadata#Products`;\n    } else {\n      result[\"@odata.context\"] = `${serviceRoot}/$metadata#Products/$entity`;\n    }\n  }\n\n  // Add @odata.count if requested\n  if (count && isCollection) {\n    result[\"@odata.count\"] = data.length;\n  }\n\n  // Add @odata.nextLink for pagination\n  if (isCollection && top && data.length >= top) {\n    const nextSkip = (skip || 0) + top;\n    result[\"@odata.nextLink\"] = `${serviceRoot}/Products?$top=${top}&$skip=${nextSkip}`;\n  }\n\n  // Add @odata.deltaLink for delta queries\n  if (isCollection && options.deltaLink) {\n    result[\"@odata.deltaLink\"] = `${serviceRoot}/Products?$deltatoken=abc123`;\n  }\n\n  // Add @odata.metadataEtag\n  if (metadata === \"full\") {\n    result[\"@odata.metadataEtag\"] = '\"metadata-etag-123\"';\n  }\n\n  // Serialize the data\n  if (isCollection) {\n    result.value = data.map(item => serializeEntity(item, options));\n  } else {\n    Object.assign(result, serializeEntity(data, options));\n  }\n\n  return result;\n}\n\nexport function serializeToXml(data: ODataEntity | ODataEntity[], options: SerializationOptions = {}): string {\n  const {\n    serviceRoot = \"https://api.example.com/odata\",\n    metadata = \"minimal\"\n  } = options;\n\n  const isCollection = Array.isArray(data);\n  let xml = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n  \n  if (isCollection) {\n    xml += `<feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\">\\n`;\n    \n    if (metadata !== \"none\") {\n      xml += `  <m:count>${data.length}</m:count>\\n`;\n    }\n    \n    data.forEach(item => {\n      xml += `  <entry>\\n`;\n      xml += `    <id>${serviceRoot}/Products(${item.id})</id>\\n`;\n      xml += `    <title type=\"text\">${item.name}</title>\\n`;\n      xml += `    <content type=\"application/xml\">\\n`;\n      xml += `      <m:properties>\\n`;\n      xml += `        <d:Id>${item.id}</d:Id>\\n`;\n      xml += `        <d:Name>${item.name}</d:Name>\\n`;\n      if ('price' in item) {\n        xml += `        <d:Price>${item.price}</d:Price>\\n`;\n      }\n      if ('categoryId' in item) {\n        xml += `        <d:CategoryId>${item.categoryId}</d:CategoryId>\\n`;\n      }\n      xml += `      </m:properties>\\n`;\n      xml += `    </content>\\n`;\n      xml += `  </entry>\\n`;\n    });\n    \n    xml += `</feed>`;\n  } else {\n    xml += `<entry xmlns=\"http://www.w3.org/2005/Atom\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\">\\n`;\n    xml += `  <id>${serviceRoot}/Products(${data.id})</id>\\n`;\n    xml += `  <title type=\"text\">${data.name}</title>\\n`;\n    xml += `  <content type=\"application/xml\">\\n`;\n    xml += `    <m:properties>\\n`;\n    xml += `      <d:Id>${data.id}</d:Id>\\n`;\n    xml += `      <d:Name>${data.name}</d:Name>\\n`;\n    if ('price' in data) {\n      xml += `      <d:Price>${data.price}</d:Price>\\n`;\n    }\n    if ('categoryId' in data) {\n      xml += `      <d:CategoryId>${data.categoryId}</d:CategoryId>\\n`;\n    }\n    xml += `    </m:properties>\\n`;\n    xml += `  </content>\\n`;\n    xml += `</entry>`;\n  }\n\n  return xml;\n}\n\nexport function serializeToAtom(data: ODataEntity | ODataEntity[], options: SerializationOptions = {}): string {\n  const {\n    serviceRoot = \"https://api.example.com/odata\",\n    metadata = \"minimal\"\n  } = options;\n\n  const isCollection = Array.isArray(data);\n  let xml = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n  \n  if (isCollection) {\n    xml += `<feed xmlns=\"http://www.w3.org/2005/Atom\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\">\\n`;\n    \n    // Add feed metadata\n    xml += `  <updated>${new Date().toISOString()}</updated>\\n`;\n    xml += `  <author>\\n`;\n    xml += `    <name>OData Service</name>\\n`;\n    xml += `  </author>\\n`;\n    \n    if (metadata !== \"none\") {\n      xml += `  <m:count>${data.length}</m:count>\\n`;\n    }\n    \n    data.forEach(item => {\n      xml += `  <entry>\\n`;\n      xml += `    <id>${serviceRoot}/Products(${item.id})</id>\\n`;\n      xml += `    <title type=\"text\">${item.name}</title>\\n`;\n      xml += `    <updated>${new Date().toISOString()}</updated>\\n`;\n      xml += `    <author>\\n`;\n      xml += `      <name>OData Service</name>\\n`;\n      xml += `    </author>\\n`;\n      xml += `    <content type=\"application/xml\">\\n`;\n      xml += `      <m:properties>\\n`;\n      xml += `        <d:Id>${item.id}</d:Id>\\n`;\n      xml += `        <d:Name>${item.name}</d:Name>\\n`;\n      if ('price' in item) {\n        xml += `        <d:Price>${item.price}</d:Price>\\n`;\n      }\n      if ('categoryId' in item) {\n        xml += `        <d:CategoryId>${item.categoryId}</d:CategoryId>\\n`;\n      }\n      xml += `      </m:properties>\\n`;\n      xml += `    </content>\\n`;\n      xml += `  </entry>\\n`;\n    });\n    \n    xml += `</feed>`;\n  } else {\n    xml += `<entry xmlns=\"http://www.w3.org/2005/Atom\" xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\">\\n`;\n    xml += `  <id>${serviceRoot}/Products(${data.id})</id>\\n`;\n    xml += `  <title type=\"text\">${data.name}</title>\\n`;\n    xml += `  <updated>${new Date().toISOString()}</updated>\\n`;\n    xml += `  <author>\\n`;\n    xml += `    <name>OData Service</name>\\n`;\n    xml += `  </author>\\n`;\n    xml += `  <content type=\"application/xml\">\\n`;\n    xml += `    <m:properties>\\n`;\n    xml += `      <d:Id>${data.id}</d:Id>\\n`;\n    xml += `      <d:Name>${data.name}</d:Name>\\n`;\n    if ('price' in data) {\n      xml += `      <d:Price>${data.price}</d:Price>\\n`;\n    }\n    if ('categoryId' in data) {\n      xml += `      <d:CategoryId>${data.categoryId}</d:CategoryId>\\n`;\n    }\n    xml += `    </m:properties>\\n`;\n    xml += `  </content>\\n`;\n    xml += `</entry>`;\n  }\n\n  return xml;\n}\n\nexport function serializeToCsv(data: ODataEntity[], options: SerializationOptions = {}): string {\n  if (!Array.isArray(data) || data.length === 0) {\n    return \"\";\n  }\n\n  // Use options to avoid unused variable warning\n  if (options.format) {\n    // Format is available for future use\n  }\n  \n  const headers = Object.keys(data[0]);\n  const csvRows = [headers.join(\",\")];\n  \n  data.forEach(item => {\n    const values = headers.map(header => {\n      const value = item[header as keyof ODataEntity];\n      // Escape CSV values\n      if (typeof value === \"string\" && (value.includes(\",\") || value.includes('\"') || value.includes(\"\\n\"))) {\n        return `\"${value.replace(/\"/g, '\"\"')}\"`;\n      }\n      return value;\n    });\n    csvRows.push(values.join(\",\"));\n  });\n\n  return csvRows.join(\"\\n\");\n}\n\nexport function serializeToText(data: ODataEntity | ODataEntity[], options: SerializationOptions = {}): string {\n  // Use options to avoid unused variable warning\n  if (options.format) {\n    // Format is available for future use\n  }\n  \n  if (Array.isArray(data)) {\n    return data.map(item => `${item.id}: ${item.name}`).join(\"\\n\");\n  } else {\n    return `${data.id}: ${data.name}`;\n  }\n}\n\nexport function serializeEntity(entity: ODataEntity, options: SerializationOptions = {}): Record<string, unknown> {\n  const { annotations = false, includeAnnotations = [], excludeAnnotations = [] } = options;\n  \n  const serialized: Record<string, unknown> = { ...entity };\n  \n  if (annotations) {\n    // Add OData annotations\n    serialized[\"@odata.id\"] = `Products(${entity.id})`;\n    serialized[\"@odata.etag\"] = `\"etag-${entity.id}\"`;\n    serialized[\"@odata.editLink\"] = `Products(${entity.id})`;\n  }\n  \n  // Add custom annotations\n  if (includeAnnotations.length > 0) {\n    includeAnnotations.forEach(annotation => {\n      serialized[annotation] = `annotation-value-${annotation}`;\n    });\n  }\n  \n  // Remove excluded annotations\n  excludeAnnotations.forEach(annotation => {\n    delete serialized[annotation];\n  });\n  \n  return serialized;\n}\n\nexport function serializeMetadata(edmModel: unknown, options: SerializationOptions = {}): string {\n  const { metadata = \"full\" } = options;\n  \n  if (metadata === \"none\") {\n    return \"\";\n  }\n  \n  // Simplified metadata serialization\n  return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<edmx:Edmx xmlns:edmx=\"http://docs.oasis-open.org/odata/ns/edmx\" Version=\"4.0\">\n  <edmx:DataServices>\n    <Schema xmlns=\"http://docs.oasis-open.org/odata/ns/edm\" Namespace=\"Default\">\n      <EntityType Name=\"Product\">\n        <Key>\n          <PropertyRef Name=\"Id\"/>\n        </Key>\n        <Property Name=\"Id\" Type=\"Edm.Int32\" Nullable=\"false\"/>\n        <Property Name=\"Name\" Type=\"Edm.String\" MaxLength=\"255\"/>\n        <Property Name=\"Price\" Type=\"Edm.Decimal\" Precision=\"10\" Scale=\"2\"/>\n        <Property Name=\"CategoryId\" Type=\"Edm.Int32\"/>\n      </EntityType>\n      <EntityContainer Name=\"Container\">\n        <EntitySet Name=\"Products\" EntityType=\"Default.Product\"/>\n      </EntityContainer>\n    </Schema>\n  </edmx:DataServices>\n</edmx:Edmx>`;\n}\n\nexport function serializeServiceDocument(options: SerializationOptions = {}): SerializedResponse {\n  const { serviceRoot = \"https://api.example.com/odata\" } = options;\n  \n  return {\n    \"@odata.context\": `${serviceRoot}/$metadata`,\n    value: [\n      {\n        name: \"Products\",\n        kind: \"EntitySet\",\n        url: \"Products\"\n      },\n      {\n        name: \"Categories\",\n        kind: \"EntitySet\", \n        url: \"Categories\"\n      }\n    ]\n  };\n}\n\nexport function serializeError(error: Error, options: SerializationOptions = {}): SerializedResponse {\n  // Use options to avoid unused variable warning\n  if (options.format) {\n    // Format is available for future use\n  }\n  \n  return {\n    error: {\n      code: \"500\",\n      message: error.message,\n      target: \"ODataService\"\n    }\n  };\n}\n\nexport function getSupportedFormats(): string[] {\n  return [\"json\", \"xml\", \"atom\", \"csv\", \"text\"];\n}\n\nexport function validateFormat(format: string): boolean {\n  return getSupportedFormats().includes(format);\n}\n\nexport function getContentType(format: string): string {\n  const contentTypes: Record<string, string> = {\n    json: \"application/json\",\n    xml: \"application/xml\",\n    atom: \"application/atom+xml\",\n    csv: \"text/csv\",\n    text: \"text/plain\"\n  };\n  \n  return contentTypes[format] || \"application/json\";\n}\n\nexport function serializeWithFormat(data: ODataEntity | ODataEntity[], format: string, options: SerializationOptions = {}): string | SerializedResponse {\n  switch (format.toLowerCase()) {\n    case \"json\":\n      return serializeToJson(data, options);\n    case \"xml\":\n      return serializeToXml(data, options);\n    case \"atom\":\n      return serializeToAtom(data, options);\n    case \"csv\":\n      return serializeToCsv(Array.isArray(data) ? data : [data], options);\n    case \"text\":\n      return serializeToText(data, options);\n    default:\n      throw new Error(`Unsupported format: ${format}`);\n  }\n}\n"],"names":["composeMiddlewares","middlewares","handler","middleware","mergeMiddlewareOptions","defaults","overrides","getMiddlewareContext","request","setMiddlewareContext","context","parseODataQuery","query","opts","sel","s","orderby","term","prop","dir","top","skip","count","filter","expand","e","DEFAULT_PARSE_OPTIONS","odataParse","options","event","parsedOptions","serviceRoot","validateQueryOptions","error","model","property","isValidPropertyPath","expandItem","isValidNavigationProperty","orderItem","propertyPath","entityType","navigationPath","nav","applySelect","row","select","out","p","projectArray","rows","expandData","data","item","expanded","navigationProperty","nestedData","DEFAULT_SHAPE_OPTIONS","odataShape","responseData","shapedData","applyDataShaping","queryOptions","shapeCollection","shapeEntity","entities","shapedEntities","entity","shapedEntity","applyExpansion","expandItems","depth","expandedEntity","resolver","navigationData","nestedContext","parseFilterExpression","parts","splitByOperator","comparisonOps","op","funcMatch","funcName","argsStr","args","arg","str","operator","inQuotes","i","char","evaluateExpression","expr","getPropertyValue","left","right","evaluateComparison","leftResult","rightResult","evaluateLogical","evaluateFunction","value","part","argValues","substring","prefix","suffix","start","length","v","date","filterArray","expression","orderArray","copy","a","b","av","bv","paginateArray","DEFAULT_FILTER_OPTIONS","odataFilter","filteredData","applyFilteringAndOrdering","filterAndOrderCollection","filterAndOrderEntity","filteredEntities","processedEntity","key","collectionOptions","getCollectionOptionsForProperty","propertyName","DEFAULT_PAGINATION_OPTIONS","odataPagination","paginatedData","applyPagination","paginateCollection","addCountToEntity","totalCount","paginatedEntities","validatedTop","validateTopLimit","validatedSkip","result","generateContextUrl","generateNextLink","entitySet","path","nextQuery","queryString","serializeCollection","contextUrl","nextLink","DEFAULT_SERIALIZE_OPTIONS","odataSerialize","serializedData","applySerialization","addODataHeaders","serializeCollectionResponse","serializeEntityResponse","serializePrimitiveResponse","generateEntityId","entityId","currentSkip","currentTop","response","ODataBadRequest","__publicField","ODataInternalServerError","toODataError","err","message","validateSelectParameters","edmModel","entityTypeDef","et","validProperties","validateFilterExpression","parenCount","propertyMatches","match","validateOrderByProperties","orderByItem","validateExpandNavigationProperties","validNavigationProperties","np","validateEdmModelConstraints","requiredProperties","getHttpStatusCode","isValidationError","isServerError","DEFAULT_ERROR_OPTIONS","odataError","customResult","errorHandlingError","functionRegistry","actionRegistry","params","categoryId","minPrice","basePrice","discount","address","shippingRates","quantities","totalItems","sum","qty","maxCount","maxPrice","category","status","warrantyPeriod","location","id","name","price","productId","newPrice","updates","update","recipients","toLocation","scheduledDate","area","items","productIds","callFunction","functionName","parameters","func","callAction","actionName","action","callBoundFunction","boundParams","callBoundAction","registerFunction","implementation","registerAction","getFunctionMetadata","getActionMetadata","validateFunctionParameters","requiredParams","param","validateActionParameters","executeFunctionImport","functionImportName","executeActionImport","actionImportName","getAvailableFunctions","getAvailableActions","DEFAULT_FUNCTIONS_OPTIONS","odataFunctions","functionMatch","actionMatch","entityKey","generateMetadata","metadata","complexType","complexTypeDef","enumType","enumDef","member","funcDef","actionDef","containerName","singleton","funcImport","actionImport","generateServiceDocument","serviceDoc","DEFAULT_METADATA_OPTIONS","odataMetadata","queryParams","contentType","serviceDocument","searchData","searchTerm","searchTerms","field","fieldValue","min","max","valueLower","pattern","baseTerm","computeData","computed","computeExpr","leftVal","rightVal","threshold","trueVal","falseVal","fieldVal","applyData","groups","aVal","bVal","EDM_MODEL","queryWithConformance","conformance","applyConformanceToEntity","applyConformanceToCollection","acc","orderbyParts","direction","getServiceDocument","getMetadataDocument","validateConformanceLevel","level","getSupportedQueryOptions","checkQueryOptionSupport","queryOption","callFunctionImport","callActionImport","executeBatch","batch","operation","index","validateConformance","missingFeatures","DEFAULT_CONFORMANCE_OPTIONS","odataConformance","requestedLevel","conformanceLevel","headers","features","getAvailableFeatures","DEFAULT_OPTIONS","odata","odataCore","odataFull","odataLight","odataReadOnly","odataWrite","createMiddlewareArray","include","exclude","allMiddlewares","middlewareNames","excludedNames","ODataErrorHandler","code","target","details","validateQueryParameters","validateAuthentication","auth","validatePermissions","requiredPermission","validateResourceExists","resource","resourceName","validateHttpMethod","method","allowedMethods","validateContentType","allowedTypes","validateEntityConstraints","constraints","constraint","validateETagMatch","etag","validateRequestSize","requestSize","maxSize","validateQueryComplexity","maxComplexity","handleTimeout","timeoutMs","resolve","reject","timer","handleConcurrentModification","handleRateLimit","requests","limit","handleServiceUnavailable","handleNotImplemented","feature","handleBadGateway","handleInternalError","createEntity","collection","processLargeData","estimatedSize","queryWithLimit","queryWithDepth","queryWithComplexity","queryWithInjection","queryWithXSS","queryWithPathTraversal","queryWithCSRF","queryWithFallback","queryWithRetry","queryWithDegradation","serializeToJson","isCollection","nextSkip","serializeEntity","serializeToXml","xml","serializeToAtom","serializeToCsv","csvRows","values","header","serializeToText","annotations","includeAnnotations","excludeAnnotations","serialized","annotation","serializeMetadata","serializeServiceDocument","serializeError","getSupportedFormats","validateFormat","format","getContentType","serializeWithFormat"],"mappings":"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"}