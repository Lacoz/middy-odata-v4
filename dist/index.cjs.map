{"version":3,"file":"index.cjs","sources":["../src/core/parse.ts","../src/middleware/index.ts","../src/core/errors.ts","../src/core/shape.ts","../src/core/filter-order.ts","../src/core/serialize.ts"],"sourcesContent":["import type { ODataQueryOptions } from \"./types\";\n\nexport function parseODataQuery(query: Record<string, string | undefined>): ODataQueryOptions {\n  const opts: ODataQueryOptions = {};\n  const sel = query[\"$select\"];\n  if (sel) opts.select = sel.split(\",\").map((s) => s.trim()).filter(Boolean);\n  const orderby = query[\"$orderby\"];\n  if (orderby) {\n    opts.orderby = orderby.split(\",\").map((term) => {\n      const [prop, dir] = term.trim().split(/\\s+/);\n      return { property: prop, direction: (dir?.toLowerCase() === \"desc\" ? \"desc\" : \"asc\") };\n    });\n  }\n  const top = query[\"$top\"];\n  if (top !== undefined) opts.top = Math.max(0, Number(top));\n  const skip = query[\"$skip\"];\n  if (skip !== undefined) opts.skip = Math.max(0, Number(skip));\n  const count = query[\"$count\"];\n  if (count !== undefined) opts.count = String(count).toLowerCase() === \"true\";\n  const filter = query[\"$filter\"];\n  if (filter) opts.filter = filter;\n  const expand = query[\"$expand\"];\n  if (expand) {\n    opts.expand = expand.split(\",\").map((e) => ({ path: e.trim() }));\n  }\n  return opts;\n}\n","import type { MiddlewareObj } from \"@middy/core\";\nimport type { ODataRequestContext, ODataQueryOptions, EdmModel } from \"../core/types\";\nimport { parseODataQuery } from \"../core/parse\";\n\nexport interface ODataMiddlewareOptions {\n  model: EdmModel;\n  serviceRoot: string | ((event: any) => string);\n  enable?: {\n    compute?: boolean;\n    apply?: boolean;\n    search?: boolean;\n  };\n  defaults?: {\n    maxTop?: number;\n    defaultTop?: number;\n  };\n}\n\nexport function odata(options: ODataMiddlewareOptions): MiddlewareObj {\n  return {\n    before: async (request: any) => {\n      const event = request.event ?? {};\n      const query: Record<string, string> = event.rawQueryString\n        ? Object.fromEntries(new URLSearchParams(event.rawQueryString))\n        : (event.queryStringParameters || {});\n      const opts: ODataQueryOptions = parseODataQuery(query);\n      const serviceRoot = typeof options.serviceRoot === \"function\" ? options.serviceRoot(event) : options.serviceRoot;\n      const ctx: ODataRequestContext = {\n        model: options.model,\n        serviceRoot,\n        entitySet: undefined,\n        options: opts,\n      };\n      request.internal = request.internal || {};\n      request.internal.odata = ctx;\n    },\n  };\n}\n","import type { ODataErrorPayload } from \"./types\";\n\nexport class ODataBadRequest extends Error {\n  statusCode = 400;\n  code = \"BadRequest\";\n}\n\nexport class ODataInternalServerError extends Error {\n  statusCode = 500;\n  code = \"InternalServerError\";\n}\n\nexport function toODataError(err: unknown, message?: string): ODataErrorPayload {\n  if (err && typeof err === \"object\" && \"statusCode\" in err && \"message\" in err) {\n    const e = err as any;\n    return { error: { code: e.code ?? String(e.statusCode), message: e.message } };\n  }\n  return { error: { code: \"InternalServerError\", message: message ?? \"An error occurred\" } };\n}\n","import type { ODataEntity, ODataQueryOptions } from \"./types\";\n\nexport function applySelect<T extends ODataEntity>(row: T, select?: string[]): Partial<T> {\n  if (!select || select.length === 0) return { ...row };\n  const out: Record<string, unknown> = {};\n  for (const p of select) if (p in row) out[p] = (row as any)[p];\n  return out as Partial<T>;\n}\n\nexport function projectArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): Partial<T>[] {\n  return rows.map((r) => applySelect(r, options.select));\n}\n\n// Expand navigation properties\nexport function expandData<T extends Record<string, any>>(\n  data: T | T[],\n  options: ODataQueryOptions\n): T | T[] {\n  if (!options.expand || options.expand.length === 0) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map(item => expandData(item, options) as T);\n  }\n\n  const expanded = { ...data } as any;\n  \n  for (const expandItem of options.expand) {\n    const navigationProperty = expandItem.path;\n    \n    // Simple expansion - in a real implementation, this would resolve navigation properties\n    // For now, we'll just ensure the property exists\n    if (navigationProperty && !(navigationProperty in expanded)) {\n      // Create a placeholder for the expanded property\n      expanded[navigationProperty] = null;\n    }\n    \n    // Handle nested query options in expansion\n    if (expandItem.options) {\n      const nestedData = expanded[navigationProperty];\n      if (nestedData) {\n        expanded[navigationProperty] = expandData(nestedData, expandItem.options);\n      }\n    }\n  }\n  \n  return expanded as T;\n}\n","import type { ODataEntity, ODataQueryOptions } from \"./types\";\n\n// Simple filter expression parser and evaluator\ninterface FilterExpression {\n  type: 'comparison' | 'logical' | 'function' | 'property' | 'literal';\n  operator?: string;\n  left?: FilterExpression;\n  right?: FilterExpression;\n  property?: string;\n  value?: any;\n  function?: string;\n  args?: FilterExpression[];\n}\n\nfunction parseFilterExpression(filter: string): FilterExpression {\n  // Simple parser for basic filter expressions\n  // This is a simplified implementation - a full OData parser would be much more complex\n  \n  // Handle parentheses and logical operators\n  if (filter.includes(' and ')) {\n    const parts = splitByOperator(filter, ' and ');\n    return {\n      type: 'logical',\n      operator: 'and',\n      left: parseFilterExpression(parts[0].trim()),\n      right: parseFilterExpression(parts[1].trim())\n    };\n  }\n  \n  if (filter.includes(' or ')) {\n    const parts = splitByOperator(filter, ' or ');\n    return {\n      type: 'logical',\n      operator: 'or',\n      left: parseFilterExpression(parts[0].trim()),\n      right: parseFilterExpression(parts[1].trim())\n    };\n  }\n  \n  // Handle comparison operators\n  const comparisonOps = [' eq ', ' ne ', ' gt ', ' ge ', ' lt ', ' le '];\n  for (const op of comparisonOps) {\n    if (filter.includes(op)) {\n      const parts = filter.split(op);\n      if (parts.length === 2) {\n        return {\n          type: 'comparison',\n          operator: op.trim(),\n          left: parseFilterExpression(parts[0].trim()),\n          right: parseFilterExpression(parts[1].trim())\n        };\n      }\n    }\n  }\n  \n  // Handle functions\n  if (filter.includes('(') && filter.includes(')')) {\n    const funcMatch = filter.match(/^(\\w+)\\((.+)\\)$/);\n    if (funcMatch) {\n      const [, funcName, argsStr] = funcMatch;\n      const args = argsStr.split(',').map(arg => parseFilterExpression(arg.trim()));\n      return {\n        type: 'function',\n        function: funcName,\n        args\n      };\n    }\n  }\n  \n  // Handle literals\n  if (filter.startsWith(\"'\") && filter.endsWith(\"'\")) {\n    return {\n      type: 'literal',\n      value: filter.slice(1, -1)\n    };\n  }\n  \n  if (filter === 'null') {\n    return {\n      type: 'literal',\n      value: null\n    };\n  }\n  \n  if (!isNaN(Number(filter))) {\n    return {\n      type: 'literal',\n      value: Number(filter)\n    };\n  }\n  \n  // Handle properties\n  return {\n    type: 'property',\n    property: filter\n  };\n}\n\nfunction splitByOperator(str: string, operator: string): string[] {\n  let depth = 0;\n  let inQuotes = false;\n  \n  for (let i = 0; i < str.length - operator.length + 1; i++) {\n    const char = str[i];\n    if (char === \"'\") inQuotes = !inQuotes;\n    if (inQuotes) continue;\n    \n    if (char === '(') depth++;\n    if (char === ')') depth--;\n    \n    if (depth === 0 && str.slice(i, i + operator.length) === operator) {\n      return [str.slice(0, i), str.slice(i + operator.length)];\n    }\n  }\n  \n  return [str];\n}\n\nfunction evaluateExpression(expr: FilterExpression, entity: any): any {\n  switch (expr.type) {\n    case 'property':\n      return getPropertyValue(entity, expr.property!);\n    \n    case 'literal':\n      return expr.value;\n    \n    case 'comparison':\n      const left = evaluateExpression(expr.left!, entity);\n      const right = evaluateExpression(expr.right!, entity);\n      return evaluateComparison(left, expr.operator!, right);\n    \n    case 'logical':\n      const leftResult = evaluateExpression(expr.left!, entity);\n      const rightResult = evaluateExpression(expr.right!, entity);\n      return evaluateLogical(leftResult, expr.operator!, rightResult);\n    \n    case 'function':\n      return evaluateFunction(expr.function!, expr.args!, entity);\n    \n    default:\n      return false;\n  }\n}\n\nfunction getPropertyValue(entity: any, property: string): any {\n  // Handle nested properties (e.g., \"address/city\")\n  const parts = property.split('/');\n  let value = entity;\n  for (const part of parts) {\n    if (value && typeof value === 'object') {\n      value = value[part];\n    } else {\n      return undefined;\n    }\n  }\n  return value;\n}\n\nfunction evaluateComparison(left: any, operator: string, right: any): boolean {\n  switch (operator) {\n    case 'eq': return left === right;\n    case 'ne': return left !== right;\n    case 'gt': return left > right;\n    case 'ge': return left >= right;\n    case 'lt': return left < right;\n    case 'le': return left <= right;\n    default: return false;\n  }\n}\n\nfunction evaluateLogical(left: boolean, operator: string, right: boolean): boolean {\n  switch (operator) {\n    case 'and': return left && right;\n    case 'or': return left || right;\n    default: return false;\n  }\n}\n\nfunction evaluateFunction(funcName: string, args: FilterExpression[], entity: any): any {\n  const argValues = args.map(arg => evaluateExpression(arg, entity));\n  \n  switch (funcName) {\n    case 'contains':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const substring = String(argValues[1] || '');\n        return str.includes(substring);\n      }\n      return false;\n    \n    case 'startswith':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const prefix = String(argValues[1] || '');\n        return str.startsWith(prefix);\n      }\n      return false;\n    \n    case 'endswith':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const suffix = String(argValues[1] || '');\n        return str.endsWith(suffix);\n      }\n      return false;\n    \n    case 'length':\n      if (argValues.length >= 1) {\n        const str = String(argValues[0] || '');\n        return str.length;\n      }\n      return 0;\n    \n    case 'tolower':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').toLowerCase();\n      }\n      return '';\n    \n    case 'toupper':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').toUpperCase();\n      }\n      return '';\n    \n    case 'trim':\n      if (argValues.length >= 1) {\n        return String(argValues[0] || '').trim();\n      }\n      return '';\n    \n    case 'substring':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const start = Number(argValues[1]) || 0;\n        if (argValues.length >= 3) {\n          const length = Number(argValues[2]) || 0;\n          return str.substring(start, start + length);\n        }\n        return str.substring(start);\n      }\n      return '';\n    \n    case 'indexof':\n      if (argValues.length >= 2) {\n        const str = String(argValues[0] || '');\n        const substring = String(argValues[1] || '');\n        return str.indexOf(substring);\n      }\n      return -1;\n    \n    case 'concat':\n      return argValues.map(v => String(v || '')).join('');\n    \n    case 'year':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getFullYear();\n      }\n      return 0;\n    \n    case 'month':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getMonth() + 1;\n      }\n      return 0;\n    \n    case 'day':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getDate();\n      }\n      return 0;\n    \n    case 'hour':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getHours();\n      }\n      return 0;\n    \n    case 'minute':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getMinutes();\n      }\n      return 0;\n    \n    case 'second':\n      if (argValues.length >= 1) {\n        const date = new Date(argValues[0]);\n        return isNaN(date.getTime()) ? 0 : date.getSeconds();\n      }\n      return 0;\n    \n    case 'round':\n      if (argValues.length >= 1) {\n        return Math.round(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'floor':\n      if (argValues.length >= 1) {\n        return Math.floor(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'ceiling':\n      if (argValues.length >= 1) {\n        return Math.ceil(Number(argValues[0]) || 0);\n      }\n      return 0;\n    \n    case 'now':\n      return new Date().toISOString();\n    \n    case 'maxdatetime':\n      return new Date('9999-12-31T23:59:59.999Z').toISOString();\n    \n    case 'mindatetime':\n      return new Date('0001-01-01T00:00:00.000Z').toISOString();\n    \n    default:\n      return false;\n  }\n}\n\nexport function filterArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.filter) return rows;\n  \n  try {\n    const expression = parseFilterExpression(options.filter);\n    return rows.filter(row => evaluateExpression(expression, row));\n  } catch (error) {\n    // If filter parsing fails, return all rows\n    console.warn('Filter parsing failed:', error);\n    return rows;\n  }\n}\n\nexport function orderArray<T extends ODataEntity>(rows: T[], options: ODataQueryOptions): T[] {\n  if (!options.orderby || options.orderby.length === 0) return rows;\n  const copy = [...rows];\n  copy.sort((a, b) => {\n    for (const term of options.orderby!) {\n      const av = (a as any)[term.property];\n      const bv = (b as any)[term.property];\n      if (av == null && bv == null) continue;\n      if (av == null) return term.direction === \"asc\" ? -1 : 1;\n      if (bv == null) return term.direction === \"asc\" ? 1 : -1;\n      if (av < bv) return term.direction === \"asc\" ? -1 : 1;\n      if (av > bv) return term.direction === \"asc\" ? 1 : -1;\n    }\n    return 0;\n  });\n  return copy;\n}\n\nexport function paginateArray<T>(rows: T[], options: ODataQueryOptions): T[] {\n  const skip = options.skip ?? 0;\n  const top = options.top ?? rows.length;\n  return rows.slice(skip, skip + top);\n}\n","import type { ODataCollectionResponse } from \"./types\";\n\nexport function serializeCollection<T>(contextUrl: string, value: T[], count?: number, nextLink?: string): ODataCollectionResponse<T> {\n  const out: ODataCollectionResponse<T> = {\n    \"@odata.context\": contextUrl,\n    value,\n  };\n  if (typeof count === \"number\") out[\"@odata.count\"] = count;\n  if (nextLink) out[\"@odata.nextLink\"] = nextLink;\n  return out;\n}\n"],"names":["parseODataQuery","query","opts","sel","s","orderby","term","prop","dir","top","skip","count","filter","expand","e","odata","options","request","event","serviceRoot","ctx","ODataBadRequest","__publicField","ODataInternalServerError","toODataError","err","message","applySelect","row","select","out","p","projectArray","rows","expandData","data","item","expanded","expandItem","navigationProperty","nestedData","parseFilterExpression","parts","splitByOperator","comparisonOps","op","funcMatch","funcName","argsStr","args","arg","str","operator","depth","inQuotes","i","char","evaluateExpression","expr","entity","getPropertyValue","left","right","evaluateComparison","leftResult","rightResult","evaluateLogical","evaluateFunction","property","value","part","argValues","substring","prefix","suffix","start","length","v","date","filterArray","expression","error","orderArray","copy","a","b","av","bv","paginateArray","serializeCollection","contextUrl","nextLink"],"mappings":"oPAEO,SAASA,EAAgBC,EAA8D,CAC5F,MAAMC,EAA0B,CAAA,EAC1BC,EAAMF,EAAM,QACdE,IAAKD,EAAK,OAASC,EAAI,MAAM,GAAG,EAAE,IAAKC,GAAMA,EAAE,KAAA,CAAM,EAAE,OAAO,OAAO,GACzE,MAAMC,EAAUJ,EAAM,SAClBI,IACFH,EAAK,QAAUG,EAAQ,MAAM,GAAG,EAAE,IAAKC,GAAS,CAC9C,KAAM,CAACC,EAAMC,CAAG,EAAIF,EAAK,KAAA,EAAO,MAAM,KAAK,EAC3C,MAAO,CAAE,SAAUC,EAAM,UAAYC,GAAK,gBAAkB,OAAS,OAAS,KAAA,CAChF,CAAC,GAEH,MAAMC,EAAMR,EAAM,KACdQ,IAAQ,SAAWP,EAAK,IAAM,KAAK,IAAI,EAAG,OAAOO,CAAG,CAAC,GACzD,MAAMC,EAAOT,EAAM,MACfS,IAAS,SAAWR,EAAK,KAAO,KAAK,IAAI,EAAG,OAAOQ,CAAI,CAAC,GAC5D,MAAMC,EAAQV,EAAM,OAChBU,IAAU,SAAWT,EAAK,MAAQ,OAAOS,CAAK,EAAE,gBAAkB,QACtE,MAAMC,EAASX,EAAM,QACjBW,MAAa,OAASA,GAC1B,MAAMC,EAASZ,EAAM,QACrB,OAAIY,IACFX,EAAK,OAASW,EAAO,MAAM,GAAG,EAAE,IAAKC,IAAO,CAAE,KAAMA,EAAE,KAAA,GAAS,GAE1DZ,CACT,CCRO,SAASa,EAAMC,EAAgD,CACpE,MAAO,CACL,OAAQ,MAAOC,GAAiB,CAC9B,MAAMC,EAAQD,EAAQ,OAAS,CAAA,EACzBhB,EAAgCiB,EAAM,eACxC,OAAO,YAAY,IAAI,gBAAgBA,EAAM,cAAc,CAAC,EAC3DA,EAAM,uBAAyB,CAAA,EAC9BhB,EAA0BF,EAAgBC,CAAK,EAC/CkB,EAAc,OAAOH,EAAQ,aAAgB,WAAaA,EAAQ,YAAYE,CAAK,EAAIF,EAAQ,YAC/FI,EAA2B,CAC/B,MAAOJ,EAAQ,MACf,YAAAG,EACA,UAAW,OACX,QAASjB,CAAA,EAEXe,EAAQ,SAAWA,EAAQ,UAAY,CAAA,EACvCA,EAAQ,SAAS,MAAQG,CAC3B,CAAA,CAEJ,CCnCO,MAAMC,UAAwB,KAAM,CAApC,kCACLC,EAAA,kBAAa,KACbA,EAAA,YAAO,cACT,CAEO,MAAMC,UAAiC,KAAM,CAA7C,kCACLD,EAAA,kBAAa,KACbA,EAAA,YAAO,uBACT,CAEO,SAASE,EAAaC,EAAcC,EAAqC,CAC9E,GAAID,GAAO,OAAOA,GAAQ,UAAY,eAAgBA,GAAO,YAAaA,EAAK,CAC7E,MAAMX,EAAIW,EACV,MAAO,CAAE,MAAO,CAAE,KAAMX,EAAE,MAAQ,OAAOA,EAAE,UAAU,EAAG,QAASA,EAAE,QAAQ,CAC7E,CACA,MAAO,CAAE,MAAO,CAAE,KAAM,sBAAuB,QAASY,GAAW,oBAAoB,CACzF,CChBO,SAASC,EAAmCC,EAAQC,EAA+B,CACxF,GAAI,CAACA,GAAUA,EAAO,SAAW,EAAG,MAAO,CAAE,GAAGD,CAAA,EAChD,MAAME,EAA+B,CAAA,EACrC,UAAWC,KAAKF,EAAYE,KAAKH,IAAKE,EAAIC,CAAC,EAAKH,EAAYG,CAAC,GAC7D,OAAOD,CACT,CAEO,SAASE,EAAoCC,EAAWjB,EAA0C,CACvG,OAAOiB,EAAK,IAAK,GAAMN,EAAY,EAAGX,EAAQ,MAAM,CAAC,CACvD,CAGO,SAASkB,EACdC,EACAnB,EACS,CACT,GAAI,CAACA,EAAQ,QAAUA,EAAQ,OAAO,SAAW,EAC/C,OAAOmB,EAGT,GAAI,MAAM,QAAQA,CAAI,EACpB,OAAOA,EAAK,IAAIC,GAAQF,EAAWE,EAAMpB,CAAO,CAAM,EAGxD,MAAMqB,EAAW,CAAE,GAAGF,CAAA,EAEtB,UAAWG,KAActB,EAAQ,OAAQ,CACvC,MAAMuB,EAAqBD,EAAW,KAUtC,GANIC,GAAsB,EAAEA,KAAsBF,KAEhDA,EAASE,CAAkB,EAAI,MAI7BD,EAAW,QAAS,CACtB,MAAME,EAAaH,EAASE,CAAkB,EAC1CC,IACFH,EAASE,CAAkB,EAAIL,EAAWM,EAAYF,EAAW,OAAO,EAE5E,CACF,CAEA,OAAOD,CACT,CClCA,SAASI,EAAsB7B,EAAkC,CAK/D,GAAIA,EAAO,SAAS,OAAO,EAAG,CAC5B,MAAM8B,EAAQC,EAAgB/B,EAAQ,OAAO,EAC7C,MAAO,CACL,KAAM,UACN,SAAU,MACV,KAAM6B,EAAsBC,EAAM,CAAC,EAAE,MAAM,EAC3C,MAAOD,EAAsBC,EAAM,CAAC,EAAE,MAAM,CAAA,CAEhD,CAEA,GAAI9B,EAAO,SAAS,MAAM,EAAG,CAC3B,MAAM8B,EAAQC,EAAgB/B,EAAQ,MAAM,EAC5C,MAAO,CACL,KAAM,UACN,SAAU,KACV,KAAM6B,EAAsBC,EAAM,CAAC,EAAE,MAAM,EAC3C,MAAOD,EAAsBC,EAAM,CAAC,EAAE,MAAM,CAAA,CAEhD,CAGA,MAAME,EAAgB,CAAC,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,MAAM,EACrE,UAAWC,KAAMD,EACf,GAAIhC,EAAO,SAASiC,CAAE,EAAG,CACvB,MAAMH,EAAQ9B,EAAO,MAAMiC,CAAE,EAC7B,GAAIH,EAAM,SAAW,EACnB,MAAO,CACL,KAAM,aACN,SAAUG,EAAG,KAAA,EACb,KAAMJ,EAAsBC,EAAM,CAAC,EAAE,MAAM,EAC3C,MAAOD,EAAsBC,EAAM,CAAC,EAAE,MAAM,CAAA,CAGlD,CAIF,GAAI9B,EAAO,SAAS,GAAG,GAAKA,EAAO,SAAS,GAAG,EAAG,CAChD,MAAMkC,EAAYlC,EAAO,MAAM,iBAAiB,EAChD,GAAIkC,EAAW,CACb,KAAM,CAAA,CAAGC,EAAUC,CAAO,EAAIF,EACxBG,EAAOD,EAAQ,MAAM,GAAG,EAAE,IAAIE,GAAOT,EAAsBS,EAAI,KAAA,CAAM,CAAC,EAC5E,MAAO,CACL,KAAM,WACN,SAAUH,EACV,KAAAE,CAAA,CAEJ,CACF,CAGA,OAAIrC,EAAO,WAAW,GAAG,GAAKA,EAAO,SAAS,GAAG,EACxC,CACL,KAAM,UACN,MAAOA,EAAO,MAAM,EAAG,EAAE,CAAA,EAIzBA,IAAW,OACN,CACL,KAAM,UACN,MAAO,IAAA,EAIN,MAAM,OAAOA,CAAM,CAAC,EAQlB,CACL,KAAM,WACN,SAAUA,CAAA,EATH,CACL,KAAM,UACN,MAAO,OAAOA,CAAM,CAAA,CAS1B,CAEA,SAAS+B,EAAgBQ,EAAaC,EAA4B,CAChE,IAAIC,EAAQ,EACRC,EAAW,GAEf,QAASC,EAAI,EAAGA,EAAIJ,EAAI,OAASC,EAAS,OAAS,EAAGG,IAAK,CACzD,MAAMC,EAAOL,EAAII,CAAC,EAElB,GADIC,IAAS,MAAKF,EAAW,CAACA,GAC1B,CAAAA,IAEAE,IAAS,KAAKH,IACdG,IAAS,KAAKH,IAEdA,IAAU,GAAKF,EAAI,MAAMI,EAAGA,EAAIH,EAAS,MAAM,IAAMA,GACvD,MAAO,CAACD,EAAI,MAAM,EAAGI,CAAC,EAAGJ,EAAI,MAAMI,EAAIH,EAAS,MAAM,CAAC,CAE3D,CAEA,MAAO,CAACD,CAAG,CACb,CAEA,SAASM,EAAmBC,EAAwBC,EAAkB,CACpE,OAAQD,EAAK,KAAA,CACX,IAAK,WACH,OAAOE,EAAiBD,EAAQD,EAAK,QAAS,EAEhD,IAAK,UACH,OAAOA,EAAK,MAEd,IAAK,aACH,MAAMG,EAAOJ,EAAmBC,EAAK,KAAOC,CAAM,EAC5CG,EAAQL,EAAmBC,EAAK,MAAQC,CAAM,EACpD,OAAOI,EAAmBF,EAAMH,EAAK,SAAWI,CAAK,EAEvD,IAAK,UACH,MAAME,EAAaP,EAAmBC,EAAK,KAAOC,CAAM,EAClDM,EAAcR,EAAmBC,EAAK,MAAQC,CAAM,EAC1D,OAAOO,EAAgBF,EAAYN,EAAK,SAAWO,CAAW,EAEhE,IAAK,WACH,OAAOE,EAAiBT,EAAK,SAAWA,EAAK,KAAOC,CAAM,EAE5D,QACE,MAAO,EAAA,CAEb,CAEA,SAASC,EAAiBD,EAAaS,EAAuB,CAE5D,MAAM1B,EAAQ0B,EAAS,MAAM,GAAG,EAChC,IAAIC,EAAQV,EACZ,UAAWW,KAAQ5B,EACjB,GAAI2B,GAAS,OAAOA,GAAU,SAC5BA,EAAQA,EAAMC,CAAI,MAElB,QAGJ,OAAOD,CACT,CAEA,SAASN,EAAmBF,EAAWT,EAAkBU,EAAqB,CAC5E,OAAQV,EAAA,CACN,IAAK,KAAM,OAAOS,IAASC,EAC3B,IAAK,KAAM,OAAOD,IAASC,EAC3B,IAAK,KAAM,OAAOD,EAAOC,EACzB,IAAK,KAAM,OAAOD,GAAQC,EAC1B,IAAK,KAAM,OAAOD,EAAOC,EACzB,IAAK,KAAM,OAAOD,GAAQC,EAC1B,QAAS,MAAO,EAAA,CAEpB,CAEA,SAASI,EAAgBL,EAAeT,EAAkBU,EAAyB,CACjF,OAAQV,EAAA,CACN,IAAK,MAAO,OAAOS,GAAQC,EAC3B,IAAK,KAAM,OAAOD,GAAQC,EAC1B,QAAS,MAAO,EAAA,CAEpB,CAEA,SAASK,EAAiBpB,EAAkBE,EAA0BU,EAAkB,CACtF,MAAMY,EAAYtB,EAAK,OAAWQ,EAAmBP,EAAKS,CAAM,CAAC,EAEjE,OAAQZ,EAAA,CACN,IAAK,WACH,GAAIwB,EAAU,QAAU,EAAG,CACzB,MAAMpB,EAAM,OAAOoB,EAAU,CAAC,GAAK,EAAE,EAC/BC,EAAY,OAAOD,EAAU,CAAC,GAAK,EAAE,EAC3C,OAAOpB,EAAI,SAASqB,CAAS,CAC/B,CACA,MAAO,GAET,IAAK,aACH,GAAID,EAAU,QAAU,EAAG,CACzB,MAAMpB,EAAM,OAAOoB,EAAU,CAAC,GAAK,EAAE,EAC/BE,EAAS,OAAOF,EAAU,CAAC,GAAK,EAAE,EACxC,OAAOpB,EAAI,WAAWsB,CAAM,CAC9B,CACA,MAAO,GAET,IAAK,WACH,GAAIF,EAAU,QAAU,EAAG,CACzB,MAAMpB,EAAM,OAAOoB,EAAU,CAAC,GAAK,EAAE,EAC/BG,EAAS,OAAOH,EAAU,CAAC,GAAK,EAAE,EACxC,OAAOpB,EAAI,SAASuB,CAAM,CAC5B,CACA,MAAO,GAET,IAAK,SACH,OAAIH,EAAU,QAAU,EACV,OAAOA,EAAU,CAAC,GAAK,EAAE,EAC1B,OAEN,EAET,IAAK,UACH,OAAIA,EAAU,QAAU,EACf,OAAOA,EAAU,CAAC,GAAK,EAAE,EAAE,YAAA,EAE7B,GAET,IAAK,UACH,OAAIA,EAAU,QAAU,EACf,OAAOA,EAAU,CAAC,GAAK,EAAE,EAAE,YAAA,EAE7B,GAET,IAAK,OACH,OAAIA,EAAU,QAAU,EACf,OAAOA,EAAU,CAAC,GAAK,EAAE,EAAE,KAAA,EAE7B,GAET,IAAK,YACH,GAAIA,EAAU,QAAU,EAAG,CACzB,MAAMpB,EAAM,OAAOoB,EAAU,CAAC,GAAK,EAAE,EAC/BI,EAAQ,OAAOJ,EAAU,CAAC,CAAC,GAAK,EACtC,GAAIA,EAAU,QAAU,EAAG,CACzB,MAAMK,EAAS,OAAOL,EAAU,CAAC,CAAC,GAAK,EACvC,OAAOpB,EAAI,UAAUwB,EAAOA,EAAQC,CAAM,CAC5C,CACA,OAAOzB,EAAI,UAAUwB,CAAK,CAC5B,CACA,MAAO,GAET,IAAK,UACH,GAAIJ,EAAU,QAAU,EAAG,CACzB,MAAMpB,EAAM,OAAOoB,EAAU,CAAC,GAAK,EAAE,EAC/BC,EAAY,OAAOD,EAAU,CAAC,GAAK,EAAE,EAC3C,OAAOpB,EAAI,QAAQqB,CAAS,CAC9B,CACA,MAAO,GAET,IAAK,SACH,OAAOD,EAAU,IAAIM,GAAK,OAAOA,GAAK,EAAE,CAAC,EAAE,KAAK,EAAE,EAEpD,IAAK,OACH,GAAIN,EAAU,QAAU,EAAG,CACzB,MAAMO,EAAO,IAAI,KAAKP,EAAU,CAAC,CAAC,EAClC,OAAO,MAAMO,EAAK,QAAA,CAAS,EAAI,EAAIA,EAAK,YAAA,CAC1C,CACA,MAAO,GAET,IAAK,QACH,GAAIP,EAAU,QAAU,EAAG,CACzB,MAAMO,EAAO,IAAI,KAAKP,EAAU,CAAC,CAAC,EAClC,OAAO,MAAMO,EAAK,QAAA,CAAS,EAAI,EAAIA,EAAK,WAAa,CACvD,CACA,MAAO,GAET,IAAK,MACH,GAAIP,EAAU,QAAU,EAAG,CACzB,MAAMO,EAAO,IAAI,KAAKP,EAAU,CAAC,CAAC,EAClC,OAAO,MAAMO,EAAK,QAAA,CAAS,EAAI,EAAIA,EAAK,QAAA,CAC1C,CACA,MAAO,GAET,IAAK,OACH,GAAIP,EAAU,QAAU,EAAG,CACzB,MAAMO,EAAO,IAAI,KAAKP,EAAU,CAAC,CAAC,EAClC,OAAO,MAAMO,EAAK,QAAA,CAAS,EAAI,EAAIA,EAAK,SAAA,CAC1C,CACA,MAAO,GAET,IAAK,SACH,GAAIP,EAAU,QAAU,EAAG,CACzB,MAAMO,EAAO,IAAI,KAAKP,EAAU,CAAC,CAAC,EAClC,OAAO,MAAMO,EAAK,QAAA,CAAS,EAAI,EAAIA,EAAK,WAAA,CAC1C,CACA,MAAO,GAET,IAAK,SACH,GAAIP,EAAU,QAAU,EAAG,CACzB,MAAMO,EAAO,IAAI,KAAKP,EAAU,CAAC,CAAC,EAClC,OAAO,MAAMO,EAAK,QAAA,CAAS,EAAI,EAAIA,EAAK,WAAA,CAC1C,CACA,MAAO,GAET,IAAK,QACH,OAAIP,EAAU,QAAU,EACf,KAAK,MAAM,OAAOA,EAAU,CAAC,CAAC,GAAK,CAAC,EAEtC,EAET,IAAK,QACH,OAAIA,EAAU,QAAU,EACf,KAAK,MAAM,OAAOA,EAAU,CAAC,CAAC,GAAK,CAAC,EAEtC,EAET,IAAK,UACH,OAAIA,EAAU,QAAU,EACf,KAAK,KAAK,OAAOA,EAAU,CAAC,CAAC,GAAK,CAAC,EAErC,EAET,IAAK,MACH,OAAO,IAAI,KAAA,EAAO,YAAA,EAEpB,IAAK,cACH,OAAO,IAAI,KAAK,0BAA0B,EAAE,YAAA,EAE9C,IAAK,cACH,OAAO,IAAI,KAAK,0BAA0B,EAAE,YAAA,EAE9C,QACE,MAAO,EAAA,CAEb,CAEO,SAASQ,EAAmC9C,EAAWjB,EAAiC,CAC7F,GAAI,CAACA,EAAQ,OAAQ,OAAOiB,EAE5B,GAAI,CACF,MAAM+C,EAAavC,EAAsBzB,EAAQ,MAAM,EACvD,OAAOiB,EAAK,OAAOL,GAAO6B,EAAmBuB,EAAYpD,CAAG,CAAC,CAC/D,OAASqD,EAAO,CAEd,eAAQ,KAAK,yBAA0BA,CAAK,EACrChD,CACT,CACF,CAEO,SAASiD,EAAkCjD,EAAWjB,EAAiC,CAC5F,GAAI,CAACA,EAAQ,SAAWA,EAAQ,QAAQ,SAAW,EAAG,OAAOiB,EAC7D,MAAMkD,EAAO,CAAC,GAAGlD,CAAI,EACrB,OAAAkD,EAAK,KAAK,CAACC,EAAGC,IAAM,CAClB,UAAW/E,KAAQU,EAAQ,QAAU,CACnC,MAAMsE,EAAMF,EAAU9E,EAAK,QAAQ,EAC7BiF,EAAMF,EAAU/E,EAAK,QAAQ,EACnC,GAAI,EAAAgF,GAAM,MAAQC,GAAM,MACxB,IAAID,GAAM,KAAM,OAAOhF,EAAK,YAAc,MAAQ,GAAK,EACvD,GAAIiF,GAAM,KAAM,OAAOjF,EAAK,YAAc,MAAQ,EAAI,GACtD,GAAIgF,EAAKC,EAAI,OAAOjF,EAAK,YAAc,MAAQ,GAAK,EACpD,GAAIgF,EAAKC,EAAI,OAAOjF,EAAK,YAAc,MAAQ,EAAI,GACrD,CACA,MAAO,EACT,CAAC,EACM6E,CACT,CAEO,SAASK,EAAiBvD,EAAWjB,EAAiC,CAC3E,MAAMN,EAAOM,EAAQ,MAAQ,EACvBP,EAAMO,EAAQ,KAAOiB,EAAK,OAChC,OAAOA,EAAK,MAAMvB,EAAMA,EAAOD,CAAG,CACpC,CCzWO,SAASgF,EAAuBC,EAAoBrB,EAAY1D,EAAgBgF,EAA+C,CACpI,MAAM7D,EAAkC,CACtC,iBAAkB4D,EAClB,MAAArB,CAAA,EAEF,OAAI,OAAO1D,GAAU,WAAUmB,EAAI,cAAc,EAAInB,GACjDgF,IAAU7D,EAAI,iBAAiB,EAAI6D,GAChC7D,CACT"}